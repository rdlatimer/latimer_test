/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//*/*	Matthew Kosnik: mkosnik@uchicago.edu/*/*	This file is copyright (C) 2000 Matthew Kosnik/*/*	This program is free software; you can redistribute it and/or modify it /*	under the terms of version 2 the GNU General Public License as published /*	by the Free Software Foundation./*/*	This program is distributed in the hope that it will be useful, but WITHOUT/*	ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or /*	FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for /*	more details./*/*	To view a copy of the license go to:/*	http://www.fsf.org/copyleft/gpl.html/*	To receive a copy of the GNU General Public License write the Free Software/* 	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA./*/*	Copies of this source code are available without cost from:/*	http://geosci.uchicago.edu/paleo/csource//*/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */#define mak_array_functions#include "array.h"/* return the sum of values in an integer array/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long i_arraysum(int *array, int length){	int i;	int total=0;	for (i=0 ; i<length ; i++)		total += array[i];	return total;}/* return the sum of values in an unsigned long array/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long ul_arraysum(unsigned long *array, int length){	int i;	unsigned long total=0;	for (i=0 ; i<length ; i++)		total += array[i];	return total;}/* return the number of non-zero values in an unsigned long array/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long ul_arraycount(unsigned long *array, int length){	int i;	unsigned long total=0;	for (i=0 ; i<length ; i++)		if (array[i]>0)			total += 1;	return total;}/* returns the minimum value in an integer array/* written M. Kosnik 1999.05.23/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */long i_arraymin(int *array, int n){	long x;	int i;		x = LONG_MAX;	for (i=0 ; i<n ; i++)		if (array[i] < x) 			x = array[i];	return x;}/* returns the maximum value in an integer array/* written M. Kosnik 1999.05.23/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */long i_arraymax(int *array, int n){	long x=0;	int i=0;		x = LONG_MIN;	for (i=0 ; i<n ; i++)		if (array[i] > x) 			x = array[i];	return x;}/* returns the highest cell number with a specified value in an integer array/* written M. Kosnik 1999.05.23/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int i_arraycell(int *array, int n, int value){	int x=0;	int i=0;			for (i=0 ; i<n ; i++)		if (array[i] == value) 			x = i;	return x;}/* returns the minimum value in an unsigned long array/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long ul_arraymin(unsigned long *array, int n){	unsigned long x;	int i;		x = ULONG_MAX;	for (i=0 ; i<n ; i++)		if (array[i] < x) 			x = array[i];	return x;}/* returns the maximum value in an unsigned long array/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long ul_arraymax(unsigned long *array, int n){	unsigned long x=0;	int i=0;		x = 0;	for (i=0 ; i<n ; i++)		if (array[i] > x) 			x = array[i];	return x;}/* return an array of 95% confidence intervals based on array sent, high and low /* a conservative estimate at small sample sizes/* written M. Kosnik 2000.12.10/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long *ul_arrayconfidence(unsigned long *array, int length, float confidence){	int j;	unsigned long *interval;	int hi=0, lo=0;		/* calculate which array cell to select */	/* -1 and -2 are because arrays run from 0 instead of 1 */	lo = trunc((length-(length*confidence))/2) - 1;	hi = (length-lo) - 2;	if (lo < 0) {		lo =0;		hi = length -1;	}	interval=ulvector(2);		/* memory space for ci's */	for (j=0 ; j<2 ; j++)		interval[j]=0;			array = ulshellsort(array,length);	interval[0] = array[lo];			/* select 95% low */	interval[1] = array[hi];			/* select 95% high */	return interval;}/* return an array of means based on matrix sent /* written M. Kosnik 2000.12.10/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */float ul_arraymean(unsigned long *array, int length){	int i;	float answer;	unsigned long total=0;	for (i=0 ; i<length ; i++)		total+=array[i];		answer= (1.0*total)/(1.0*length);		return answer;}/* returns ranked sequence from an unsigned long array/* rank determined by order of first appearance?/* example 4, 3, 4, 6, 5, 2 becomes 1, 2, 1, 3, 4, 5/* written by m. kosnik 1999.09.12/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long *ul_random_to_sequence (unsigned long *listsbin, int lists){	int *bnumbers;						/* list of bin numbers (each bin number appears once) */	int i, j, ng=1;		bnumbers=ivector(lists);	for (i=0 ; i<lists ; i++) 		bnumbers[i] = 0;	bnumbers[0]=listsbin[0];				/* get list of bin numbers */	for (i=0 ; i<lists ; i++) {				/* convert from "real" bin numbers to sequential numbers */		for (j=0 ; j<ng ; j++) 			if (listsbin[i] == bnumbers[j]) {				listsbin[i]=j;				j=INT_MAX;				break;			}		if (j != INT_MAX) {			bnumbers[ng]=listsbin[i];			listsbin[i]=ng;			ng++;		}	}	free_ivector(bnumbers);	listsbin[0]=0;		return listsbin;}/* returns ranked sequence from an unsigned long array/*		for example-/*			from:	2 4 2 5 7 8 7 5 4 2/*			to:		1 2 1 3 4 5 4 3 2 1/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long *ul_convert_to_sequential(unsigned long *listgrps, int ntaxa, int ngrps){	unsigned long *array;	unsigned long *temp;	int i, j, k=1, l=0;		temp = ulvector(ngrps);	for (i=0 ; i<ngrps ; i++)		temp[i]=0;			array = ulvector(ntaxa);	for (i=0 ; i<ntaxa ; i++)		array[i]=0;		temp[0]=listgrps[0];	for (i=0 ; i<ntaxa ; i++) {		l=0;		for (j=0 ; j<k ; j++) {			if (listgrps[i] == temp[j]) {				array[i]=j;				l=1;				j=k+1;			}		}		if (l != 1) {			temp[k]=listgrps[i];			array[i]=k;			k++;			l=0;		}	}		free_ulvector(temp);	return array;}