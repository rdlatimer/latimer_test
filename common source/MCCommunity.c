/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//*/*	Peter J. Wagner: pwagner@fmnh.org/*	Matthew Kosnik: mkosnik@uchicago.edu/*/*	This file is copyright (C) 2001 Peter J. Wagner & Matthew Kosnik/*/*	This program is free software; you can redistribute it and/or modify it /*	under the terms of version 2 the GNU General Public License as published /*	by the Free Software Foundation./*/*	This program is distributed in the hope that it will be useful, but WITHOUT/*	ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or /*	FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for /*	more details./*/*	To view a copy of the license go to:/*	http://www.fsf.org/copyleft/gpl.html/*	To receive a copy of the GNU General Public License write the Free Software/* 	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA./*/*	Copies of this source code are available without cost from:/*	http://geosci.uchicago.edu/paleo/csource//*	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */#define MCCommunity#include "MCCommunity.h"#include "distribution_calc.h"/* Takes a slope and a minimum abundance, then generates and returns a geometric-series abundance distribution *//* E: slope in log-log space - from best fit distribution/* S: optimal richness - from best fit distribution/* N: number of specimens per list.***********************************************************************/int *sim_geo(double E, long double min, int N){int		a, b, c, S;unsigned long	*cumab;int	*abundance;double	x;double	*A;/*create geometric density function */A=proportional_geo_distribution(E,min);x=1+((log(min)-log(1-E))/log(E));S=x;if ((x-S)>=0.5)	++S;cumab=ulvector(S);abundance=ivector(S);A=ideal_distribution(A,S);/* create a cumulative distribution for sampling */cumab[0]=RAND_MAX*A[0];for (a=1; a<S; ++a)	{	cumab[a]=cumab[a-1]+(RAND_MAX*A[a]);	}for (a=0; a<S; ++a)	abundance[a]=0;for (a=0; a<N; ++a)	{	b = (int)((double)rand()/ ((double)RAND_MAX+1) * cumab[S-1]);	for (c=0 ; c<S ; c++) {		if (b<cumab[c]) {			++abundance[c];			c=S;			}		else if (c==S-1) {			++abundance[c];			printf("\nproblem in sim_geos (s=%d, c=%d, b=%d)\t",S,c,b);			}		}	}c=0;for (a=0; a<S; ++a)	if (abundance[a]==0)	++c;for (a=0; a<(S-c); ++a)	{	if (abundance[a]==0)	{		for (b=a; b<(S-1); ++b)			abundance[b]=abundance[b+1];		abundance[S-1]=0;		--a;		}	}free_dvector(A);free_ulvector(cumab);return abundance;}/* Takes a slope and a true richness, then generates and returns a geometric-series abundance distribution *//* E: slope in log-log space - from best fit distribution/* S: optimal richness - from best fit distribution/* N: number of specimens per list.***********************************************************************/int *sim_geos(double E, int S, int N){int		a, b, c;unsigned long	*cumab;int *abundance;double	*A;cumab=ulvector(S);abundance=ivector(S);/*create geometric density function */A=proportional_geos_distribution(E,S);A=ideal_distribution(A,S);/* create a cumulative distribution for sampling */cumab[0]=RAND_MAX*A[0];for (a=1; a<S; ++a)	{	cumab[a]=cumab[a-1]+(RAND_MAX*A[a]);	}for (a=0; a<S; ++a)	abundance[a]=0;for (a=0; a<N; ++a)	{	b = (int)((double)rand()/ ((double)RAND_MAX+1) * cumab[S-1]);	for (c=0 ; c<S ; c++) {		if (b<cumab[c]) {			++abundance[c];			c=S;			}		else if (c==S-1) {			++abundance[c];			printf("\nproblem in sim_geos (s=%d, c=%d, b=%d)\t",S,c,b);			}		}	}c=0;for (a=0; a<S; ++a)	if (abundance[a]==0)	++c;for (a=0; a<(S-c); ++a)	{	if (abundance[a]==0)	{		for (b=a; b<(S-1); ++b)			abundance[b]=abundance[b+1];		abundance[S-1]=0;		--a;		}	}free_dvector(A);free_ulvector(cumab);return abundance;}/* Takes a slope and a true richness, then generates and returns a geometric-series abundance distribution *//* E: slope in log-log space - from best fit distribution/* S: optimal richness - from best fit distribution/* N: number of specimens per list.***********************************************************************/int *sim_zsm(double TH, double M, int S, int N){int		a, b, c, sS;unsigned long	*cumab;int *abundance;double	*A;/*create zero sum density function */A=proportional_zsm_distribution(TH,M,5*N);sS=0;while (A[sS]>0)	++sS;A=ideal_distribution(A,sS);cumab=ulvector(sS);abundance=ivector(sS+1);/* create a cumulative distribution for sampling */cumab[0]=RAND_MAX*A[0];for (a=1; a<sS; ++a)	{	cumab[a]=cumab[a-1]+(RAND_MAX*A[a]);	}for (a=0; a<sS; ++a)	abundance[a]=0;for (a=0; a<N; ++a)	{	b = (int)((double)rand()/ ((double)RAND_MAX+1) * cumab[sS-1]);	for (c=0 ; c<sS ; c++) {		if (b<cumab[c]) {			++abundance[c];			c=sS;			}		else if (c==sS-1) {			++abundance[c];			printf("\nproblem in sim_zsm (s=%d, c=%d, b=%d)\t",sS,c,b);			}		}	}c=0;for (a=0; a<sS; ++a)	if (abundance[a]==0)	++c;for (a=0; a<(sS-c); ++a)	{	if (abundance[a]==0)	{		for (b=a; b<(sS-1); ++b)			abundance[b]=abundance[b+1];		abundance[sS-1]=0;		--a;		}	}free_dvector(A);free_ulvector(cumab);abundance=ishellsort_dec(abundance,sS+1);return abundance;}/* Takes a slope and a true richness, then generates and returns a Zipf abundance distribution *//* E: slope in log-log space - from best fit distribution/* S: optimal richness - from best fit distribution/* N: number of specimens per list.***********************************************************************/int *sim_zpf(double E, int S, int N){int		a, b, c;unsigned long	*cumab;int *abundance;double	T;double	*A;cumab=ulvector(S);abundance=ivector(S+1);T=100;/*create Zipf-Mandelbrot density function */	A=proportional_zipf_distribution(E,S);A=ideal_distribution(A,S);c=RAND_MAX;/* create a cumulative distribution for sampling */cumab[0]=RAND_MAX*A[0];for (a=1; a<S; ++a)	{	cumab[a]=cumab[a-1]+(RAND_MAX*A[a]);	}for (a=0; a<S; ++a)	abundance[a]=0;for (a=0; a<N; ++a)	{	b = (int)(((double)rand() / ((double)RAND_MAX+1)) * cumab[S-1]);	for (c=0 ; c<S ; c++) {		if (b<cumab[c]) {			++abundance[c];			c=S;			}		else if (c==S-1) {			++abundance[c];			printf("\nproblem in sim_zm (s=%d, c=%d, b=%d)\t",S,c,b);			}		}	}c=0;for (a=0; a<S; ++a)	if (abundance[a]==0)	++c;for (a=0; a<(S-c); ++a)	{	if (abundance[a]==0)	{		for (b=a; b<(S-1); ++b)			abundance[b]=abundance[b+1];		abundance[S-1]=0;		--a;		}	}free_dvector(A);free_ulvector(cumab);return abundance;}/* Takes a slope and a true richness, then generates and returns a Zipf-Mandelbrot abundance distribution *//* E: slope in log-log space - from best fit distribution/* S: optimal richness - from best fit distribution/* nspec: number of specimens per list./* Oc: number of occurrences per list.***********************************************************************/int *sim_zfm(double E, double B, int S, int nspec){int		a, b, c;int *abundance;double	x, T;double	*relab, *cumab;cumab=dvector(S);abundance=ivector(S);T=100;/*create Zipf-Mandelbrot density function */	relab=proportional_zm_distribution(E,B,S);/*relab=ideal_distribution(relab,S);	*/c=RAND_MAX;/* create a cumulative distribution for sampling */cumab[0]=relab[0];for (a=1; a<S; ++a)	{	cumab[a]=cumab[a-1]+relab[a];	}for (a=0; a<S; ++a)	abundance[a]=0;for (a=0; a<nspec; ++a)	{	x = ((double)rand()) / ((double) RAND_MAX+1);	b=0;	while (x>cumab[b] && b<S-1)	++b;		++abundance[b];/*	for (c=0 ; c<S; c++) {		if (x>cumab[c] && x<cumab[c]) {			++abundance[c];			c=S;			}		else if (c==S-1) {			++abundance[c];/*			printf("\nproblem in sim_zm (s=%d, c=%d, b=%d)\t",S,c,b);				}		}	*/	}c=0;for (a=0; a<S; ++a)	if (abundance[a]==0)	++c;for (a=0; a<(S-c); ++a)	{	if (abundance[a]==0)	{		for (b=a; b<(S-1); ++b)			abundance[b]=abundance[b+1];		abundance[S-1]=0;		--a;		}	}free_dvector(relab);free_dvector(cumab);return abundance;}/* Takes a slope and a true richness, then generates and returnsa Log-Normal abundance distribution *//* Mag: Magnitude of increase along each Octave/* Med: Octave with median species number/* N: number of specimens per list./* Oc: number of occurrences per list.***********************************************************************/int *sim_lgn(double Mag, double Trunc, int S, int N){int		a, b, c, d=0;unsigned long	*cumab;int		*abundance;double	T;double	*A;A=dvector(S);cumab=ulvector(S);abundance=ivector(S);T=A[0]=100;if (Trunc!=0)	d=1;/*create Log-Normal density function */	//A=proportional_fln_distribution(Trunc,Mag,S);A=proportional_lgn_distribution (Mag, S);A=ideal_distribution(A,S);/* create a cumulative distribution for sampling */cumab[0]=RAND_MAX*A[0];for (a=1; a<S; ++a)	{	cumab[a]=cumab[a-1]+(RAND_MAX*A[a]);	}for (a=0; a<S; ++a)	abundance[a]=0;for (a=0; a<N; ++a)	{	b = (int)((double)rand() / ((double)RAND_MAX+1) * cumab[S-1]);	for (c=0 ; c<S ; c++) {		if (b<cumab[c]) {			++abundance[c];			c=S;			}		else if (c==S-1) {			++abundance[c];			printf("\nproblem in sim_ln (s=%d, c=%d, b=%d)\t",S,c,b);			}		}	}c=0;for (a=0; a<S; ++a)	if (abundance[a]==0)	++c;for (a=0; a<(S-c); ++a)	{	if (abundance[a]==0)	{		for (b=a; b<(S-1); ++b)			abundance[b]=abundance[b+1];		abundance[S-1]=0;		--a;		}	}free_dvector(A);free_ulvector(cumab);return abundance;}/* Generates and returns a Log-Power abundance distribution *//* C: Coefficient of Power Function/* X: Exponent of Power Function/* S: number of taxa per list./* N: number of finds per list.***********************************************************************/int *sim_lp(double C, double X, int S, int N){int		a, b, c;unsigned long	*cumab;int		*abundance;double	*A;cumab=ulvector(S);abundance=ivector(S);/*create Log-Normal density function */	A=proportional_lp_distribution(C,X,S);A=ideal_distribution(A,S);/* create a cumulative distribution for sampling */cumab[0]=RAND_MAX*A[0];for (a=1; a<S; ++a)	{	cumab[a]=cumab[a-1]+(RAND_MAX*A[a]);	}for (a=0; a<S; ++a)	abundance[a]=0;for (a=0; a<N; ++a)	{	b = (int)((double)rand() / ((double)RAND_MAX+1) * cumab[S-1]);	for (c=0 ; c<S ; c++) {		if (b<cumab[c]) {			++abundance[c];			c=S;			}		else if (c==S-1) {			++abundance[c];			printf("\nproblem in sim_lp (s=%d, c=%d, b=%d)\t",S,c,b);			}		}	}c=0;for (a=0; a<S; ++a)	if (abundance[a]==0)	++c;for (a=0; a<(S-c); ++a)	{	if (abundance[a]==0)	{		for (b=a; b<(S-1); ++b)			abundance[b]=abundance[b+1];		abundance[S-1]=0;		--a;		}	}free_dvector(A);free_ulvector(cumab);return abundance;}/* Takes a slope and a true richness, then generates and returnsa geometric-series abundance distribution *//* rad: relative abundances of each species, given as a real number/* S: optimal richness - from best fit distribution/* N: number of specimens per list.***********************************************************************/int *sim_community(double *rad, int S, int N){int		a, b, c;double	*cumab;int	*abundance;cumab=dvector(S);abundance=ivector(S);/* create a cumulative distribution for sampling */cumab[0]=RAND_MAX*rad[0];for (a=1; a<S; ++a)	{	cumab[a]=cumab[a-1]+(RAND_MAX*rad[a]);	}for (a=0; a<S; ++a)	abundance[a]=0;for (a=0; a<N; ++a)	{	b = (int)((double)rand()/ ((double)RAND_MAX+1) * cumab[S-1]);	for (c=0 ; c<S ; c++) {		if (b<cumab[c]) {			++abundance[c];			c=S;			}		else if (c==S-1) {			++abundance[c];			printf("\nproblem in sim_community (s=%d, c=%d, b=%d)\t",S,c,b);			}		}	}c=0;for (a=0; a<S; ++a)	if (abundance[a]==0)	++c;for (a=0; a<(S-c); ++a)	{	if (abundance[a]==0)	{		for (b=a; b<(S-1); ++b)			abundance[b]=abundance[b+1];		abundance[S-1]=0;		--a;		}	}free_dvector(cumab);return abundance;}