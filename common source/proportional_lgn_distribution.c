/*CALCULATES LOG-NORMAL DISTRIBUTION - this is a real lognormal distribution! 	This based onNEEDS:    - mag (magnitude of increase between octaves)    - mode (position of the mode)    - S (number of taxa)RETURNS:	- A: proportional abundances***********************************************************************/double *proportional_lgn_distributionN (double mag, double mode, double ocs, int S){int		a=0, b, c, d=0, s=0;/*unsigned long	n, pn;*/double long	n, pn, spec;long			in;double	ra, la, rer, ler;double	oct, moct, x, rnd=0.0f, ttl=0.0f, lttl=-1.0f, kttl;/*double	d1, d2, h;*/double	lp=0.0000000f, lnc=0.0000000f, y=0.0000000f;double	fn, ar=0.0f;double	*A;/* make sure that mxsp>=mxfds *//* if S<100, then there are 5 octaves that should have speciesif (S<75)			ocs=2.5;else if (S<350)		ocs=3.0;else if (S<2000)	ocs=3.5;else if (S<15000)	ocs=4.0;else 				ocs=4.5; */if (mode<0)			moct=mode+ocs;else				moct=ocs;/* if the distribution is truncated, then we need to adjust the area under the curve	*//* dividing each fn below by this increases it to the proportion of the possible area	*//*	for (x=0; x<=moct+3.5; x+=0.125)	{	 y=normheight(x,moct,1);	 ar+=y/8;	 }	*//* find the area on the left side of the bell curve *//* if moct==0, then the left half is completely truncated */if (mode==-1*ocs || ocs<-1*mode)	la=0.0f;/* if the distribution is truncated, then there will be less of this than otherwise 		*//* even if not, then because we begin 3.5 SD's away, we want to eliminate that small amount */else if (mode<0)	{	la=normheight(0,moct,1);	ler=erf(moct);	la*=ler;	}/* if moct>=0, then the left (rare) half is completely untruncated */else if (mode>=0)	{	la=normheight(0,ocs,1);	ler=erf(ocs);	la*=ler;	}/* if mode == 0s, then the right side is completely truncated */if (mode==ocs || mode>ocs)	ra=0.0f;/* if the right (common) half is truncated, then we go fewer octaves to the right *//* this will create a relatively large number of abundant species  */else if (mode>=0)	{	ra=normheight(0,ocs-mode,1);	rer=erf(ocs-mode);	ra*=rer;	}/* if we truncate the left (rare) half, then the right (common) half is completely untruncated */else if (mode<0)	{	ra=normheight(0,ocs,1);	rer=erf(ocs);	ra*=rer;	}ar=ra+la;y=0.0000000f;A=dvector(S);in=1;/* find the probability of species beginning with n specimens*/for (n=1; s<S; n=n+in)	{	/* calculate how far along the x-axis we are given that the axis really is in a log-scale */	oct=log(n)/log(mag);	x=0.5+n;	/* find the area within the histogram centred on n - that is the expected frequency of species with n specimens *//*	h=normheight(oct,moct,1);	d1=log(x)/log(mag);	d2=log(x-1)/log(mag);	fn=h*(d1-d2);	fn=((double) S)*fn;*/	if (s>0 && s%50==0)	{		fn=(1/ar);		}	if (in==1)	{/*		fn=(1/ar)*((double) S)*normheight(oct,moct,1)*((log(x)/log(mag))-(log(x-1)/log(mag)));	*/		/* estimate the total number of expected individuals */		/* then see if we expect the next species to fall on this point */		if (n==1)	la=0;		else		la=log(x-1)/log(mag);		ra=log(x)/log(mag);		fn=(1/ar) * ((double) S) * normareabetween(la,ra,moct,1);		ttl+=fn;		a=ttl;		b=lttl;/*		if (((ttl-a)>=0.5 && (lttl-b)<0.5) || (a-b)>1)	{	*/		if (ttl>=(((double) d)+0.5) && lttl<(((double) d)+0.5))	{			if ((ttl-a)>=0.5)	++a;			if (b<0)			b=0;			for (c=d; c<a; ++c)	pn=A[c]=n;			s=d=a;		/* this shouldn't be necessary, but it is..... */			if (a==1 && A[0]>=10)				in=A[0]/2;			else if (a>1 && (A[a-1]-A[a-2]>=10))in=(A[a-1]-A[a-2])/2;			else								in=1;			}		}			else	{		y=(n-in)+0.5;		x=n+0.5;		la=log(y)/log(mag);		ra=log(x)/log(mag);/*		fn=normareabetween(la,ra,moct,1);		fn*=(1/ar);		fn*=((double) S);	*/		fn=(1/ar) * ((double) S) * normareabetween(la,ra,moct,1);		ttl+=fn;/*		d=1+lttl;	*/		a=ttl;		b=lttl;		/* now if we overshot X.5, we need to back up to the n at which it happened *//*		if (((ttl-a)>=0.5 && (lttl-b)<0.5) || (ttl-lttl >= ((((double) d)+0.5)-lttl)))	{	*/		if (ttl>=(((double) d)+0.5) && lttl<(((double) d)+0.5))	{			c=kttl=ttl;					/* kttl will be used to keep track of prior ttls	*/			ttl-=fn;					/* reset ttl			*/			in/=-2;						/* we need to go backwards in smaller steps */			while (n+in<pn)	in/=2;/*			if (n-1==A[a-1])	in=0;	*/			if (n-1==pn)	in=0;						while (abs(in)>0)	{				while ((n+in)<pn)	in/=2;				if (in==0)	in=1;				n+=in;				x=0.5+n;/*				la=log(y)/log(mag);	*/				ra=log(x)/log(mag);/*				fn=normareabetween(la,ra,moct,1);				fn*=(1/ar);				fn*=((double) S);	*/				fn=(1/ar) * ((double) S) * normareabetween(la,ra,moct,1);				ttl+=fn;				a=ttl;								/* whenever the current and previous area are on either side of X.5, reverse a half-step */				if ((ttl-a)<0.5 && (kttl-a)>0.5 || (ttl-a)>0.5 && (kttl-a)<0.5)	{						in/=-2;						/* we need to go backwards in smaller steps */					if (n==(pn+1) && (ttl-a)>=0.5)	in=0;					/* once this reaches 0, we are there */					if (in==0)	{						/* if ttl is below X.5, then it is n+1 that we want */						if ((ttl-a)<0.5)	{							++n;							ttl=kttl;							}						pn=A[a]=n;						s=d=a+1;						}					}				c=kttl=ttl;				if (in!=0)	ttl-=fn;				/* do not let n become lower than the n prior to X.5 being passed */				}						if (a==1 && A[0]>=10)				in=A[0]/2;			else if (a>1 && (A[a-1]-A[a-2]>=10))in=(A[a]-A[a-1])/2;			else								in=1;			}		}	pn=n;	lttl=ttl;	}	spec=sumdvector(A,S);for (s=0; s<S; ++s)	A[s]/=spec;A = dshellsort_dec(A,S);return A;}