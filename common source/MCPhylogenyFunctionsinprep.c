void deriveeachchar(long **matrix, int **taxachange, int *maxch, int *steps, int *aptaxa, int notu, int nchars, int deltas, int maxstp, int mxdel, int UNKNOWN, int INAP, long **tree, int nodes){int	a, u;int	br, ev, ch, st, sp, best, clse;for (ch=0; (ch<nchars && deltas<maxstp); ++ch)	{	while (maxch[ch]==0 && ch<nchars)	++ch;	if (ch>=nchars)			break;	steps[ch]=st=0;	clearivector(taxachange[ch],mxdel,-1);	ev=0;			/* make sure that inapplicable characters have at least one taxon that can be changed */	if (aptaxa[ch]<notu)	{		/* count unknowns - these will be put back in later */		u=0;		for (a=0; a<notu; ++a)	if (matrix[a][ch]==UNKNOWN)	++u;		/* now find a node that has similar diversity */		clse=RAND_MAX;				/* start from the bottom if most taxa are scored */		if (aptaxa[ch]>(notu/2))	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==(notu-aptaxa[ch]))	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs((notu-aptaxa[ch])-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}		/* start from the top otherwise */		else	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==aptaxa[ch])	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs(aptaxa[ch]-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}				for (sp=0; sp<notu; ++sp)	{			if (aptaxa[ch]>(notu/2))	matrix[sp][ch]=0;			else						matrix[sp][ch]=INAP;			}		for (a=1; a<tree[best][0]; ++a)	{			sp=tree[best][a];			matrix[sp][a]=0;			}		}	/* end initial creation of inapplicable character */		/* make autapomorphic characters change on one species only */	/* invariants do not change at all */	for (ch=ch; maxch[ch]<=1; ++ch)	{		/* skip invariants and make autapomorphies autapomorphic */		if	(maxch[ch]==1)	{			c=0;			/* we will sample only from otus here - so do not include clades in branches array! */			/* this part rewritten with Cubs winning 7-0 against the Marlins in Game 4 */			for (sp=0; sp<notu; ++sp)				if ((matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP) && trpd[sp]>0)	++c;			if (c>0)	{				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || (trpd[sp]==0 || sp>=notu))					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=1;				taxachange[ch][0]=sp;				}			/* if only cells belong to species with 0 length branches */			if (c==0)	{				/* flip-flop an unknown apomorphic species with a known plesiomorphic one - give plesiomorphic species a ? and the other a 1 */				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || sp2>=notu)					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);								sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while (trpd[sp2]==0 || sp2>=notu)					sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp2][ch];				invmatrix[ch][sp2]=matrix[sp2][ch]=1;				taxachange[ch][0]=sp2;/*				clearivector(branches,ttlbr,0);				sp=branches[0];				while (trpd[sp]==0)	{					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);					}				f=(int)((double)rand() / ((double)RAND_MAX + 1) * a);				d=branches[f];				invmatrix[ch][d]=matrix[d][ch]==INAP;				invmatrix[ch][sp]=matrix[sp][ch]=1;				taxachange[ch][0]=sp;	*/				}	/* end routine if all scored species were unknown *//*			else	{				sp=branches[f];				while (trpd[sp]==0 || (matrix[sp][ch]==UNKNOWN || matrix[sp][ch]==INAP))	{					f=(int)((double)rand() / ((double)RAND_MAX + 1) * a);					sp=branches[f];					}				invmatrix[ch][a]=matrix[sp][ch]=1;				taxachange[ch][0]=sp;				}*/			ev=1;			++deltas;			++steps[ch];			++apo[ch];			}		}	/* this should leave us with a character that needs to be changed OR out of characters */	if (ch>=nchars)	break;			used=0;	/* this tells how many branches are discarded; used > steps IF there are absents */	/* branch length is taken into account by trpd */	equalivector(branches,available,ttlbr);	/* Binary && unordered multistate is Easy */	/* for normal character, have it change until all X states are realized */	if (nstates[ch]==2 || ctype[ch]==1)	{		for (st=0; st<nstates[ch]-1; st=st)	{			/* There are ttlbr-used branches that could change */			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			sp = branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				ev=1;				invmatrix[ch][sp]=matrix[sp][ch]=st+1;				}			else if (sp>notu)	{				/* use st+1 instead of nstates[ch] here - we want only 0Ést+1 not 0Énstates */				/*		(remember, st has not yet been incremented, so we need st+1 		*/				if (st>0)	{					for (b=1; b<=tree[sp-notu][1]; ++b)	{						sp2=tree[sp-notu][b];						if (matrix[sp2][ch]==0)	matrix[sp2][ch]=st+1;						}					}				else		evolvebinaryinclade(tree[sp-notu],matrix,ch);				for (c=0; c<notu; ++c)	{					if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;					invmatrix[ch][c]=matrix[c][ch];					}				/* if there was a change, then tally it */				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1))				removefromivector(branches,sp,a);							if (used<steps[ch])	{				printf("ERROR LINE 954 - there are more changes than deleted branches for Ch%dÉ\n",ch+1);				}			/* if ev=1 then the state has been derived */			if (ev==1)	{				++apo[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				++st;	/* we increment this only if we have made a change */				}			}	/*end derivation of state */		}	/* end loop for binary / unordered characters */		/* Ordered Multistates are tougher */	else if (nstates[ch]>2 && ctype[ch]==0)	{		used=0;		for (st=0; (st<nstates[ch]-1 && (steps[ch]<mxdel && steps[ch]<maxch[ch])); st=st)	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			sp=branches[br];			/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				matrix[sp][ch]=multi(matrix[sp][ch],nstates[ch],bias[ch]);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				ev=1;				}							else if (sp>notu)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])	flip=1;				else				flip=-1;				evolveorderedinclade(tree[sp-notu],matrix,ch,flip, INAP, UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				}							for (c=0; c<notu; ++c)	{				if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;				invmatrix[ch][c]=matrix[c][ch];				}			/* if ev=1 then the state has been derived */			if (ev==1)	{				++apo[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				/* note - do not increment st here - that is done only if a new state is derived */				}			/* check if all states have been derived */			/* note: this is needed only for ordered multistates */			if (steps[ch]>=nstates[ch]-1)	{				for(a=0; a<notu; ++a)	{					if (matrix[a][ch]>st && (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN))						st=matrix[a][ch];					}				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1))				removefromivector(branches,sp,a);			if (used<steps[ch])				printf("ERROR LINE 2145 - there are more changes than deleted branches for Ch%dÉ\n",ch+1);						/* emergency reboot procedure! - clear everything and start over again */			if (used==ttlbr)	{				for (a=0; a<steps[ch]; ++a)	{					sp=taxachange[ch][a];					--apo[sp];					taxachange[ch][a]=0;					}				deltas=deltas-steps[ch];				st=steps[ch]=used=0;				for (sp=0; sp<notu; ++sp)					if (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN)						invmatrix[ch][sp]=matrix[sp][ch]=0;				for (sp=0; sp<ttlbr; ++sp)	branches[sp]=available[sp];				}			}		/* if there are many states and few taxa, then you do not want to mess with this anymore.  Any changes will either eliminate extreme states,		or simply shift the state up or down one (resulting in no observable change once standardized.  So, if steps >= half the taxa, then shut it down */				if (steps[ch]>(notu/2))	steps[ch]=maxch[ch];				}	/* end loop for ordered multistates */	}	/* end derivation of all character states */}