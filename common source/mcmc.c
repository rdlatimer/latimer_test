#define mcmc#include "matrixchange.h"#include "mcmc.h"#include "memory.h"#include "minmax.h"#include "probability.h"#include "sort.h"#include "stratocladistics.h"#include "tree_likelihood.h"//int GibbsSample (int argc, char *argv)double **GibbsSample (int n, double rho){long i;double x,y,sd;double **Gibbs;Gibbs=dmatrix(2,n);//gsl_rng *r = gsl_rng_alloc(gsl_rng_mt19937);//n=(long) atoi(argv[1]);//rho=(double) atof(argv[2]);sd=sqrt(1-rho*rho);x=0;y=0;//printf(" %3.3f %3.3f \n",x,y);for (i=1;i<n;i++)	{	Gibbs[0][i]=x=randomnormalZ(rho*y,sd);	Gibbs[1][i]=y=randomnormalZ(rho*x,sd);//	printf(" %3.3f %3.3f \n",x,y);	}return Gibbs;}/* swapbr: routine to swap branches in tree	ape: tree giving ancestral htu of each otu & htu	ttblr: total branches in the tree	notu: number of observed taxa (tips) in tree.****************************************************/void swapbr(long *ape, int ttlbr, int notu){int	a, b, c, d, f, i;a=notu;while (a==notu)	a=(((unsigned int) rand())%ttlbr);if (ape[a]==notu)	{	//		c=ape[a];	d=f=-1;	/* flip notu into node above basal node; pull one descendant of that node to base	*/	for (i=0; i<ttlbr && d==-1; ++i)	{		if (ape[i]==notu && i!=a)	d=i;	/* move node into sister node	*/		}	/* attach one branch to the base	*/	if (d>notu)	{		ape[a]=d;		for (i=0; i<ttlbr && f==-1; ++i)	{			if (ape[i]==d && i!=a)	ape[f=i]=notu;			}	/* attach one branch formerly attached to base to node a-notu	*/		}	/* end case where we flip things into different nodes at the base	*/	else	{		/* find a branch within a and flip that with the outgroup	*/		ape[d]=a;	/* flip outgroup notu->node a	*/		for (i=0; i<ttlbr && f==-1; ++i)	{			if (ape[i]==a && i!=d)	ape[f=i]=notu;	/* flip former daughter taxon -> basal node	*/			}	/* attach one branch formerly attached to base to node a-notu	*/		}	/* end case where the outgroup is a notu	*/	}	/* end case where we flip things around the base of the ape	*/else if (ape[a]!=notu)	{	/* swap ancestors between a & b	*/	c=ape[b=ape[a]];	/* target node	*/	d=imax(b, ttlbr-b);	f=-1;	/* look "up" and "down" until you find the cousin node	*/	for (i=1; (i<=d && f==-1); ++i)	{		if ((b-i)>=0)			if (ape[b-i]==c)	f=b-i;		if ((b+i)<ttlbr && f==-1)			if (ape[b+i]==c)	f=b+i;		}	/* end search for "cousin" to switch	*/	b=ape[a];	ape[a]=ape[f];	ape[f]=b;	}	/* end switch of ancestral nodes	*/}/* swapbrX: routine to swap branch X in tree	ape: tree giving ancestral htu of each otu & htu	ttblr: total branches in the tree	notu: number of observed taxa (tips) in tree.NOTE: use this if you want to do something else with this branch****************************************************************/void swapbrX(long *ape, int ttlbr, int notu, int br){int	b, c, d, f, i;if (ape[br]==notu)	{	//		c=ape[br];	d=f=-1;	/* flip notu into node above basal node; pull one descendant of that node to base	*/	for (i=0; i<ttlbr && d==-1; ++i)	{		if (ape[i]==notu && i!=br)	d=i;	/* move node into sister node	*/		}	/* attach one branch to the base	*/	if (d>notu)	{		ape[br]=d;		for (i=0; i<ttlbr && f==-1; ++i)	{			if (ape[i]==d && i!=br)	ape[f=i]=notu;			}	/* attach one branch formerly attached to base to node br-notu	*/		}	/* end case where we flip things into different nodes at the base	*/	else	{		/* find a branch within br and flip that with the outgroup	*/		ape[d]=br;	/* flip outgroup notu->node br	*/		for (i=0; i<ttlbr && f==-1; ++i)	{			if (ape[i]==br && i!=d)	ape[f=i]=notu;	/* flip former daughter taxon -> basal node	*/			}	/* attach one branch formerly attached to base to node br-notu	*/		}	/* end case where the outgroup is br notu	*/	}	/* end case where we flip things around the base of the ape	*/else if (ape[br]!=notu)	{	/* swap ancestors between br & b	*/	c=ape[b=ape[br]];	/* target node	*/	d=imax(b, ttlbr-b);	f=-1;	/* look "up" and "down" until you find the cousin node	*/	for (i=1; (i<=d && f==-1); ++i)	{		if ((b-i)>=0)			if (ape[b-i]==c)	f=b-i;		if ((b+i)<ttlbr && f==-1)			if (ape[b+i]==c)	f=b+i;		}	/* end search for "cousin" to switch	*/	b=ape[br];	ape[br]=ape[f];	ape[f]=b;	}	/* end switch of ancestral nodes	*/}void swapbr2(long *tree, int ttlbr, int notu){int	a, b, d;a=notu;while (a==notu)	b=a =(((unsigned int) rand())%ttlbr);while (b==a || (b==notu || tree[a]==tree[b]))	b=(((unsigned int) rand())%ttlbr);/* swap ancestors between a & b	*/d=tree[a];tree[a]=tree[b];tree[b]=d;}/* *************************************************************************************************/double exponentialbranchdurations (double lambda){double p, t;p=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);t=-1*log(1-p)/lambda;return t;}/*	swap_and_recalculate: swap two branches, then recalculate tree likelihood using pulley principleRequires: ape: tree vector giving ancestral node of each species	notu: # observed taxa;	nodes: # clades (= [2*notu] - 1 without polytomies	statechars: matrix giving characters with X states	charswstates: # characters with X states	maxst: maximum number of states	alphas: anagenetic rate of change	betas: punctuated rate of change	rates: number of rates	statelikes: cube giving conditional likelihood of each state for each character at each node	lambda: speciation rate	ranges: first and last appearances	divergences: upper and lower bounds of divergences (upper bound = FA for observed taxa)	ancestral: number of descendants for each node/species	minbr: minimum branching events leading to each TU.  This is zero only for potential anagenetic descendants/* altered 2014-09-22 to take into account adjusting ancestors & anangenesis; also, polytomies	 *************************************************************************************************/void swap_and_recalculate(long *ape, int notu, int nodes, long **statechars, long *charswstates, int maxst, double *alphas, double *betas, int rates, double ***statelikes, double lambda, double **ranges, double **divergences, unsigned long *ancestral, unsigned long *minbr){int	b, c, d, f, i, br, ttlbr;int	nd1, nd2, HTU;	/* two nodes with different descendants & node on which to start recalculating	*/int desc[100], f1, foote;double x=0.0f;ttlbr=notu+nodes;br=notu;while (br==notu)	br=(((unsigned int) rand())%ttlbr);	/* choose a branch to slide down the tree	*/if (br>notu && ancestral[br]>2)	x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);if (x<0.5)	{	/* ID branches that must be altered: basically, that is all nodes with new members, and everything below them	*/	if (ape[br]==notu)	{		d=f=-1;		if (br<notu)	{			ancestral[br]=0;			minbr[br]=1;			}	/* if part of an AD statement is removed, then alter that	*/		/* flip notu into node above basal node; pull one descendant of that node to base	*/		for (i=0; i<ttlbr && d==-1; ++i)	{			if (ape[i]==notu && i!=br)	d=i;	/* move node into sister node	*/			}	/* attach one branch to the base	*/		if (d>notu)	{			nd1=ape[br]=d;			for (i=0; i<ttlbr && f==-1; ++i)	{				if (ape[i]==d && i!=br)	nd2=ape[f=i]=notu;				}	/* attach one branch formerly attached to base to node br-notu	*/			}	/* end case where we flip things into different nodes at the base	*/		else	{			/* find a branch within br and flip that with the outgroup	*/			nd1=ape[d]=br;	/* flip outgroup notu->node br	*/			for (i=0; i<ttlbr && f==-1; ++i)	{				if (ape[i]==br && i!=d)	nd2=ape[f=i]=notu;	/* flip former daughter taxon -> basal node	*/				}	/* attach one branch formerly attached to base to node br-notu	*/			}	/* end case where the outgroup is br notu	*/		if (f<notu)	{			ancestral[f]=0;			minbr[f]=1;			}	/* if part of an AD statement is removed, then alter that	*/		}	/* end case where we flip things around the base of the ape	*/	else if (ape[br]!=notu)	{		/* swap ancestors between br & b	*/		c=ape[b=ape[br]];	/* target node	*/		d=imax(b, ttlbr-b);		f=-1;		/* look "up" and "down" until you find the cousin node	*/		for (i=1; (i<=d && f==-1); ++i)	{			if ((b-i)>=0)				if (ape[b-i]==c)	f=b-i;			if ((b+i)<ttlbr && f==-1)				if (ape[b+i]==c)	f=b+i;			}	/* end search for "cousin" to switch	*/		b=ape[br];		nd1=ape[br]=ape[f];		nd2=ape[f]=b;		if (br<notu)	{			ancestral[br]=0;			minbr[br]=1;			}	/* if part of an AD statement is removed, then alter that	*/		if (f<notu)	{			ancestral[f]=0;			minbr[f]=1;			}	/* if part of an AD statement is removed, then alter that	*/		}	/* end switch of ancestral nodes; RESET minbr & ancestral if species!!!	*/	if (nd1==notu)				HTU=nd2;	else if (nd2==notu)			HTU=nd1;	else if (ape[nd1]==nd2)		HTU=nd1;	else if (ape[nd2]==nd1)		HTU=nd2;	}/* routine to break up a polytomy into an additoinal node	*/if (x>0.5)	{	f1=0;	foote=-1;	HTU=notu+nodes;	for (d=0; d<HTU; ++d)	{		if (ape[d]==br)	{			desc[f1]=d;			if (ancestral[d]>0)	foote=d;			++f1;			}		}	b=foote;	scrambleiarraycommand(desc,f1);	d=i=0;	while (i<2)	{		if (desc[d]!=foote)	{			ape[desc[d]]=notu+nodes;			++d;			}		++i;		}	/* add taxa other than ancestor to new node within old one	*/	ancestral[HTU]=2;	ape[HTU]=br;	--ancestral[br];	if (foote!=-1)	--ancestral[foote];	++nodes;	}//else if (ape[nd1]==ape[nd2])	c=100;  else	c=100;/* now use our old friend recursion!	*/datecladerealape_pulley(HTU, ape, divergences, nodes, notu, ancestral);MkSimplePulley(HTU, ape, notu, nodes, divergences, statechars, charswstates, maxst, alphas, betas, rates, statelikes, lambda, ancestral, minbr);//MkSimplePulley(HTU, ape, notu, nodes, divergences, statechars, charswstates, maxst, alphas, betas, rates, statelikes, lambda, ancestral, minbr);}/* change branch lengths	After doing so, use the pulley principle to redo divergences below that node.  Then use pulley principle to redo likelihoods below that node./*******************************************************************************************************/void change_branch_length(long *ape, int notu, int nodes, long **statechars, long *charswstates, int nchars, int maxst, double *alphas, double *betas, int rates, double ***statelikes, double lambda, double **ranges, double **divergences, unsigned long *ancestral, unsigned long *minbr){int	a, b, d, f1=0, fail=0;int br, ttlbr, HTU, outg, foote=-1;int desc[10];double  bl, x, y, t;double ble, blu, div[10], fa[10];ttlbr=notu+nodes;br=notu;while (br==notu)	br=(((unsigned int) rand())%ttlbr);	/* choose a branch to slide down the tree	*/HTU=ape[br];x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);y=-1*log(x)/log(2);	/* this will be the proportional change to the branch length in question	*/for (d=0; d<nodes+notu; ++d)	{    if (ape[d]==HTU)	{        desc[f1]=d;	/* make list of descendants	*/        if (ancestral[d]>0)	foote=d;		/* ancestor identified	*/        div[f1]=divergences[d][0];	/* is this pointless?	*/        fa[f1]=divergences[d][1];        if (divergences[d][1]<ble)	{            outg=d;                  /* track the oldest taxon in the node           */            ble=divergences[d][1];	/* oldest divergence time among descendants		*/			}        if (divergences[d][0]>blu)	blu=divergences[d][0];	/* youngest divergence time among descendants	*/        ++f1;		}	}if (outg<notu && y<1)   {    /* there are multiple possible scenarios here:     1. We make branches longer: if so, then it doesn't matter which species we use.  (Use shortest just to minimize extension).     2. We make branches shorter.     A. if it leads to oldest species, then just drag up divergence[HTU][1]     B. if it happens to a younger species, then:     i. it just drags up divergence[HTU][1];     ii. it drags divergence[d][0] above FA of oldest species, necessitating AD relatonship     a. requiring branching IF divergence[anc][1]<divergence[d][0]<ranges[anc][1];     b. allowing anagenesis IF ranges[anc][1]<divergence[d][0]     /* alter one of the later branches: this allows for AD hypotheses  */    /* if ancestor has not yet been sampled   */    if (foote==-1)	{        if (f1>2)	d=1+(((unsigned int) rand())%(f1-1));		/* choose one of the descendants	*/        else		d=1;        while (d>=f1)   --d;        bl=y*fabs(divergences[d][1]-divergences[d][0]);        divergences[d][0]=divergences[d][1]-bl;                if (divergences[d][0]>divergences[outg][1])	{            foote=outg;            ancestral[foote]=f1-1;											/* how many species derive from this species?	*/            equaldmatrix(statelikes[HTU],statelikes[outg],nchars,maxst);	/* prior to re-evaluating likelihood, make nodal states the ancestral ones	*/            if (divergences[d][0]>ranges[foote][1])	{                minbr[d]=0;													/* no branching is necessary	*/                divergences[d][0]=ranges[foote][1];							/* minimum divergence time is LA[anc] -> FA[desc]	*/                }	/*descendant appears after ancestor: make this a morphocline	*/            }	/* species must be ancestral!	*/        if (f1>2)	{            for (a=0; a<f1; ++a)	{                if (desc[a]!=foote && desc[a]!=d)	{                    b=desc[a];                    x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);                    bl=x*fabs(ranges[b][0]-divergences[foote][0]);                    divergences[b][0]=ranges[b][0]-bl;                    if (divergences[b][0]>ranges[foote][1])	{                        minbr[b]=0;                        divergences[b][0]=ranges[foote][1];                        }   /* end case of possible anagenesis  */                    }   /* end check to make sure this isn't the ancestor or Sp #1  */                }   /* end search of extra branches in polytomy */            }            /**** NOTE: if this is a polytomy, then go through and make sure that all descendants appear sometime between divergence[foote][0] and range[desc][0]	*/        }   /* if divegences[d][1] is after ranges[outg][1], then we can have anagenetic series  */    else	{        d=foote;        while (d==foote)	{            a=(((unsigned int) rand())%f1);			/* choose one of the descendants	*/            d=desc[a];            }        if (minbr[d]==1)	{            bl=y*fabs(divergences[d][1]-divergences[d][0]);            divergences[d][0]=divergences[d][1]-bl;            if (divergences[d][0]>ranges[foote][1])	{                minbr[d]=0;													/* no branching is necessary	*/                divergences[d][0]=ranges[foote][1];							/* minimum divergence time is LA[anc] -> FA[desc]	*/                }	/*descendant appears after ancestor: make this a morphocline	*/            }	/* if ancestor already sampled, then just check to see if the branch	*/        else if (minbr[foote]==1)	{            bl=y*fabs(divergences[foote][1]-divergences[d][0]);            divergences[d][0]=divergences[d][1]-bl;            if (divergences[d][0]>ranges[foote][1])	{                minbr[d]=0;													/* no branching is necessary	*/                divergences[d][0]=ranges[foote][1];							/* minimum divergence time is LA[anc] -> FA[desc]	*/                }	/*descendant appears after ancestor: make this a morphocline	*/            }	/* alter divergence of ancestral species	*/        else	fail=1;        }    }else	{	if (foote==-1)	{		dshellsort_inc_command(fa,f1);			/* first will be the oldest appearing taxon	*/		t=fa[0];		}	else	t=divergences[foote][0];	bl=y*fabs(t-divergences[HTU][1]);		/* take the shortest range extension & use that to alter the whole clade		*/	x=divergences[HTU][1];					/* old divergence time	*/	divergences[HTU][1]-=bl;				/* new divergence time	*/    for (d=0; d<f1; ++d)	{        if (divergences[d][0]==x)	divergences[d][0]=divergences[HTU][1];		}	/* note: if there are AD statements here, then we do not want to drag the divergence dates of D's up to the whole nodes	*/    /* find ancestral node; see if we can drag the branch up this far; if not, then drag sister-taxon's branch up that far  */	}   /* end case where we definitely won't be making an ancestor    */    if (fail==0)	{    datecladerealape_pulley(HTU, ape, divergences, nodes, notu, ancestral);    MkSimplePulley(HTU, ape, notu, nodes, divergences, statechars, charswstates, maxst, alphas, betas, rates, statelikes, lambda, ancestral, minbr);    }}   /* end changing of branch lengths   */void change_alpha(double *alphas, int rates){int	r;double  pi=1.5, x, y;    x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);y=-normsinv(x);	/* this will be the proportional change to the branch length in question	*/pi=pow(1.5,y);for (r=0; r<rates; ++r) alphas[r]*=pi;    }   /* end changing of branch lengths   *//* collapse nodes into polytomies. big trick: handling ancestors and possible anagenetic sequences After doing so, use the pulley principle to redo divergences below that node.  Then use pulley principle to redo likelihoods below that node./*******************************************************************************************************/void collapse_node_and_recalculate(long *ape, int notu, int *nodes, long **statechars, long *charswstates, int nchars, int maxst, double *alphas, double *betas, int rates, double ***statelikes, double lambda, double **ranges, double **divergences, unsigned long *ancestral, unsigned long *minbr){int	a, b, d, br, HTU, f1=0, f2=0, foote1=-1, foote2=-1;int desc[100], desc2[100];double x;int clades=*nodes;br=notu;while (br==notu)	br=notu+(((unsigned int) rand())%clades);	/* choose a node to collapse	*/br=10;HTU=ape[br];for (d=0; d<notu+clades; ++d)	{	if (ape[d]==br)	{		if (ancestral[d]>0 && d<notu)	foote1=d;	/* node had sampled ancestor	*/		desc[f1]=d;		++f1;		ape[d]=ape[br];	/* drop into lower node	*/		}	else if (ape[d]==ape[br])	{		if (ancestral[d]>0 && d<notu)	foote2=d;	/* node had sampled ancestor	*/		desc2[f2]=d;		++f2;		}	}	/* see if either (or both) nodes have an ancestral species attached	*/if (foote2!=-1 || foote1!=-1)	{	if (ranges[foote2][0]<ranges[foote1][0] || foote1==-1)		a=0;	else if (ranges[foote2][0]>ranges[foote1][0] || foote2==-1)	a=1;	else	{		x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		if (x<0.5)	a=0;		else		a=1;		}	/* if both have ancestors and both appear at the same time	*/	if (a==0)	{		ancestral[foote1]=0;		ancestral[foote2]+=(f1-1);		for (d=0; d<f1; ++d)	minbr[desc[d]]=1;		}	/* keep foote2 the ancestor	*/	else 	{		ancestral[foote2]=0;		ancestral[foote2=foote1]+=(f1-1);		for (d=0; d<f1; ++d)	minbr[desc2[d]]=1;		}	/* keep foote1 the ancestor	*/	}removefromivector(desc2,br,&f2);for (a=0; a<f1; ++a)	{	desc2[a+f2]=d=desc[a];	ape[d]=HTU;//	++f2;	}ancestral[HTU]+=(f1-1);				/* reset size of clade	*//* rewrite tree to remove this node							*/for (b=br; b<(notu+clades)-1; ++b)	{	ape[b]=ape[b+1];	minbr[b]=minbr[b+1];	ancestral[b]=ancestral[b+1];	divergences[b][0]=divergences[b+1][0];	/* reset divergence base	*/	divergences[b][1]=divergences[b+1][1];	/* reset divergence top		*/	equaldmatrix(statelikes[b],statelikes[b+1],nchars,maxst);		/* reset likelihoods	*/	}	/* reset node properties	*/ancestral[(notu+clades)-1]=0;		/* clear final nodes	*/ape[(notu+clades)-1]=-1;			/* clear final nodes	*/minbr[(notu+clades)-1]=0;			/* clear final nodes	*/for (d=0; d<(notu+clades)-1; ++d)	if (ape[d]>br)	--ape[d];				/* reduce ancestral node by 1	*/if (HTU>br)	--HTU;					/* after many runs, nodes can get out of order	*//* rewrite descendants to remove this node							*/--clades;/* redate lineages allowing for ancestor					*/datecladerealape_one_node(HTU, desc2, divergences, ancestral[HTU], notu, ancestral);/* now, redate the clade	*/datecladerealape_pulley(HTU, ape, divergences, clades, notu, ancestral);/* estimate tree likelihood	*/MkSimplePulley(HTU, ape, notu, clades, divergences, statechars, charswstates, maxst, alphas, betas, rates, statelikes, lambda, ancestral, minbr);*nodes=clades;}