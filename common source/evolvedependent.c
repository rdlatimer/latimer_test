void evolvedependent(long **matrix,long **tree,int *trpd,int ttlbr,int notu,int *steps,int ind,int dep,int nstates,int ctype,int bias,int maxd,int **taxachange,int deltas,int UNKNOWN,int INAP){int a, b, bb, c;int br, ch, cl, dcl, sp, sp2, st;int *available;int **descnodes;/* set dependent to inapplicable when the independent state is absent */for (sp=0; sp<notu; ++sp)	{	if (matrix[sp][ind]==UNKNOWN)	matrix[sp][dep]=UNKNOWN;	else if (matrix[sp][ind]==0)	matrix[sp][dep]=INAP;	else							matrix[sp][dep]=0;	}st=0;for (a=0; a<steps[ind]; ++a)	{	sp=taxachange[ind][a];	if (sp<notu)	{		if (matrix[sp][ind]!=0)	{			if (st<nstates)	{				matrix[sp][dep]=st;				++st;				}			else	matrix[sp][dep]=ch=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates);			}		else if (matrix[sp][ind]==0)		matrix[sp][dep]=INAP;		else if (matrix[sp][ind]==UNKNOWN)	matrix[sp][dep]=UNKNOWN;		}	}/* if we cannot derived all of the states just with the derivations of the independent, then we need some evolution *//* note that this cannot happen unless there is at least one clade for which the independent is a synapomorphy - we want only its descendants */if (st<nstates)	{	descnodes=descendantnodes(tree,notu);	available=ivector(ttlbr);		/* only bother with clades */	br=0;	for (a=0; a<steps[ind] && taxachange[ind][a]>notu; ++a)	{		cl=taxachange[ind][a];		cl=cl-notu;				/* first, make sure that the clade is not already there.  If it is, then there has been a reversal, so it (and its descendants)	*/		/* cannot have changes on the dependent character without yet another reversal */		c=0;		for (b=0; b<br && c==0; ++b)	{			if (available[b]==cl+notu)	c=1;			}		/* add descendant clades and non-ancestral species within the clade to available.  Do not add the clade itself - 	*/		/* the dependent automatically kicks in and cannot change descendant clades 										*/		if (c==0)	{			for (b=1; b<descnodes[cl][0]; ++b)	{				dcl=descnodes[cl][b];				sp2=dcl+notu;				if (br==0)	{					/* add dcl+notu (the htu number) once for each branch length */					for (br=0; br<trpd[dcl+notu]; ++br)	available[br]=sp2;					}				/* sort clades upwards */				else	{					for (bb=br; bb>=0; --bb)	{						if (sp2<available[bb] || available[bb]<notu)	available[bb+1]=available[bb];						}					for (c=bb+1; c<bb+trpd[sp2]; ++c)					available[c]=sp2;					br=br+trpd[sp2];					}				}			/* now, add species */			for (b=1; b<tree[cl][0]; ++b)	{				sp=tree[cl][b];				if (trpd[sp]>0 && (matrix[sp][ind]!=INAP && matrix[sp][ind]!=UNKNOWN))	{					available[br]=sp;					++br;					}				}			}					/* remove clade, descendant clades and non-ancestral species within the clade to available 		*/		/* it is not necessary to remove the species - they will have '-' for matrix[sp][dep] and '0'	*/		/* for matrix[sp][ind] and will not have been added to the available array.						*/		else	{			removefromivector(available,cl+notu,br);			for (b=1; b<descnodes[cl][0]; ++b)	{				dcl=descnodes[cl][b];				sp2=dcl+notu;				removefromivector(available,sp2,br);				}			}		}	free_imatrix(descnodes,notu,notu);	free_ivector(available);	}}