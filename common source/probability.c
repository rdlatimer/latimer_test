#define probability#include "probability.h"#include "matrixanalysis.h"#include "matrixchange.h"#include "memory.h"#include <math.h>#include <stdlib.h>#include <stdio.h>#include <string.h>#include <time.h>#define	e	2.718281828#define	pi	3.141592654/* calculate an array that can be used to generate a Poisson distribution *//* it provides an array of integers summing to precision, where each cell n gives		the P[²n | rate, time] * precision; a random number number from 1Éprecision		now can be used to randomly generate an outcome given that Poisson probability;		in random=1000, then simply find the first cell in which result[n]>1000; n then		is the outcome./*		Requires: rate/*				  time/*				  n (number of successes);/*		Returns: P, the probability of n given r and t******************************************************************************/int *PoissonRand(double rate, double time, double precision){int	a, b;double	x, y, sum=0;int	*result;b=y=0;x=1;while (x>=(1/precision) || sum<(precision/2))	{	x=pow(e,(-1*rate*time)) * pow((rate*time),b) / fact(b);	sum=sum+(x*precision);	++b;	}result=ivector(b);/*(int *)malloc(b*sizeof(int));*/y=0;for (a=0; a<b; ++a)	{	x=pow(e,(-1*rate*time)) * pow((rate*time),a) / fact(a);	y=y+(x*(precision*precision)/sum);	result[a]=y;	if (y-result[a]>0.5)	++result[a];	}return result;}/* PoissonRandOutcome - given probability, how many successes were there given expectation of r*t/*		Requires: r (rate)/*				  t ("time")/*				  prob:  probability (e.g., from a random number of 0É1)/*		Returns: result, some n of probability prob. given r and t/* NOTE: MAX is put in there to prevent anything wonky; use RAND_MAX if you don't care!******************************************************************************/int PoissonRandOutcome(double rate, double time, double prob, int MAX){int	n;double	x=0.0f;int	result=0;for (n=0; x<prob && n<MAX; ++n)	{	result=n;	x+=Poisson(rate,time,((double) n));		/* cumulative probability of n or fewer events	*/	}return result;}/* Poisson - calculated the Poisson probability of n events over t given an/*			expectation of r*t/*		Requires: r (rate)/*				  t ("time")/*				  n (number of successes);/*		Returns: P, the probability of n given r and t******************************************************************************/double Poisson(double r, double t, double n){double	P;P = pow(e,(-1*r*t)) * pow((r*t),n) / fact(n);return P;}/* lnPoisson - calculated the poisson probability of n events over t given an/*			expectation of r*t/*		Requires: r (rate)/*				  t ("time")/*				  n (number of successes);/*		Returns: P, the probability of n given r and t******************************************************************************/double lnPoisson(double r, double t, double n){int		i;double	x=0, lnP=0;for (i=2; i<=n; ++i)	x=x+log(i);lnP = (-1*r*t) + n*log(r*t) - x;return lnP;}/* lnPoisson_vector - calculated the poisson probability of a vector of length s given /*			n[0És] events expectation of exp[0És]/*		Requires: exp: (vector of expectations, e.g., rate x time)/*				  n: vector of observations (e.g., number of successes);/*				  mxf: maximum length of both vectors;/*		Returns: P, the probability of n given r and t******************************************************************************/double lnPoisson_vector(double *exp, double *n, int mxf){int		f, i;double	x, y=-1.0f, z=-1*pow(10,-5), lnP=0;for (f=0; f<=mxf; ++f)	{/*	while ((y>z && n[f]==0) && f<mxf)	++f;/* this skips through f's that produce probabilities so low that it won't affect anything */	while (n[f]==0 && f<=mxf)	{		if (exp[f]==0)	exp[f]=pow(10,-323);	/* this is the minimum number it can calculate 			*/		lnP+=(-1*exp[f]);						/* log Poisson prob. when there are 0 finds is -1 x rate	*/		++f;		}	if (f>mxf)	break;							/* if the above while loop goes too far, then quit 			*/	if (exp[f]==0)	exp[f]=pow(10,-323);		/* this is the minimum number it can calculate 				*/	x=0.0f;	for (i=2; i<=n[f]; ++i)	x=x+log(i);	lnP=lnP+(y=(-1*exp[f])+n[f]*log(exp[f])-x);	}for (f=f; y<z; ++f)	lnP=lnP+(y=(-1*exp[f]));return lnP;}/* lnPoisson_vector - calculated the poisson probability of a vector of lenght s given /*		  P=([exp^n] x [e^-exp])/n!		lnP=(n x exp) - exp - ln (n!)/*			n[0És] events expectation of exp[0És]/*		Requires: exp: (vector of expectations, e.g., rate x time)/*				  n: vector of observations (e.g., number of successes);/*				  mxf: maximum length of both vectors;/*		Returns: P, the probability of n given r and t******************************************************************************/double lnPoisson_vector_part(double *exp, double *n, int mxf, int start){int		f;double	y=-1.0f, z=-1*pow(10,-5), lnP=0;for (f=start; f<=mxf; ++f)	{	if (exp[f]>0)	lnP+=lnPoisson(exp[f],1,n[f]);/*	while ((y>z && n[f]==0) && f<mxf)	++f;/* this skips through f's that produce probabilities so low that it won't affect anything *///	while (n[f]==0 && f<=mxf)	{//		if (exp[f]==0)	exp[f]=pow(10,-323);	/* this is the minimum number it can calculate 			*///		lnP+=(-1*exp[f]);						/* log Poisson prob. when there are 0 finds is -1 x rate	*///		++f;//		}//	if (f>mxf)	break;							/* if the above while loop goes too far, then quit 			*///	if (exp[f]==0)	exp[f]=pow(10,-323);		/* this is the minimum number it can calculate 				*///	x=0.0f;									//	for (i=2; i<=n[f]; ++i)	x=x+log(i);			/* calculate the factorial portion of the Poisson by summing the logs *///	lnP+=(y=((-1*exp[f])+n[f]*log(exp[f])-x)); 	/* log Poisson equation */	}/* this adds the probablity after we've made our last observation: 0's are somewhat improbable, after all	*///for (f=f; y<z && f<2*mxf; ++f)//	lnP+=(y=(-1*exp[f]));return lnP;}/* binomexact - calculated the exact binomial probability of n events over t possible events/*			given an expectation of x*t/*		Requires: n: successes/*				  t: possible successes/*				  x: probability of success;/*		Returns: p, the probability of n given r and t	NOTE: We use logs because they are much easier numbers with which to work.  ******************************************************************************/double binomexact(int n, int t, double x){int		i, m;double	lnc=0.0000000f, lp=0.0f, p=0.0f, y=0.0f;m=n;if (m>(t-n))	m=t-n;/* calculate combinations in logarithms */for (i=(t-m)+1; i<=t; ++i)		lnc=lnc+log(i);for (i=2; i<=m; ++i)			lnc=lnc-log(i);/* find log of probability */y=1-x;lp=lnc+((double)n)*log(x)+((double)(t-n)*log(y));p=pow(e,lp);return p;}double *binomialvector(int n, double x){int	i;double	*binomp;binomp=dvector(n+1);for (i=0; i<=n; ++i)	{	binomp[i]=binomexact(i,n,x);	}return binomp;}/* lnmultinomsuff - calculates the log of the sufficient statistic for multinomial probability/*	Requires: /*		obs: vector of observed values where obs[i] gives the number of times i is observed;/*		exp: vector of expected proportion of times we expect to observe i/*		n: number of entities sampled (i.e., the sum of obs);/*	Returns: l/*		lp, the log probability of obs given exp and n	NOTE: We use logs because they are much easier numbers with which to work.  ******************************************************************************/double lnmultinomsuff(double *obs, double *exp, int n){int		i, j=0;double	lp=0.0f;for (i=0; i<n; ++i)	if (((int) obs[i])>0)	j=i;	/* find the maximum observed value			*/for (i=0; i<=j; ++i)	{					/* don't bother after you pass the maximum	*/	while (obs[i]==0)	++i;	if (exp[i]==0)	exp[i]=pow(10,-323);		/* this is the minimum number it can calculate 				*/	lp+=obs[i]*log(exp[i]);	}return lp;}/* chidist - calculates the probability of a sum of squared deviations from expectation/*			given degrees of freedom/*	Requires: n: successes/*		ssq: sum of squared deviations from expectation/*		df: degrees of freedom;/*	Returns: X, the probability of ssq given df******************************************************************************/double chidist(double ssq, int df){double n, X=0.0f;n = df;X = (0.5*pow(e,(-1*ssq)/2)*pow((ssq/2),(n-1)))/gamma(n/2);return X;}/* Calculate Gamma(a)	Requires:		a: a real number (but must be evenly divisible by 0.5)	Returns:		g: the gamma function ******************************************************************************/double gamma(double a){int	n, b;double	g;n=a;if ((a-n)<0.5)	g=b=fact(a-1);else	g=(pow(2,-2*n)*fact(2*n)*pow(pi,0.5))/fact(n);return g;}/* Calculate gammaprob	Requires:		y: observed value (e.g., sum of squared deviations for Chi-square);		a: the alpha parameter (e.g., half the degrees of freedom in a Chi-square);		b: the lambda/beta paramter (e.g., 0.5 for a chi-square distribution);	Returns:		p: the probability of y given a & b ******************************************************************************/double gammaprob(double r, double a, double b){//int	up;//double	h, g, x, p, lh, fx;double	p,g,x;p=gammadist(r,a,b);g=0;for (x=0.01; x<=10; x=x+0.01)	{	g+=gammadist(x,a,b);	}p/=g;/*g=gamma(a);p=(b*pow(e,(-1*b*y)))*pow(b*y,a-1);lh=0.0;up=h=1.0;x=0;while (h>0.0001 && up==1)	{	fx=fx+(h= b*exp(-1*b*x) * pow(b*x,a-1));	if (h>lh)	up=1;	else		up-0;	lh=h;	x=x+0.0001;	}p=p/fx;	*/return p;}/* calculate probability of r given a & b for a gamma distribution	Requires:		r: real number the probability of which you want to know		a: alpha, the shape parameter		b: beta, the scale parameter (= lambda of Poisson);	Returns:		p: the probability of r given a & b ******************************************************************************/double gammadist(double r, double a, double b){double	p, x, y, z;y=pow(b,a);x=pow(r,(a-1));z=exp(-b*r);p=pow(r,(a-1))*pow(b,a)*exp(-b*r);x=gammln(a);		/* gets the log of GAMMA(a)	*/y=exp(x);			/* for an integer, this should be (a-1)!	*/p/=y;return p;}/***************************************************************************returns natural log of gamma function for value xx>0	written by T. Olszewski 2003	seems to have been modified from Press et al. 1992 pl. 214/***************************************************************************/double gammad(double xx){double x,y,z,tmp,ser;static double cof[6]={76.18009172947146,-86.50532032941677,24.01409824083091,-1.2317395724550155,0.1208650973866179e-2,-0.5395239384953e-5};int j;y=x=xx;tmp=x+5.5;tmp -= (x+0.5)*log(tmp);ser=1.000000000190015;for (j=0;j<=5;j++) ser += cof[j]/++y;z=-tmp+log(2.5066282746310005*ser/x);z=exp(z);return z;}/***************************************************************************returns natural log of gamma function for value xx>0	written by T. Olszewski 2003	seems to have been modified from Press et al. 1992 pl. 214/***************************************************************************/double gammln(double xx){double x,y,tmp,ser;static double cof[6]={76.18009172947146,-86.50532032941677,24.01409824083091,-1.2317395724550155,0.1208650973866179e-2,-0.5395239384953e-5};int j;y=x=xx;tmp=x+5.5;tmp -= (x+0.5)*log(tmp);ser=1.000000000190015;for (j=0;j<=5;j++) ser += cof[j]/++y;return -tmp+log(2.5066282746310005*ser/x);}/* gammapartitions - finds the medians for pts partitions within a gamma distribution with alpha = a and beta = b/*		Requires: a (alpha, shape parameter)/*				  b (beta, scale parameter)/*				  pts (number of partitions)/*		Returns: paths******************************************************************************/double *gammapartitions(double a, double b, int pts){int		i;double	ar, m, x, p, lp;double	*parts;parts=dvector(pts);			/* the partition medians 			*/m=1/((double) (pts+1));			/* the first relevant percentile	*/ar=0.0f;					/* get the area under the df to create a pdf	*/for (x=0.001; x<=10; x=x+0.001)	{	ar+=gammadist(x,a,b);	}lp=0.0f;					/* area under the curve up to last point	*/i=0;						/* current partition						*/for (x=0.001; i<pts; x=x+0.001)	{	p=gammadist(x,a,b)/ar;	/* P[x | gamma, a, b]	*/	if (lp<m && (lp+p)>m)	{		parts[i]=x;		m+=(1/((double) pts));		++i;		}	lp+=p;					/* area under the curve for P[x | gamma, a, b]	*/	}	return (parts);}/* gammapartitions - finds the medians for pts partitions within a gamma distribution with alpha = a and beta = b/*		Requires: a (alpha, shape parameter)/*				  b (beta, scale parameter)/*				  pts (number of partitions)/*		Returns: paths******************************************************************************/double *gammapartitionsrev(double a, double b, int pts){int		i, j, k;double	ar, m, x, p, lp;double	*parts;double	prec=0.0002f;parts=dvector(pts);			/* the partition medians 			*/m=1/((double) (pts+1));			/* the first relevant percentile	*/ar=0.0f;					/* get the area under the df to create a pdf	*/for (x=prec; x<=10; x=x+prec)	{	ar+=gammadist(x,a,b);	}lp=0.0f;					/* area under the curve up to last point	*/i=pts-1;						/* current partition						*/for (x=prec; i>=0; x=x+prec)	{	p=gammadist(x,a,b)/ar;	/* P[x | gamma, a, b]	*/	if (lp<m && (lp+p)>m)	{		parts[i]=x;		m+=(1/((double) pts));		--i;		}	lp+=p;					/* area under the curve for P[x | gamma, a, b]	*/	if (lp>m)	{		j=1;//		n=m;		for (j=1; m<lp; ++j)	m+=(1/((double) pts));		for (k=1; k<j; ++k)		{			parts[i]=x+(prec/((double) j));			--i;			}//		m+=(1/((double) pts));//		--i;		}	}	return (parts);}/* gammapartitions - finds the medians for pts partitions within a gamma distribution with alpha = a and beta = b/*		Requires: a (alpha, shape parameter)/*				  b (beta, scale parameter)/*				  pts (number of partitions)/*		Returns: paths******************************************************************************/double *gammapartitionmids(double a, double b, int pts){int		i;double	ar, m, x, p, lp;double	*parts;parts=dvector(pts);			/* the partition medians 			*/m=(1/((double) pts))/2;			/* the first relevant percentile	*/ar=0.0f;					/* get the area under the df to create a pdf	*/for (x=0.001; x<=10; x=x+0.001)	{	ar+=gammadist(x,a,b);	}lp=0.0f;					/* area under the curve up to last point	*/i=0;						/* current partition						*/for (x=0.001; i<pts; x=x+0.001)	{	p=gammadist(x,a,b)/ar;	/* P[x | gamma, a, b]	*/	if (lp<m && (lp+p)>m)	{		parts[i]=x;		m+=(1/((double) pts));		++i;		}	lp+=p;					/* area under the curve for P[x | gamma, a, b]	*/	}	return (parts);}/* create a probability density function from some other density function.  	This rescales each element so that the area under the curve sums to 1.0.	Note that we have a start and end to make conditional probabilities easy to calculateRequires:	density: vector of length end or greater giving the initial relative probabilities	start: the point where the pdf will start.  This usually is zero, but if 1Éend, the P[0] = 0.	end: the point where the pdf will end. This will be less than the true length of density if we are truncating******************************************************************************/double *pdfmaker (double *density, int start, int end){int i;double area;double *pdf;pdf=dvector(end+1);cleardvector(pdf,end+1,0);area=sumdvector(density,end+1);for (i=start; i<(end+1); ++i)	pdf[i]=density[i];		/* do it like this so that you can use only part of density	(e.g., conditional probability) */rescaledvector(pdf,end+1,area);return (pdf);}/* Calculate a factorial for integer d ******************************************************************************/int fact(int d){int	a, result;double	x, y;if (d<=1)	result=1;else	{	x=0;	for (a=2; a<=d; ++a)		x=x+log(a);		y=pow(e,x);	result=y;	if ((y-result)>0.5)	++result;	}return result;}/* Pathsback - calculates the number of paths that lead back to the original state/*			given steps states./*		Requires: steps (number of changes)/*				  states (number of states)/*		Returns: paths******************************************************************************/int paths_back(int steps, int states){int	i, paths;paths=0;for (i=2; i<=steps; ++i)	{	paths=paths+pow(-1,i)*pow((states-1),i-1);	}paths=abs(paths);return paths;}/* Combin - calculates the number of combinations/*		Requires: N (total number of possibilities)/*				  n (number of successes)/*		Returns: C, the number of combinations of n within N/* C = N! / (n! * [N-n]!)/* Because factorials quickly become unwieldy, it is caluclated here by summing/*		logs:  lnC = ·ln(N) - (·ln(n) + ·ln(N-n)long combin(int n, int N){int		i, C;double	x, y, z;if (n==0 || N==1)	C=1;else {	x=y=z=0;	for (i=1; i<=N; ++i)		x=x+log(i);	for (i=1; i<=n; ++i)		y=y+log(i);	for (i=1; i<=(N-n); ++i)	z=z+log(i);	x=x-(y+z);	x=pow(e,x);	C=x;	if ((x-C)>0.5)	++C;	}return C;}******************************************************************************//* mean: calculates the average given an array of length n;/*	requires:/*		data: a vector of double/*		N: the number of datapoints to be averaged/*/*	returns:/*		ave: the mean (average)******************************************************************************/double mean(double *data, int N){double	ave, rN=0.0f;rN=N;ave=darraytotal(data,N);ave=ave/rN;return ave;}/* variance: calculates the variance given an array of length n;/*	requires:/*		data: a vector of double/*		N: the number of datapoints to be averaged/*/*	returns:/*		S2: the variance******************************************************************************/double variance(double *data, int N){int		a;double	ave, S2=0.0f, rN=N;ave=mean(data,N);for (a=0; a<N; ++a)	S2=S2+((data[a]-ave)*(data[a]-ave));S2=S2/(rN-1);return S2;}/* stand_dev: calculates the standard deviation given an array of length n;/*	requires:/*		data: a vector of double/*		N: the number of datapoints to be averaged/*/*	returns:/*		S: the standard deviation******************************************************************************/double stand_dev(double *data, int N){double	S;S=variance(data,N);S=pow(S,0.5);return S;}/* sumsqdiffs - find the sum of squared differences between two vectors	Requires:		v1 - array of observed;		v2 - array of expected;		n - number of data points (length of arrays);	Returns:		ssq - sum of squared differences between v1 and v2******************************************************************************/double dsumsqdiffs (double *v1, double *v2, int n){int i;double ssq=0.0000f;for (i=0; i<n; ++i)	{	ssq+=(v1[i]-v2[i])*(v1[i]-v2[i]);	}return ssq;}/* normheight - find height of normal curve at x, given mean and standard deviation	Requires:		x - a point on the abcissa;		mean - the mean on the abcissa;		sd - the standard deviation;	returns:		ht - the height of the curve.******************************************************************************/double normheight (double x, double ave, double sd){double	y, ht;y=(x-ave)/sd;y*=y;y/=-2;ht = exp(y)/(sd*pow(2*pi,0.5));return ht;}/* nerf - calculate error function for determining area under a normal curverequires: x - distance from the mean in standard deviationsreturns: r******************************************************************************/double nerf(double x){int			i;double		d, y=1.0f, lnd=0.00000f;double long	lnr=0.00000000f, r=0.00000f;for (i=1; y>=0.001; i=i+2)	{/*	d*=i;	r+=pow(x,i)/((double) d);	*/	lnd+=log((double) i);	lnr= i*log(x)-lnd;	d=pow(e,lnd);	r+=(y=pow(e,lnr));	}return r;}/* normareabetween - calculate error function for determining area under a normal curve	Requires: 		x - 1st datum		y - 2nd	datum		ave - the mean		sd - standard deviation	Returns:		area - the area under a normal curve between x and y******************************************************************************/double normareabetween(double x, double y, double ave, double sd){double	w, z, xa, xer, ya, yer;double	area;if (x>y)	{	z=x;	x=y;	y=z;	}z=(x-y)/10000;for (w=x; w<=y; w+=z)	{		}/* if both are to the left of the mean */if (x<ave && y<=ave)	{	xa=normheight(0,(ave-x)/sd,1);	xer=nerf((ave-x)/sd);	xa*=xer;	ya=normheight(0,(ave-y)/sd,1);	yer=nerf((ave-y)/sd);	ya*=yer;		area=xa-ya;	}/* if x is to the left of the mean and y is to the right of the mean */else if (x<ave && y>ave)	{	xa=normheight(0,(ave-x)/sd,1);	xer=nerf((ave-x)/sd);	xa*=xer;	ya=normheight(0,(y-ave)/sd,1);	yer=nerf((y-ave)/sd);	ya*=yer;		area=ya+xa;	}/* if x is to the right of the mean and y is to the right of the mean */else if (x>=ave && y>ave)	{	xa=normheight(0,x-ave,1);	xer=nerf(x-ave);	xa*=xer;	ya=normheight(0,(y-ave)/sd,1);	yer=nerf((y-ave)/sd);	ya*=yer;		area=ya-xa;	}return area;}/* normpartitions - finds the partitions within a gamma distribution with µ = 0 and sd = 1/*		Requires: pts (number of partitions)/*		Returns: parts******************************************************************************/double *normpartitions(int pts){int		i,j;double	ar, m, x, p, lp;double	*parts;parts=dvector(pts-1);			/* the partition medians 			*/m=1/((double) pts);			/* the first relevant percentile	*/ar=0.0f;					/* get the area under the df to create a pdf	*/for (x=0.001; x<=4; x=x+0.001)	{	ar+=normheight(x,0,1);	}ar*=2;						/* that got half of the curve only	*/lp=0.0f;					/* area under the curve up to last point	*/j=1;if (pts%2==0)	{	i=pts/2;						/* current partition						*/	for (x=0.001; i<pts; x=x+0.001)	{		p=normheight(x,0,1)/ar;	/* 	P[x | normal, µ=0, sd=1]	*/		if (lp<m && (lp+p)>m)	{			parts[i-j]=parts[i]=x;			m+=(1/((double) pts));			++i;			}		lp+=p;					/* area under the curve for P[x | normal, µ=0, sd=1]	*/		}	}else	{	}	return (parts);}/* normpartitions - finds the partitions within a gamma distribution with µ = 0 and sd = 1/*		Requires: pts (number of partitions)/*		Returns: parts******************************************************************************/double *normpartitionmids(int pts){int		i,j;double	m, x, p, lp;double	*parts;parts=dvector(pts);			/* the partition medians 			*/lp=0.5f;					/* area under the curve up to last point	*/if (pts%2==0)	{	m=0.5+(0.5/((double) pts));				/* the first relevant percentile	*/	i=pts/2;								/* current partition						*/	j=i-1;	for (x=0.001; i<pts; x=x+0.001)	{		p=normheight(x,0,1)*0.001;			/* 	P[x | normal, µ=0, sd=1]	*/		if (lp<m && (lp+p)>m)	{			parts[j]=-1*x;			parts[i]=x;			m+=(1/((double) pts));			++i;			--j;			}		lp+=p;					/* area under the curve for P[x | normal, µ=0, sd=1]	*/		}	}/* routine for odd numbers: middle partition centered on the mean	*/else	{	}	return (parts);}/* normpartitions - finds the partitions within a gamma distribution with µ = 0 and sd = 1/*		Requires: pts (number of partitions)/*		Returns: parts******************************************************************************/double *lgnormpartitionmids(double mag, int pts){int		i;double	ar, par, m, x, p, lp, px, lx;double	*parts;parts=dvector(pts);			/* the partition medians 			*/lp=0.5f;					/* area under the curve up to last point	*//* find area under curve	*/ar=0.0f;									/* area under lognormal curve	*/px=pow(mag,-4.01);							/* prior x	*/for (lx=-4; lx<=5; lx+=0.01)	{	x=pow(mag,lx);							/* lx is log x												*/	ar+=normheight(lx,0,1)*(x-px);			/* normal curve is based on log x, but area is based on x	*/		px=x;									/* update prior x	*/	}par=0.0f;									/* area under lognormal curve	*/px=pow(mag,-4.01);							/* prior x	*/i=0;if (pts%2==0)	{	m=(0.5/((double) pts));					/* the first relevant x-tile	*/	for (lx=-4; i<pts; lx+=0.01)	{		x=pow(mag,lx);						/* lx is log x												*/		p=log(normheight(lx,0,1))+log(x-px);		p=exp(p);//		p=normheight(lx,0,1)*(x-px);		/* normal curve is based on log x, but area is based on x	*/		/* if partition line crossed, then tally & increment	*/		if ((par/ar)<m && ((par+p)/ar)>=m)	{//		if (ar<m && (ar+p)>=m)	{			parts[i]=x;			m+=(1/((double) pts));			++i;			}		par+=p;								/* add to area		*/		px=x;								/* update prior x	*/		}	}/* routine for odd numbers: middle partition centered on the mean	*/else	{	}	return (parts);}/* randomnormal: given a random number between 0É1, it tells you how many standard deviations away it would be from the mean	*/double randomnormal(double precision){double x, h1, h2, cdf=0.5, prob;double	sign=1.0f;prob=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);if (prob<0.5)	{	sign*=-1;	prob=1-prob;	}h1=normheight(0,0,1);for (x=precision; cdf<=prob; x+=precision)	{	h2=normheight(x,0,1);				/* height of normal curve at this point	*/	cdf+=precision*((h1+h2)/2);	h1=h2;	}	return sign*(x-precision);}/* randonormalZ: returns standard deviations away from the mean based on uniform 0É1 probability.Requires:	ave: the mean	sd: standard deviations.	NOTE: if ave=0 and sd=1 (i.e., a classic normal curve centered on the mean and Z-transformed), then this is	just normsinv(p) with p being a random number from 0É1******************************************************************************/double randomnormalZ (double ave, double sd){double prob;prob=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);return ave+(sd*normsinv(prob));}/* randomnormal: given a random number between 0É1, it tells you how many standard deviations away it would be from the mean	*//* randomnormal: given a random number between 0É1, it tells you how many standard deviations away it would be from the mean	*/double randomnormaloutcome(double prob, double precision){double x, h1, h2, cdf=0.5;double	sign=1.0f;if (prob<0.5)	{	sign*=-1;	prob=1-prob;	}h1=normheight(0,0,1);for (x=precision; cdf<=prob; x+=precision)	{	h2=normheight(x,0,1);				/* height of normal curve at this point	*/	cdf+=precision*((h1+h2)/2);	h1=h2;	}	//for (dev=0.001; cdf<=(0.5+(sign*(prob-0.50))); dev+=0.01)	{//	x=erf(dev)/2;//	x=nerf(dev);//	x=normareabetween(0.0, dev, 0.0, 1.0);//	x=taylornerf(dev);//	cdf+=x;//	}return sign*(x-precision);}double taylornerf(double z){int n;double	erfz=0.0f, v;v=1.0f;for (n=0; n<100 && v>0.0000000001; ++n)	{	v=(pow(-1,n)*pow(z,((2*n)+1)))/(fact(n)*((2*n)+1));	erfz+=v;	}erfz*=(2/sqrt(pi));return erfz;}double normalcurvearea (double precision){double x, h1, h2;double area=0.0f;h1=normheight(0,0,1);for (x=precision; x<4.0; x+=precision)	{	h2=normheight(x,0,1);				/* height of normal curve at this point	*/	area+=precision*((h1+h2)/2);	h1=h2;	}return area;}long double normsinv(long double p){long double x;long double q, r;if ((0 < p )  && (p < P_LOW))	{	q = sqrt(-2*log(p));	x = (((((C1*q+C2)*q+C3)*q+C4)*q+C5)*q+C6) / ((((D1*q+D2)*q+D3)*q+D4)*q+1);	}else	{    if ((P_LOW <= p) && (p <= P_HIGH)){       q = p - 0.5;       r = q*q;       x = (((((A1*r+A2)*r+A3)*r+A4)*r+A5)*r+A6)*q /(((((B1*r+B2)*r+B3)*r+B4)*r+B5)*r+1);	    }    else	{        if ((P_HIGH < p)&&(p < 1))	{           q = sqrt(-2*log(1-p));           x = -(((((C1*q+C2)*q+C3)*q+C4)*q+C5)*q+C6) / ((((D1*q+D2)*q+D3)*q+D4)*q+1);	        }	    }	}/* If you are compiling this under UNIX OR LINUX, you may uncomment this block for better accuracy.if(( 0 < p)&&(p < 1)){   z = 0.5 * erfc(-x/sqrt(2)) - p;   u = z * sqrt(2*PI) * exp(x*x/2);   x = x - u/(1 + x*u/2);}*/return x;}/* normhistogramReturns a vector giving the midpoint of S equal area partitions of a normal curve.  For 1, it would give A[0]=2;For 2, it gives A[0]=0.430727299 and A[1]=-0.430727299.***********************************************************************************************/double *normhistogram(int S){int		a;long double x;double	*A;A=dvector(S);for (a=0; a<S; ++a)	{	x=((long double) (S-a))/((long double) (S+1));	A[a]=normsinv(x);	}return A;}double exponentialrandom (double lambda){double p, t;p=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);t=-1*log(1-p)/lambda;return t;}