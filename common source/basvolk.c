#include <stdio.h>#include <stdlib.h>#include <math.h>#include <time.h>#include <string.h>#include <limits.h>#define MAXSPEC	2000      /*max number of specs*/#define FUNC(a,b,c,d,e,f)	((*func)(a,b,c,d,e,f))	/*used in midpnt*/#define EPS			1.0e-6         /*used in qromo*/#define JMAX		14					/*used in qromo*/#define JMAXP		(JMAX+1)       /*used in qromo*/#define K			5         		/*used in qromo*/FILE *fpout;double zerosum(double theta, double m, long int J);double gammln(double xx);double *vector(long nl, long nh);void free_vector(double *v, long nl, long nh);long int *lvector(long nl, long nh);void lfree_vector(long int *v, long nl, long nh);void polint(double xa[], double ya[], int n, double x, double *y, double *dy);double qromo(double (*func)(double,double,int,long int,double,double), double theta, double gam, int nn, long int J, double coef, double a, double b, double (*choose)(double(*)(double,double,int,long int,double,double), double, double, int, long int, double, double, double, int));double midpnt(double (*func)(double,double,int,long int,double,double), double theta, double gam, int nn, long int J, double coef, double a, double b, int n);double volkov(double theta, double gam, int n, long int J, double coef, double y);int main(void){long int J;double theta,m;char buff[10];fpout=fopen("volkout.txt","w");fprintf(fpout,"volkout.txt\n");printf("\nEnter theta value:");theta=atof(gets(buff));printf("\nEnter m value:");m=atof(gets(buff));printf("\nEnter J value:");J=atoi(gets(buff));fprintf(fpout,"theta=%f   m=%f   J=%i\n",theta,m,J);printf("theta=%f   m=%f   J=%i\n",theta,m,J);zerosum(theta,m,J);fclose(fpout);}/***************************************************************************/double zerosum(double theta, double m, long int J){double gam,coef,cumphi[21],phi,S;long int x,y,expon;for (x=0; x<21; x++) {	cumphi[x] = 0.0;	}gam = m*(J-1)/(1-m);coef = (log(theta)+gammln(J+1)+gammln(gam)-gammln(1+1)-gammln(J-1+1)-gammln(J+gam));phi = qromo(volkov,theta,gam,1,J,coef,0.0,gam,midpnt);S=phi;fprintf(fpout,"1\t%e\t%e\n",phi,S);cumphi[0] = 0.5*phi;cumphi[1] = 0.5*phi;expon = 1;for (y=2;y<=J;y++) {  coef = (log(theta)+gammln(J+1)+gammln(gam)-gammln(y+1)-gammln(J-y+1)-gammln(J+gam));  phi = qromo(volkov,theta,gam,y,J,coef,0.0,gam,midpnt);  S = S+phi;  fprintf(fpout,"%i\t%e\t%e\n",y,phi,S);  if (y==pow(2,expon)) { 		cumphi[expon] = cumphi[expon]+0.5*phi;     expon++;     cumphi[expon] = cumphi[expon]+0.5*phi;  	}   else {	cumphi[expon] = cumphi[expon]+phi;		}	}S = 0.0;fprintf(fpout,"\noctave\tS\tcum(S)\n");for (x=0; x<21; x++) {if (cumphi[x]==0.0) {break;}S = S + cumphi[x];  fprintf(fpout,"%i\t%e\t%e\n",x,cumphi[x],S);	}}/***************************************************************************/double volkov(double theta, double gam, int n, long int J, double coef, double y){return exp(gammln(n+y)+gammln(J-n+gam-y)-gammln(1+y)-gammln(gam-y)-y*theta/gam+coef);}/***************************************************************************/double gammln(double xx)/*returns natural log of gamma function for value xx>0*/{double x,y,tmp,ser;static double cof[6]={76.18009172947146,-86.50532032941677,24.01409824083091,-1.2317395724550155,  0.1208650973866179e-2,-0.5395239384953e-5};int j;y=x=xx;tmp=x+5.5;tmp -= (x+0.5)*log(tmp);ser=1.000000000190015;for (j=0;j<=5;j++) ser += cof[j]/++y;return -tmp+log(2.5066282746310005*ser/x);}/***************************************************************************/double midpnt(double (*func)(double,double,int,long int,double,double), double theta, double gam, int nn, long int J, double coef, double a, double b, int n)/*this routine computes the nth stage refinement of an extended midpoint rule.func is input as a pointer to the function to integrated between limits a and b,also input.  When called with n=1, thie routine returns the crudest estimate ofthe integral of f(x)dx over the interval a to b.  Subsequent calls with n=2,3,...(in that sequential order) will improve the accuracy of s by adding (2/3)x3^(n-1)additional interior points.  s should not be modified between sequential calls.*/{double x,tnm,sum,del,ddel;static double s;int it,j;if (n == 1) {	return (s=(b-a)*FUNC(theta,gam,nn,J,coef,0.5*(a+b)));	} else {	for (it=1,j=1;j<n-1;j++) it *=3;	tnm=it;	del=(b-a)/(3.0*tnm);	ddel=del+del;	x=a+0.5*del;	sum=0.0;	for (j=1;j<=it;j++) {		sum += FUNC(theta,gam,nn,J,coef,x);		 x += ddel;		 sum += FUNC(theta,gam,nn,J,coef,x);		 x += del;		}	s=(s+(b-a)*sum/tnm)/3.0;	return s;	}}/***************************************************************************/double qromo(double (*func)(double,double,int,long int,double,double), double theta, double gam, int nn, long int J, double coef, double a, double b, double (*choose)(double(*)(double,double,int,long int,double,double), double, double, int, long int, double, double, double, int))/*Romberg integration on an open interval.  Returns the integral of the functionfunc from a to b, using any specified integrating function choosen and Romberg'smethod.  Normally choose will be an open formula, not evaluating the function atthe endpoints.  It is assumed that choose triples the number of steps on eachcall, and that its error series contains only even powers of the number of steps.The routines midpnt, midinf, midsql, midsqu, medexp, are possible choices forchoose.  The parameters have the same meaning as in qromb.*/{void polint(double xa[], double ya[], int n, double x, double *y, double *dy);int j;double ss,dss,h[JMAXP+1],s[JMAXP+1];h[1]=1.0;for (j=1;j<=JMAX;j++) {	s[j]=(*choose)(func,theta,gam,nn,J,coef,a,b,j);	if (j >= K) {		polint(&h[j-K],&s[j-K],K,0.0,&ss,&dss);		if (fabs(dss) < EPS*fabs(ss)) return ss;		}	  s[j+1]=s[j];	  h[j+1]=h[j]/9.0;	/*this is where the assumption of step tripling and an even error series is used*/	}return 0.0;				/*never get here*/}/***************************************************************************/void polint(double xa[], double ya[], int n, double x, double *y, double *dy)/*Given arrays  xa[1..n] and ya[1..n], and given a value x, this routine returnsa value y, and an error estimate dy.  If P(x) is the polynomial of degree N-1such that P(xai)=yai, i=1,...,n, then the returned value y = P(x).*/{int i,m,ns=1;double den,dif,dift,ho,hp,w;double *c,*d;dif=fabs(x-xa[1]);c=vector(1,n);d=vector(1,n);for (i=1;i<=n;i++) {				/*here we find the index ns of the closest table entry,*/	if ( (dift=fabs(x-xa[i])) < dif) {		ns=i;		dif=dift;		}	c[i]=ya[i];        			/*and initialize the tableau of c's and d's.*/	d[i]=ya[i];	}*y=ya[ns--];						/*This is the initial approximation to y.*/for (m=1;m<n;m++) {			/*For each column of the tableau,*/	for (i=1;i<=n-m;i++) {		/*we loop over the current c's and d's and update them.*/		ho=xa[i]-x;		hp=xa[i+m]-x;		w=c[i+1]-d[i];		den=ho-hp;		den=w/den;		d[i]=hp*den;		c[i]=ho*den;		}	*y += (*dy=(2*ns < (n-m) ? c[ns+1] : d[ns--]));/*After each column in the tableau is completed, we decide which correction,c or d, we want to add to our accumulating value of y, i.e., which path totake through the tableau--forking up or down.  We do this in such a way asto take the most "straight line" route through the tableau to its apex,updating ns accordingly to keep track of where we are.  This route keeps thepartial approximation centered (insofar as possible) on the target of x.The last dy added is thus the error indication.*/	}free_vector(d,1,n);free_vector(c,1,n);}/***************************************************************************/double *vector(long nl, long nh)/*allocates a double vector with subscript range v[nl..nh]*/{	double *v;   v=(double *)malloc((size_t) ((nh-nl+1+1)*sizeof(double)));   return v-nl+1;}void free_vector(double *v, long nl, long nh)/*free a double vector allocated with vector()*/{	free((char*) (v+nl-1));}long int *lvector(long nl, long nh)/*allocates a double vector with subscript range v[nl..nh]*/{	long int *v;   v=(long int *)malloc((size_t) ((nh-nl+1+1)*sizeof(long int)));   return v-nl+1;}void lfree_vector(long int *v, long nl, long nh)/*free a double vector allocated with vector()*/{	free((char*) (v+nl-1));}