double *fuzz_fit_mul_gamma(double *dist, int chars, int mxstp, double base, int pts) {int i = 0;					/* LOOP VARIABLE													*/double ev = 0.000f;			/* LOOP SLOPE 														*/double amin = 0.000000001f;	/* min slope														*/double ain = 1.000f;		/* initial slope													*/double ai = 0.000f;			/* how much to increment ev in each loop							*/double lai[2];				/* last two slope increments										*/double iai;					/* initial slope increment at each richness							*/double mai=0.000001f;		/* minimum evenness increment										*/double as[3];				/* previous log likelihoods (cell number = num previous).			*/double *bals;				/* BEST ev PARAMETERS (DISTRIBUTION SLOPE) - return array format	*/double pbes;				/* previous best support for decay rate								*/double x,y;bals=dvector(2);for (i=0; i<2; i++) bals[i]= -1.0*DBL_MAX;ain=1.0f;iai=ain-1;if (ai==0)	ai=0.00001f;pbes = 0.0f;/*	ai = (double) FITINC / 10;	*//* increment starting at 0.1 since we are almost never going to find slopes of 2+	*/for (i=0; i<2; i++) bals[i] = -1.0*DBL_MAX;for (i=0; i<3; i++) as[i] = -1.0*DBL_MAX;lai[0]=lai[1]=0.0f;ai=iai;while (ai+ain<= amin)	ai/=2;for (al = ain; ((al>=amin && fabs(ai)>mai) && ((bpals == 0.0f) || (bals[0] > (bpals + SUPINC)))); al += ai) {			/* calculate gamma distribution	with alpha=beta=al	*/	parts=gammapartitionmids(al,al,pts);		/* get the expected sampled distribution */	cleardvector(steps,mxstp,0);	for (i=0; i<pts; ++i)	{		for (j=1; j<mxstp; ++j)	{			y=Poisson(parts[i],base,j);			/* get the probability of j changes given expected change parts[i]*base	*/			steps[j]+=y;									x+=y;			}		}	/* calculate likelihood of gamma distribution	*/	als[0]=0;	for (j=1; j<mxstp; ++j)	{		steps[j]/=y;		/* make a pdf	*/		als[0]+=dist[j]*log(steps[j]);		}	/*Debugging line */	if (al<=amin) printf("\nDANGER: gamma alpha=%f, S=%f ",al,as[0]);	if (as[0] >= bals[0]) {							/* IF BETTER THAN BEST FIT */		bpals = bals[0];								/* save last best ssq for evenness */		bals[0] = as[0];								/* STORE FIT */		bals[1] = al;								/* STORE SLOPE */				/* while we are getting better on the initial increment, just ride with it			*/		if (ai==iei)	{			lei[1]=lei[0];			lei[0]=ai;			}		/* if we have a later improvement, wander halfway back to the last improvement 	*/		/* (remember, we always start at the most likely slope up to that point			*/		else	{			lei[1]=lei[0];			lei[0]=ai;			ai/=-2;			if ((al+ai)<=amin)	ai*=-1;			}		}					/* If likelihood has not increased, then reset and change the increment  value	*/	else	{		/* if we went from x -> -x, then we want to cut the increment in half */		if (ai==-1*lei[0] || ai==iei)	{			lei[1]=lei[0];			lei[0]=ai;			if (al==(ain+iei))	{				ai/=-2;				}			else if (ai==iei)	{				/* determine whether as[0] or as[2] is the second best - move towards that	*//*				if (as[0]>as[2])	ai/=2;				else				ai/=-2;	*/				ai/=2;							/* redone 20.03.2009 to get this to search properly	*/				}			else	{				/* determine whether as[0] or as[1] is the second best - move towards that	*//*				if (as[0]>as[1])	ai/=2;				else				ai/=-2;	*/				if (fabs(lei[0])==ai)	ai/=2;				else					ai*=-1;				}			}		/* if we just divided in half, then we want to reverse the increment */		else if (ai==-1*iei || (2*fabs(ai)==fabs(lei[0])))	{			/* if al+x/2 got closer than al-x, back up and go to al+x/4				if (as[0]>as[2])	ai/=2;			/* otherwise go to al-x/2												else				ai*=-1;	*/			if (fabs(lei[0])==ai)		{				lei[1]=lei[0];				lei[0]=ai;				ai/=2;					}			else	{				lei[1]=lei[0];				lei[0]=ai;				ai*=-1;				}			}		al=bals[1];		}	/* make sure that ai does not take al below 1.0 */	while (al+ai<= amin)	{		if (fabs(lei[0])==fabs(lei[1]))	ai/=2;		else							ai=-1*lei[0];		}			as[2] = as[1];									/* Store last 2 attempts to identify	*/	as[1] = as[0];									/* when the peak is past 				*/	}return bals;}