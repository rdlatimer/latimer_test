#define parsimony#include "parsimony.h"#include "memory_koz.h"struct NODE 	{	int member1;	int member2;	int anc;	};float TotalTreeLength(struct NODE *node, int nnodes, int ntaxa, int root_node, int **matrix, int nchars, int nstates)	{	int i;	float treelength;		treelength=0;	for (i=1;i<=nchars;++i) treelength+=SingleChr_TreeLength(node, nnodes, ntaxa, matrix, root_node, i, nstates);	return treelength;	}	float SingleChr_TreeLength(struct NODE *node, int nnodes, int ntaxa, int **matrix, int root_node, int chr_number, int nstates){	int i, j;	float treelength;	float **anc_set;	float **cost_matrix;	int gobots;	anc_set=fmatrix(nnodes+1, nstates);	cost_matrix=unordered_costmatrix(nstates);/*	for (i=0;i<nstates;++i)		{		for (j=0;j<nstates;++j) printf ("%f\t", cost_matrix[i][j]);		printf ("\n");		}	scanf ("%d", &gobots);*/		for (i=1;i<=nnodes;++i) for (j=0;j<nstates;++j) anc_set[i][j]=-1;		GetLengthSet(node, matrix, ntaxa, root_node, nstates, anc_set, cost_matrix, chr_number);	// get the lengths for each possible reconstruction of the root node	treelength=10e10;	for (i=0;i<nstates;++i) if (anc_set[root_node][i]<treelength) treelength=anc_set[root_node][i]; // return the minimum length		free_fmatrix(anc_set, nnodes+1, nstates);	free_fmatrix(cost_matrix, nstates, nstates);	return treelength;}void GetLengthSet (struct NODE *node, int **matrix, int ntaxa, int anc_node, int nstates, float **anc_set, float **cost_matrix, int chr_number){	int anc_state, desc_state, descendant;	float length, minlength;	for (anc_state=0;anc_state<nstates;++anc_state)				// for each possible ancestral state reconstruction		{		minlength=100000;		descendant=node[anc_node].member1;						// check left branch first		if (descendant<=ntaxa) minlength=cost_matrix[anc_state][matrix[descendant][chr_number]];	// if descendant is a tip, use its observed state		else for (desc_state=0;desc_state<nstates;++desc_state) 									// if descendant is a node, check each possible reconstruction			{			if (anc_set[descendant-ntaxa][desc_state]<0) 				GetLengthSet(node, matrix, ntaxa, descendant-ntaxa, nstates, anc_set, cost_matrix, chr_number);	// if the node hasn't been checked yet, check it			length=cost_matrix[anc_state][desc_state]+anc_set[descendant-ntaxa][desc_state];			if (length<minlength) minlength=length;			}		anc_set[anc_node][anc_state]=minlength;					minlength=100000;		descendant=node[anc_node].member2;		if (descendant<=ntaxa) minlength=cost_matrix[anc_state][matrix[descendant][chr_number]];		else for (desc_state=0;desc_state<nstates;++desc_state) 			{			if (anc_set[descendant-ntaxa][desc_state]<0) 				GetLengthSet(node, matrix, ntaxa, descendant-ntaxa, nstates, anc_set, cost_matrix, chr_number);			length=cost_matrix[anc_state][desc_state]+anc_set[descendant-ntaxa][desc_state];			if (length<minlength) minlength=length;			}		anc_set[anc_node][anc_state]+=minlength;			}				}float **unordered_costmatrix(int nstates){	int i, j;	float **cost_matrix;		cost_matrix=fmatrix(nstates, nstates);		for (i=0;i<nstates;++i)						// construct cost matrix		{		for (j=0;j<nstates;++j)			{			if (i==j) cost_matrix[i][j]=0;			else cost_matrix[i][j]=1;			}		}	return cost_matrix;}float **ordered_costmatrix(int nstates){	int i, j;	float **cost_matrix;		cost_matrix=fmatrix(nstates, nstates);		for (i=0;i<nstates;++i)						// construct cost matrix		{		for (j=0;j<nstates;++j)			{			if (i==j) cost_matrix[i][j]=0;			else if (j>i) cost_matrix[i][j]=cost_matrix[i][j-1]+1;			else cost_matrix[i][j]=cost_matrix[i-1][j]+1;			}		}	return cost_matrix;}float **irrevup_costmatrix(int nstates){	int i, j;	float **cost_matrix;		cost_matrix=fmatrix(nstates, nstates);		for (i=0;i<nstates;++i)						// construct cost matrix		{		for (j=0;j<nstates;++j)			{			if (i==j) cost_matrix[i][j]=0;			else if (j>i) cost_matrix[i][j]=1;			else cost_matrix[i][j]=10e10;			}		}	return cost_matrix;}float **irrevdown_costmatrix(int nstates){	int i, j;	float **cost_matrix;		cost_matrix=fmatrix(nstates, nstates);		for (i=0;i<nstates;++i)						// construct cost matrix		{		for (j=0;j<nstates;++j)			{			if (i==j) cost_matrix[i][j]=0;			else if (j>i) cost_matrix[i][j]=10e10;			else cost_matrix[i][j]=1;			}		}	return cost_matrix;}float **strat_costmatrix(int nstates){	int i, j;	float **cost_matrix;		cost_matrix=fmatrix(nstates, nstates);		for (i=0;i<nstates;++i)						// construct cost matrix		{		for (j=0;j<nstates;++j)			{			if (i==j) cost_matrix[i][j]=0;			else if (j>i) cost_matrix[i][j]=cost_matrix[i][j-1]+1;			else cost_matrix[i][j]=10e10;			}		}	return cost_matrix;}