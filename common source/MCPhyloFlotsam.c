	for (ch=0; ch<nchars; ++ch)	{		/* skip invariant characters and logically dependent characters.  The latter are handled when their independent leader is evolved */		while ((sychos[ch]==0 || maxch[ch]==0) && ch<nchars)	++ch;		if (ch>=nchars)			break;		steps[ch]=st=0;		clearivector(taxachange[ch],mxdel,-1);		ev=0;					/* make sure that inapplicable characters have at least one taxon that can be changed */		if (aptaxa[ch]<notu)	{			/* count unknowns - these will be put back in later */			u=0;			for (a=0; a<notu; ++a)	if (matrix[a][ch]==UNKNOWN)	++u;			/* now find a node that has similar diversity */			clse=RAND_MAX;						/* start from the bottom if most taxa are scored */			if (aptaxa[ch]>(notu/2))	{				for (br=nodes-1; br>0; ++br) {					/* if you find a clade exactly the same size, then use it */					if (tree[br][0]==(notu-aptaxa[ch]))	{						best=br;						br=nodes;						clse=0;						}					/* if not, find the closest one - favor those that are slightly larger */					else	{						a=abs((notu-aptaxa[ch])-tree[br][0]);						if (a<clse)	{							clse=a;							best=br;							}						else if (a==clse && tree[br][0]>tree[best][0])	best=br;						}					}				}			/* start from the top otherwise */			else	{				for (br=nodes-1; br>0; ++br) {					/* if you find a clade exactly the same size, then use it */					if (tree[br][0]==aptaxa[ch])	{						best=br;						br=nodes;						clse=0;						}					/* if not, find the closest one - favor those that are slightly larger */					else	{						a=abs(aptaxa[ch]-tree[br][0]);						if (a<clse)	{							clse=a;							best=br;							}						else if (a==clse && tree[br][0]>tree[best][0])	best=br;						}					}				}						for (sp=0; sp<notu; ++sp)	{				if (aptaxa[ch]>(notu/2))	matrix[sp][ch]=0;				else						matrix[sp][ch]=INAP;				}			for (a=1; a<tree[best][0]; ++a)	{				sp=tree[best][a];				matrix[sp][a]=0;				}			}	/* end initial creation of inapplicable character */				/* make autapomorphic characters change on one species only */		/* invariants do not change at all */		for (ch=ch; maxch[ch]<=1; ++ch)	{			/* skip invariants and make autapomorphies autapomorphic */			if	(maxch[ch]==1)	{				c=0;				/* we will sample only from otus here - so do not include clades in branches array! */				/* this part rewritten with Cubs winning 7-0 against the Marlins in Game 4 */				for (sp=0; sp<notu; ++sp)					if ((matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP) && trpd[sp]>0)	++c;				if (c>0)	{					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);					while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || (trpd[sp]==0 || sp>=notu))						sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);					invmatrix[ch][sp]=matrix[sp][ch]=1;					taxachange[ch][0]=sp;					}				/* if only cells belong to species with 0 length branches */				if (c==0)	{					/* flip-flop an unknown apomorphic species with a known plesiomorphic one - give plesiomorphic species a ? and the other a 1 */					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);					while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || sp2>=notu)						sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);										sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);					while (trpd[sp2]==0 || sp2>=notu)						sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);					invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp2][ch];					invmatrix[ch][sp2]=matrix[sp2][ch]=1;					taxachange[ch][0]=sp2;					}	/* end routine if all scored species were unknown */				ev=1;				++deltas;				++steps[ch];				++mpd[ch];				}			}		/* this should leave us with a character that needs to be changed OR out of characters */		if (ch>=nchars)	break;					used=0;	/* this tells how many branches are discarded; used > steps IF there are absents */		/* branch length is taken into account by trpd */		equalivector(branches,available,ttlbr);		/* Binary && unordered multistate is Easy */		/* for normal character, have it change until all X states are realized */		if (nstates[ch]==2 || ctype[ch]==1)	{			/* changed 10/14/2003 so that non-apomorphic characters	diagnose 2+ species */			/* for characters with logical dependents, enough taxa must have the independent to produce all of the states */			minder=2;			if (sychos[ch]>1)	{				for (c=1; c<sychos[ch]; ++c)	{					cc=sychomat[ch][c];					if (nstates[cc]>minder)	minder=nstates[cc];					}				}			for (st=0; (st<nstates[ch]-1 || der[ch]<=minder); st=st)	{				/* There are ttlbr-used branches that could change */				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				/* have binary characters change on branches - if they are not autapomorphic, then they need to diagnose multiple species THIS WAS REMOVED 10/14/2003				else				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (avnodes-used));*/				sp = branches[br];								/* this shouldn't be necessary, but occassionaly the random number generator */				/* produces a number outside of the proscribed limits */				while (trpd[sp]==0 || br>=(ttlbr-used))	{					br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));					sp = branches[br];					}				if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{					ev=1;					if (nstates[ch]==2)	invmatrix[ch][sp]=matrix[sp][ch]=1;					else					invmatrix[ch][sp]=matrix[sp][ch]=st+1;					++der[ch];				/* add one to the number of species showing derived condition(s) */					}				else if (sp>notu)	{					/* use st+1 instead of nstates[ch] here - we want only 0Ést+1 not 0Énstates    */					/*		(remember, st has not yet been incremented, so we need st+1) 		   */					/* This section modified 10/14/2003 to make sure characters are not apomorphic */					/* if multistate, then we need at least two iterations */					if (nstates[ch]>2)	{						/* if we have not yet derived all of the states, do it this way 			*/						/* if deriving first state (i.e., st=0), then it is the same as binary		*/						if (st<nstates[ch] && st==0)							evolvebinaryinclade(tree[sp-notu],matrix,ch);						/* if deriving subsequent states, then used change unmodified species to st+1 		*/						else if (st<(nstates[ch]-1) && st>=1)	{							for (c=1; c<=tree[sp-notu][0]; ++c)	{								sp2=tree[sp-notu][c];								if (matrix[sp2][ch]==0)	matrix[sp2][ch]=st+1;								}							}	//						evolveunorderedinclade(tree[sp-notu],matrix,ch,st+2,UNKNOWN,INAP);						/* if we have an essentially apomorphic states, then just do it like any other time */						else							evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],UNKNOWN,INAP);						}					else		evolvebinaryinclade(tree[sp-notu],matrix,ch);					for (c=1; c<=tree[sp-notu][0]; ++c)	{						sp2=tree[sp-notu][c];						if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;						invmatrix[ch][sp2]=matrix[sp2][ch];						if (invmatrix[ch][sp2]!=0 && (invmatrix[ch][sp2]!=UNKNOWN && invmatrix[ch][sp2]!=INAP))							++der[ch];						else if (invmatrix[ch][sp2]==0)							--der[ch];					/* this will happen only if there are reversals */						}					/* if there was a change, then tally it */					}				a=ttlbr-used;				used=used+trpd[sp];				/* remove branches from possible change list (but only if more changes must be made)	*/				if (st<(nstates[ch]-1) || der[ch]<=1)					removefromivector(branches,sp,&a);									if (used<steps[ch])	{					printf("ERROR LINE 954 - there are more changes than deleted branches for Ch%dÉ\n",ch+1);					}				/* if ev=1 then the state has been derived */				if (ev==1)	{					++mpd[sp];					/* sort taxa change for characters with dependents as you go through - this will make life simpler later */					if (sychos[ch]>1)	{						if (steps[ch]==0)	taxachange[ch][steps[ch]]=sp;						else	{							for (a=steps[ch]-1; a>=0 && (sp<taxachange[ch][a] || (sp>=notu && taxachange[ch][a]<notu)); --a)	taxachange[ch][a+1]=taxachange[ch][a];							taxachange[ch][a+1]=sp;							}						}					else	taxachange[ch][steps[ch]]=sp;										++steps[ch];					++deltas;					++st;	/* we increment this only if we have made a change */					}				}	/*end derivation of state */			}	/* end loop for binary / unordered characters */				/* Ordered Multistates are tougher */		else if (nstates[ch]>2 && ctype[ch]==0)	{			used=0;			for (st=0; (st<nstates[ch]-1 && (steps[ch]<mxdel && steps[ch]<maxch[ch])); st=st)	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp=branches[br];				/* this shouldn't be necessary, but occassionaly the random number generator */				/* produces a number outside of the proscribed limits */				while (trpd[sp]==0 || br>=(ttlbr-used))	{					br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));					sp = branches[br];					}				if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{					matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);					multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);					/* in this case all taxa must be examined just in case the matrix has been recentered due to a negative number */					for (sp2=0; sp2<notu; ++sp2)	{						if (ev==0 && invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;						invmatrix[ch][sp2]=matrix[sp2][ch];						}					ev=1;					}									else if (sp>notu)	{					flip = ((int) (100 * rand() / RAND_MAX));					if (flip<bias[ch])	flip=1;					else				flip=-1;					evolveorderedinclade(tree[sp-notu],matrix,ch,flip, INAP, UNKNOWN);					multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);					/* in this case all taxa must be modified just in case the matrix has been recentered due to a negative number */					for (sp2=0; sp2<notu; ++sp2)	{						if (ev==0 && invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;						invmatrix[ch][sp2]=matrix[sp2][ch];						}					}									/* if ev=1 then the state has been derived */				if (ev==1)	{					++mpd[sp];					/* sort taxa change for characters with dependents as you go through - this will make life simpler later */					if (sychos[ch]>1)	{						if (steps[ch]==0)	taxachange[ch][steps[ch]]=sp;						else	{							for (a=steps[ch]-1; a>=0 && (sp<taxachange[ch][a] || (sp>=notu && taxachange[ch][a]<notu)); --a)	taxachange[ch][a+1]=taxachange[ch][a];							taxachange[ch][a+1]=sp;							}						}					else	taxachange[ch][steps[ch]]=sp;					++steps[ch];					++deltas;					/* note - do not increment st here - that is done only if a new state is derived */					}				/* check if all states have been derived */				/* note: this is needed only for ordered multistates */				if (steps[ch]>=nstates[ch]-1)	{					for(a=0; a<notu; ++a)	{						if (matrix[a][ch]>st && (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN))							st=matrix[a][ch];						}					}				a=ttlbr-used;				used=used+trpd[sp];				/* remove branches from possible change list (but only if more changes must be made)	*/				if (st<(nstates[ch]-1))					removefromivector(branches,sp,&a);				if (used<steps[ch])					printf("ERROR LINE 2817 - there are more changes than deleted branches for Ch%dÉ\n",ch+1);								/* emergency reboot procedure! - clear everything and start over again */				if (used==ttlbr)	{					for (a=0; a<steps[ch]; ++a)	{						sp=taxachange[ch][a];						--mpd[sp];						taxachange[ch][a]=0;						}					deltas=deltas-steps[ch];					st=steps[ch]=used=0;					for (sp=0; sp<notu; ++sp)						if (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN)							invmatrix[ch][sp]=matrix[sp][ch]=0;					for (sp=0; sp<ttlbr; ++sp)	branches[sp]=available[sp];					}				}			/* if there are many states and few taxa, then you do not want to mess with this anymore.  Any changes will either eliminate extreme states,			or simply shift the state up or down one (resulting in no observable change once standardized.  So, if steps >= half the taxa, then shut it down */						}	/* end loop for ordered multistates */				if (sychos[ch]>1)	{			for (c=1; c<=sychos[ch]; ++c)	{				cc=sychomat[ch][c];				evolvedependent(matrix,tree,trpd,ttlbr,notu,steps,ch,cc,nstates[cc],ctype[cc],bias[cc],taxachange,&deltas,UNKNOWN,INAP);				}			}		}	/* end derivation of all character states */	/* Step #2: make sure that each apomorphic species has a derivation */	for (sp=0; sp<notu+nodes; ++sp)	{		if (mpd[sp]==0 && trpd[sp]>0)	{			while (mpd[sp]==0)	{				ev=0;				ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));				while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))					ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));								if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{					if (nstates[ch]==2)							invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);					else if (ctype[ch]==1)						invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);					else if (ctype[ch]==0)	{						invmatrix[ch][sp]=matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);						/* make sure no negative numbers are kept! */						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					ev=1;	/* this means that there was a change */					}								else if (sp>notu)	{					d=0;					/* make sure that there are taxa with scorable conditions for this character 		*/					/* and also that not all the descendants have changed already for this character 	*/					/* (the latter can be omitted as evolution cannot know this - but it makes the 		*/					/* output easier to compare to empirical studies.)									*/							for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{						sp2=tree[sp-notu][sc];						if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;						else	{							for (c=0; c<steps[ch]; ++c)	{								if (taxachange[ch][c]==sp2)	{									++d;									c=steps[ch];									}								}							}		/* if any taxa have not yet changed, then d < clade diversity */						}	/* end search for scored taxa */						/* if d is less than clade diversity, then proceed with change */					if (d<tree[sp-notu][0])	{						/* if character is an unordered multistate, then we need an array	*/						/* that tells how each state changed withing the clade				*/						if (ctype[ch]==1)	{							/* routine for unordered multistates */							if (nstates[ch]>2)	{								evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);								}							/* routine for binaries */							else	{								evolvebinaryinclade(tree[sp-notu],matrix,ch);								}							}	/* end routine for unordered / binary characters */						/* routine for ordered multistate */						else {							/* flip is used only for multistates */							flip = ((int) (100 * rand() / RAND_MAX));							if (flip<bias[ch])	flip=1;							else				flip=-1;							evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);							multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);							}						/* now make sure that there was change */						for (c=0; c<notu; ++c)	{							if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;							invmatrix[ch][c]=matrix[c][ch];							}						}	/* end conditional loop */					}	/* end routine for clade */				/* if there was a change, then ev = 1.  Now tally the information */				if (ev==1)	{					taxachange[ch][steps[ch]]=sp;					++steps[ch];					++mpd[sp];					++deltas;					}	/* add changes if there actually was a change */				}	/* routine is repeated until an apomorphy is acquired */						}	/* end derivation of apomorphy for this branch */		}	/* end derivation for each apomorphic branch */