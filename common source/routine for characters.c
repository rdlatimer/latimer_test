int	a, b, c, d, g, h, ch, sp, steps, m, t;int	nodes, ttlbr, branch, tb;int mxdl, apo, chcl;int	truns, mruns, cruns;int *chapos, *chuns, *chmax;int	*dstates, *dtypes, *done;int	*available, *savailable, *trpd;long *chvector, *chvector2;long **tree, **smatrix, **dumatrix;unsigned long *compat, *scompat;long **compsort;unsigned long **scompsort, **chclass;double x, y, z, pr, dp=0.1f, ave;double **Lsteps, **Psteps, ****prcmp, **Lrates, **Srates, **sbars;double	*zz, *ps, *bstgam, *bstlgn, *chclruns;char outfile1[100], outfile2[100], outfile3[100], outfile4[100];FILE *output, *output2;				dumatrix=smatrix;				/* redo this to take into account the proper character	*/				while (done[ch]!=0 && ch<nchars)	++ch;				if (ch>=nchars)	break;								dtypes[nchars]=ctype[ch];				dstates[nchars]=nstates[ch];								/* now, run simulations of individual characters	*/				for (c=0; c<cruns; ++c)	{					if (debug==1)	srand((unsigned int) (t*mruns*cruns)+(m*cruns)+c);					clearlvector(chvector,notu,0);					/* set to zero for each run		*/					for (a=0; a<notu; ++a)	{						if (matrix[a][ch]==UNKNOWN)		chvector[a]=UNKNOWN;						else if (matrix[a][ch]==INAP)	chvector[a]=INAP;						}										/* set aside branches eligible to change; this might allow multiple entries for branches	*/					for (a=0; a<=ttlbr; ++a)	savailable[a]=available[a];					tb=ttlbr;										/* total branches in each run	*/					for (steps=1; steps<=mxdl; ++steps)	{						/* 2010-01-18 BRAINWAVE! Just do one MORE step per run. D'OH!!!!	*/	/*					chvector=evolvecharacterNsteps(tree,1,notu,chvector,nstates[ch],ctype[ch],bias[ch],UNKNOWN,INAP);	*/						d=(int)((double)rand() / ((double)RAND_MAX + 1) * tb);	/* pick a number from 0 - (ttlbr-1)	*/						branch=savailable[d];						removefromivector(savailable,branch,&tb);	/* don't use this branch again	*/						chvector=evolvecharacteronemorestep(tree,branch,notu,chvector,nstates[ch],ctype[ch],bias[ch],UNKNOWN,INAP);						/* next, add it to the rest of the matrix */						for (sp=0; sp<notu; ++sp)	dumatrix[sp][scompsort[c][1]]=chvector[sp];	/* CHECK THIS!!!	*/						/* find its compatibility */						d=char_nu_comp(nchars, dstates, notu, smatrix, dtypes, nchars, comptype, 0, UNKNOWN, INAP);	/* get compatibility of simulated char	*/						apo=autapo_char(smatrix,notu,nchars,UNKNOWN,INAP);											/* get autapomorphies of simulated char	*/						/* increment the probability of the observed combination of compatibilities and taxa with derived condition by 1/cruns	*/						a=countstatescharvector(chvector, notu, UNKNOWN, INAP);						if (nstates[ch]==a)	{//							++prcmp[chclass[ch]][steps][apo][d];							}	/* 2010-01-19: this means that the conditional probability of evolving n states for an n-state character is maintained	*/						}					/* make note of which other characters are done by this loop	*/					done[ch]=1;					for (ch2=ch+1; ch2<nchars; ++ch2)	{//						if(chclass[ch2]==chclass[ch])	done[ch2]=1;						}					}		/* end run for individual character classes	*/		lsimc=simc=(empcompat-compsort[0][0]);		clearivector(done,nchars,0);	/* clear "done" vector for each matrix run	*/		for (simc=(empcompat-compsort[nchars-1][0]); simc<=(empcompat-compsort[nchars-1][0]); simc=simc)	{			/* go through characters needing this compatibility	*/			if (simc!=(empcompat-compsort[nchars-1][0]))	{				if (simc<lsimc)	{					for (c=lch; c<nchars; ++c)	{						if (compsort[c][0]==simc)	{							ch2=c;							f=0;							c=nchars;							}						}					}				else if (simc>lsimc)	{					for (c=lch; c>=0; --c)	{						if (compsort[c][0]==simc)	{							ch2=c;							f=0;							c=0;							}						}					}				else	f=1;				}			else		ch2=f=0;						/* 2010.12.13: work on this loop tomorrow!  	*/			/* if d==0, then this simc is good!				*///			ch=compat[ch2][3];			/* this is the character number	*/			if (f==0)	{				++chclruns[compsort[g][5]];				/* now go through all of the characters with the same compatibility	*/				for (g=ch2; compsort[g][0]==compsort[ch2][0]; ++g)	{					ch=compsort[g][3];	/* this is the character number	*/					if (done[g]==0)	{						for (c=0; c<cruns; ++c)	{							if (debug==1)	srand((unsigned int) (t*mruns*cruns)+(m*cruns)+c);							clearlvector(chvector,notu,0);					/* set to zero for each run		*/							for (a=0; a<notu; ++a)	{								if (matrix[a][ch]==UNKNOWN)		chvector[a]=UNKNOWN;								else if (matrix[a][ch]==INAP)	chvector[a]=INAP;								}														for (a=0; a<=ttlbr; ++a)	savailable[a]=available[a];							tb=ttlbr;										/* total branches in each run	*/							for (steps=1; steps<=mxdl; ++steps)	{								/* 2010-01-18 BRAINWAVE! Just do one MORE step per run. D'OH!!!!	*/			/*					chvector=evolvecharacterNsteps(tree,1,notu,chvector,nstates[ch],ctype[ch],bias[ch],UNKNOWN,INAP);	*/								d=(int)((double)rand() / ((double)RAND_MAX + 1) * tb);	/* pick a number from 0 - (ttlbr-1)	*/								branch=savailable[d];								removefromivector(savailable,branch,&tb);								chvector=evolvecharacteronemorestep(tree,branch,notu,chvector,nstates[ch],ctype[ch],bias[ch],UNKNOWN,INAP);								/* next, add it to the rest of the matrix */								for (sp=0; sp<notu; ++sp)	smatrix[sp][nchars]=chvector[sp];								/* find its compatibility */								d=char_nu_comp(nchars, dstates, notu, smatrix, dtypes, nchars, comptype, 0, UNKNOWN, INAP);	/* get compatibility of simulated char	*/								apo=autapo_char(smatrix,notu,nchars,UNKNOWN,INAP);											/* get autapomorphies of simulated char	*/								/* increment the probability of the observed combination of compatibilities and taxa with derived condition by 1/cruns	*/								a=countstatescharvector(chvector, notu, UNKNOWN, INAP);								if (nstates[ch]==a)	{									++prcmp[compsort[ch][5]][steps][apo][d];									}	/* 2010-01-19: this means that the conditional probability of evolving n states for an n-state character is maintained	*/								}							/* make note of which other characters are done by this loop	*/							done[g]=1;														/* look through remainder of compsort to find characters with same compatibility, states & unknowns/inapplicables	*/							/* that will require rewriting this loop																			*/							for (h=g+1; h<nchars; ++h)								if(compsort[h][4]==compsort[g][4])	done[h]=1;							}		/* end run for individual character classes	*/						}	/* in case where character type has not been done yet	*/					}	/* finish characters of the same compatiblity	*/				}	/* end case where submatrix matches real submatrix	*/				/* now, evolve another step and see if the resulting compatibility is good for anything	*/			chch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars-1));			vectorequallongmatrixcol(smatrix,chvector2,chch,notu);			chvector=evolvecharacteronemorestep(tree,branch,notu,chvector,nstates[ch],ctype[ch],bias[ch],UNKNOWN,INAP);			simc=nu_comp(nstates, notu, smatrix, ctype, nchars-1, 0, 0, UNKNOWN, INAP);			}	/* end loop of maximum -> minimum compatibility	*/		}	/* end matrix run	*/	}}/*likelyvarratesremainder - calculates the probability of X compatibilities given Y steps and observed matrix.Requires:	matrix: empirical character matrix	nstates: array giving the number of states per character	ctype: array giving character types (0: ordered; 1: unordered)	maxd: maximum numbers of steps per character	nchars: number of characters	bias: array giving biases in gains / loses for character, with 60 meaning P[increase]=0.6	maxd: maximum number of changes per character	notu: number of taxa	fossil: 0 if no fossils, 1 if fossils included.  	mbl: simulation parameters (origination, extinction, sampling, speciation mode)	debug: 0 if using a random number, 1 if using a number generated by the replicate for debugging purposes	UNKNOWN: value for "?"	INAP: value for inapplicable**********************************************************************************************************************************************************/void **likelyvarratesremainderB(char *taxonname, long **matrix, int *nstates, int *ctype, int *maxd, int *bias, int *depend, int nchars, int empcompat, int comptype, int notu, int fossil, double *mbl, int debug, int UNKNOWN, int INAP){int	a, b, c, d, f, g, h, ch, ch2, cc, sp, steps, m, t, s, chch, lch;int	nodes, ttlbr, branch, tb;int mxdl, apo, chcl;int	truns, mruns, cruns;int *chapos, *chuns, *chmax;int	*dstates, *dtypes, *done;int	*available, *savailable, *trpd;long simc, lsimc;long *chvector, *chvector2;long **tree, **smatrix;unsigned long *compat;long **compsort;double x, y, z, pr, dp=0.1f, ave;double **Lsteps, **Psteps, ****prcmp, **Lrates, **Srates, **sbars;double	*zz, *ps, *bstgam, *bstlgn, *chclruns;char outfile1[100], outfile2[100], outfile3[100], outfile4[100];FILE *output, *output2;strcpy(outfile1,taxonname);strcat(outfile1,"_lnL[Steps|CharComp]");strcpy(outfile2,taxonname);strcat(outfile2,"_lnL[Rate|CharComp]");strcpy(outfile3,taxonname);strcat(outfile3,"_S[Rate|CharComp]");strcpy(outfile4,taxonname);strcat(outfile4,"_Rate_Information");/* get the real compatibilities for each character */compat=char_comp(nstates,notu,matrix,ctype,nchars,comptype,0,UNKNOWN,INAP);/* see if there are dependent inapplicables */a=0;for (ch=0; ch<nchars && a==0; ++ch)	if (depend[ch]!=ch)	a=1;/* allocate memory for "dummy" arrays & matrices - these simply jackknife the real data to make a nchars-1 matrix & character info */dstates=ivector(nchars+1);dtypes=ivector(nchars+1);done=ivector(nchars);											/* goes to 1 when a character with like states & unknowns is simulated	*/chapos=autapomorphies(matrix,nstates,notu,nchars,UNKNOWN,INAP);	/* number of apomorphies for each character								*/chuns=unknownstates(matrix,notu,nchars,UNKNOWN,INAP);			/* number of unknowns for each character								*/chmax=ivector(nchars);											/* maximum state for each character										*/smatrix=lmatrix(notu, nchars+1);								/* simulated matrix														*//*chclass=ivector(nchars+1);										/* class of each real character (states & unknowns)						*//* assign each character to a class based on states and unknowns	*//*clearivector(chclass,nchars+1,-1);								/* FIXED 2010-06-25		*/compsort=lmatrix(nchars,5);for (a=0; a<nchars; ++a)	{	compsort[a][0]=compat[a];	compsort[a][1]=nstates[a];	compsort[a][2]=chuns[a];	compsort[a][3]=a;	compsort[a][4]=-1;	}sortlmatrixoncol_inc(compsort,0,nchars,4);chcl=0;for (a=0; a<nchars; ++a)	{	while (compsort[a][4]!=-1 && a<nchars)	++a;	if (a>=nchars)	break;	compsort[a][4]=chcl;	if (a<(nchars-1))	{		for (c=a+1; compsort[c][0]==compsort[a][0]; ++c)	{			if (compsort[c][1]==compsort[a][1] && compsort[c][2]==compsort[a][2])	compsort[c][4]=chcl;			}		}	++chcl;	}sortlmatrixoncol_inc(compsort,4,nchars,5);chvector=lvector(notu);			/* why is there a memory error here?					*/chclruns=dvector(chcl);cleardvector(chclruns,chcl,0);mxdl=maxiarray(maxd,nchars);	/* maximum number of changes possible for any character */if (mxdl>notu)	mxdl=notu-1;Lsteps=dmatrix(nchars,mxdl+1);clearivector(chmax,nchars,notu-1);/*for (ch=0; ch<nchars; ++ch)/*	if (nstates[ch]>=4 && chmax[ch]<(notu-1))	chmax[ch]=notu-1;	*/equalivector(dstates,nstates,nchars);equalivector(dtypes,ctype,nchars);printf("\nFor each character, this routine will generate X trees and Y matrices per tree.\n");printf("  Each matrix is of N-1 characters, with N being the observed number.  The compatibility.\n");printf("  of each matrix will be the same as the compatibility of the other N-1 characters in\n");printf("  the observed matrix.  The program then will evolve the character K, K+1, K+2É steps Z times\n");printf("  (with K being one less than the number of states).  The program then calculate the\n");printf("  compatibility of the character.  It also will determine whether the proper number of states\n");printf("  and the proper number of derived taxa evolve.  Over X*Y*Z runs, this will determine the\n");printf("  probability of the observed structure of each character given K, K+1, etc., steps.  \n\n");printf("Enter the number of trees to use for each character (X above): ");//scanf("%i",&truns);cruns=mruns=truns=50;printf("\n");printf("Enter the number of matrices to evolve per tree (Y above): ");//scanf("%i",&mruns);printf("\n");printf("Enter the number of times to replicate each number of steps (Z above): ");//scanf("%i",&cruns);printf("\n");printf("The program will examine %d trees, generating %d matrices for each tree with\n",truns,mruns);printf("\teach number of steps replicated %d times to find L[setps | CPs, states, apomorphies].\n",cruns);tree=lmatrix(notu+4,notu+1);					/* also will give clade diversity in first cell 			*/												/* 		finally, gives branch lengths in final two lines 	*/prcmp=dhypcube(chcl+1,mxdl+1,notu,nchars+1);	/* go to mxdl+1 because there are cases where you can have zero steps with inapplicables	*/												/* go to nchars+1 for compatibilities because 0...nchars are possible with nchars+1 chars	*/printf("Doing tree ");for (t=0; t<truns; ++t)	{	/* evolve a tree to evolve characters over */	if (debug==1)	srand((unsigned int) t);	/* This is easier because you do not know how many nodes you'll get when sampling over time */	if (fossil==1)	tree=evolvetreeVenn(notu, mbl, fossil);	/* if no fossil taxa, then just make a cladogram and a Venn tree from it */	else	{		tree=evolvecladogram(notu,tree);		tree=clademember(tree, notu, notu-1);		}		/* find the number of nodes and their diversities */	nodes=0;	for (a=0; a<notu; ++a)	{		if (tree[a][0]>1)	++nodes;		else	a=notu;		}	/* allocate memory for branch lengths */	trpd=ivector(nodes+notu);	trpd[notu]=0;	for (sp=0; sp<notu; ++sp)	{		trpd[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */		}	for (sp=1; sp<nodes; ++sp)	{		trpd[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors */		}	/* allocate memory for arrays containing branches needing changes */	ttlbr=branchnumber(tree,notu);	available=ivector(2*ttlbr);		/* this should not be necessary	*/	savailable=ivector(2*ttlbr);		/* this should not be necessary	*/	/* determine appropriate branches for changes - all nodes & species without sampled descendants */	/* we'll ignore the basal node, assuming that it is all 0's */	b=0;	for (a=1; a<nodes; ++a)	{		for (c=0; c<trpd[a+notu]; ++c)	{			available[b]=a+notu;			++b;			}		}	for (a=0; a<notu; ++a)	{		for (c=0; c<trpd[a]; ++c)	{			available[b]=a;			++b;			}		}		printf("%d, matrix ",t+1);	for (m=0; m<mruns; ++m)	{		if (debug==1)	srand((unsigned int) (t*mruns)+m);				/* another idea: 			1) evolve matrix of original dimensions to the same size;			2) go from 0Énchar simulated compatibilities and pull out those matching				original compatibility of observed characters;			3) evolve 1Én steps for characters matching those observed characters;			4) rinse and repeat.				/* 09 Dec. 2010: do this for partial matrix for each character; skip "done" characters!	*/		/* use array of submatrix compatibilities to decide if this matrix is OK				*/		/* evolve a matrix matching the compatibility of the original matrix					*/		/* now starts off at the highest n-m matrix compatibility for ch-1 characters where		*/		/*		n-m is the compatibility of the remaining (ch-1) characters after you remove 	*/		/*		the most compatible character(s)												*/		smatrix=evolvetocompat(tree,(empcompat-compsort[0][0]),notu,matrix,(nchars-1),nstates,ctype,bias,chmax,depend,comptype,UNKNOWN,INAP);		lsimc=simc=(empcompat-compsort[0][0]);		clearivector(done,nchars,0);	/* clear "done" vector for each matrix run	*/		for (simc=(empcompat-compsort[nchars-1][0]); simc<=(empcompat-compsort[nchars-1][0]); simc=simc)	{			/* go through characters needing this compatibility	*/			if (simc!=(empcompat-compsort[nchars-1][0]))	{				if (simc<lsimc)	{					for (c=lch; c<nchars; ++c)	{						if (compsort[c][0]==simc)	{							ch2=c;							f=0;							c=nchars;							}						}					}				else if (simc>lsimc)	{					for (c=lch; c>=0; --c)	{						if (compsort[c][0]==simc)	{							ch2=c;							f=0;							c=0;							}						}					}				else	f=1;				}			else		ch2=f=0;						/* 2010.12.13: work on this loop tomorrow!  	*/			/* if d==0, then this simc is good!				*///			ch=compat[ch2][3];			/* this is the character number	*/			if (f==0)	{				++chclruns[compsort[g][4]];				/* now go through all of the characters with the same compatibility	*/				for (g=ch2; compsort[g][0]==compsort[ch2][0]; ++g)	{					ch=compsort[g][3];	/* this is the character number	*/					if (done[g]==0)	{						for (c=0; c<cruns; ++c)	{							if (debug==1)	srand((unsigned int) (t*mruns*cruns)+(m*cruns)+c);							clearlvector(chvector,notu,0);					/* set to zero for each run		*/							for (a=0; a<notu; ++a)	{								if (matrix[a][ch]==UNKNOWN)		chvector[a]=UNKNOWN;								else if (matrix[a][ch]==INAP)	chvector[a]=INAP;								}														for (a=0; a<=ttlbr; ++a)	savailable[a]=available[a];							tb=ttlbr;										/* total branches in each run	*/							for (steps=1; steps<=mxdl; ++steps)	{								/* 2010-01-18 BRAINWAVE! Just do one MORE step per run. D'OH!!!!	*/			/*					chvector=evolvecharacterNsteps(tree,1,notu,chvector,nstates[ch],ctype[ch],bias[ch],UNKNOWN,INAP);	*/								d=(int)((double)rand() / ((double)RAND_MAX + 1) * tb);	/* pick a number from 0 - (ttlbr-1)	*/								branch=savailable[d];								removefromivector(savailable,branch,&tb);								chvector=evolvecharacteronemorestep(tree,branch,notu,chvector,nstates[ch],ctype[ch],bias[ch],UNKNOWN,INAP);								/* next, add it to the rest of the matrix */								for (sp=0; sp<notu; ++sp)	smatrix[sp][nchars]=chvector[sp];								/* find its compatibility */								d=char_nu_comp(nchars, dstates, notu, smatrix, dtypes, nchars, comptype, 0, UNKNOWN, INAP);	/* get compatibility of simulated char	*/								apo=autapo_char(smatrix,notu,nchars,UNKNOWN,INAP);											/* get autapomorphies of simulated char	*/								/* increment the probability of the observed combination of compatibilities and taxa with derived condition by 1/cruns	*/								a=countstatescharvector(chvector, notu, UNKNOWN, INAP);								if (nstates[ch]==a)	{									++prcmp[compsort[ch][4]][steps][apo][d];									}	/* 2010-01-19: this means that the conditional probability of evolving n states for an n-state character is maintained	*/								}							/* make note of which other characters are done by this loop	*/							done[g]=1;														/* look through remainder of compsort to find characters with same compatibility, states & unknowns/inapplicables	*/							/* that will require rewriting this loop																			*/							for (h=g+1; h<nchars; ++h)								if(compsort[h][4]==compsort[g][4])	done[h]=1;							}		/* end run for individual character classes	*/						}	/* in case where character type has not been done yet	*/					}	/* finish characters of the same compatiblity	*/				}	/* end case where submatrix matches real submatrix	*/				/* now, evolve another step and see if the resulting compatibility is good for anything	*/			chch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars-1));			vectorequallongmatrixcol(smatrix,chvector2,chch,notu);			chvector=evolvecharacteronemorestep(tree,branch,notu,chvector,nstates[ch],ctype[ch],bias[ch],UNKNOWN,INAP);			simc=nu_comp(nstates, notu, smatrix, ctype, nchars-1, 0, 0, UNKNOWN, INAP);			}	/* end loop of maximum -> minimum compatibility	*/		}	/* end matrix run	*/	}}		for (c=0; c<chcl; ++c)	{			/* if there is a character values in scompsort[c][2], then character scompsort[c][1] should be excised from the matrix					and replaced with simulated characters to determine P[compatibility | steps, matrix compatibilty				*/			if (scompsort[c][2]<nchars)	{				/* now, go through and figure out which character classes require this amount of remaining compatibility	*/								/* go through all the character classes with the same compatibility and note that we have a run	*/				/* start with the matching character from compsort (i.e., the cth least compatible				*/				/* compsort[scompsort[c][2]][0] gives the compatibility of the matching character				*/								/* Now, simulate the evolution of a single character matching this character class	*/				/* Keep missing data as it was in an original character from this class				*/				/* we'll add inapplicables later!													*/								for (steps=1; steps<=mxdl; ++steps)	{					for (c=0; c<cruns; ++c)	{						if (debug==1)	srand((unsigned int) (t*mruns*cruns)+(m*cruns)+c);						clearlvector(chvector,notu,0);					/* set to zero for each run		*/						/* set if there are unknowns, then randomly draw a character from this character class and use its unknowns	*/												/* now set simulated vector to the unknowns/inaps in question	*/						for (a=0; a<notu; ++a)	{							if (matrix[a][ch]==UNKNOWN)		chvector[a]=UNKNOWN;							else if (matrix[a][ch]==INAP)	chvector[a]=INAP;							}												for (a=0; a<=ttlbr; ++a)	savailable[a]=available[a];						tb=ttlbr;										/* total branches in each run	*/						for (steps=1; steps<=mxdl; ++steps)	{							/* 2010-01-18 BRAINWAVE! Just do one MORE step per run. D'OH!!!!	*/		/*					chvector=evolvecharacterNsteps(tree,1,notu,chvector,nstates[ch],ctype[ch],bias[ch],UNKNOWN,INAP);	*/							d=(int)((double)rand() / ((double)RAND_MAX + 1) * tb);	/* pick a number from 0 - (ttlbr-1)	*/							branch=savailable[d];							removefromivector(savailable,branch,&tb);							chvector=evolvecharacteronemorestep(tree,branch,notu,chvector,nstates[ch],ctype[ch],bias[ch],UNKNOWN,INAP);							/* next, add it to the rest of the matrix */							for (sp=0; sp<notu; ++sp)	smatrix[sp][nchars]=chvector[sp];							/* find its compatibility */							d=char_nu_comp(nchars, dstates, notu, smatrix, dtypes, nchars, comptype, 0, UNKNOWN, INAP);	/* get compatibility of simulated char	*/							apo=autapo_char(smatrix,notu,nchars,UNKNOWN,INAP);											/* get autapomorphies of simulated char	*/							/* increment the probability of the observed combination of compatibilities and taxa with derived condition by 1/cruns	*/							a=countstatescharvector(chvector, notu, UNKNOWN, INAP);							if (nstates[ch]==a)	{								++prcmp[compsort[ch][4]][steps][apo][d];								}	/* 2010-01-19: this means that the conditional probability of evolving n states for an n-state character is maintained	*/							}						/* make note of which other characters are done by this loop	*/						done[g]=1;												/* look through remainder of compsort to find characters with same compatibility, states & unknowns/inapplicables	*/						/* that will require rewriting this loop																			*/						for (h=g+1; h<nchars; ++h)							if(compsort[h][4]==compsort[g][4])	done[h]=1;						}		/* end run for individual character classes	*/					}												/* scroll through any other members of this character class	*/				for (d=scompsort[c][2]; compsort[d][0]==compsort[scompsort[c][2]][0]; ++d)	{					//printf("%d\n",d);					++chclruns[scompsort[d][1]];	/* scompsort[d][1] is the character class for character d	*/					/* skip to the next character class with the same compatibility	*/					if (d<(nchars-1))	{						while (d<(nchars-1) && (compsort[d+1][5]==compsort[d][5] && compsort[d+1][0]==compsort[d][0]))	++d;						}					else	break;					}	/* end search of simulated character classes */				}			}	/* end run through characters to find appropriate compatibilities	*/