#define matrix_functions#include "matrix.h"/* counts the number of unique entries in a given column of a matrix/* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long *ul_vector_of_unique(unsigned long *matrix, int length, int numvalues){	int i=0, j=0, n=0;	unsigned long *temp;		temp=ulvector(numvalues);	for (i=0 ; i<numvalues ; i++) 		temp[i] = 0;		temp[0]=matrix[0];		for (i=0 ; i<length ; i++) {		for (j=0 ; j<=n ; j++)			if (matrix[i] == temp[j]) {				j=INT_MAX;				break;			}		if (j != INT_MAX) {			n++;			temp[n]=matrix[i];		}	}	return temp;}/* counts the number of unique entries in a given column of a matrix/* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int l_countcolumn(long **matrix, int length, int column){int i=0, j=0, n=0;int *temp;int total=1;temp=ivector(length);for (i=0 ; i<length ; i++) 	temp[i] = 0;temp[0]=matrix[0][column];for (i=0 ; i<length ; i++) {	for (j=0 ; j<=n ; j++)		if (matrix[i][column] == temp[j]) {			j=INT_MAX;			break;			}	if (j != INT_MAX) {		n++;		temp[n]=matrix[i][column];		total++;		}	}free_ivector(temp);return total;}/* counts the number of unique entries in a given column of a matrix/* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int ul_countcolumn(unsigned long **matrix, int length, int column){int i=0, j=0, n=0;int *temp;int total=1;temp=ivector(length);for (i=0 ; i<length ; i++) 	temp[i] = 0;temp[0]=matrix[0][column];for (i=0 ; i<length ; i++) {	for (j=0 ; j<=n ; j++)		if (matrix[i][column] == temp[j]) {			j=INT_MAX;			break;			}	if (j != INT_MAX) {		n++;		temp[n]=matrix[i][column];		total++;		}	}free_ivector(temp);return total;}/* counts the number of unique entries in a given column of a matrix/* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int d_countcolumn(double **matrix, int length, int column){	int i=0, j=0, n=0;	double *temp;	int total=1;		temp=dvector(length);		temp[0]=matrix[0][column];		for (i=0 ; i<length ; i++) {		for (j=0 ; j<=n ; j++)			if (matrix[i][column] == temp[j]) {				j=INT_MAX;				break;			}		if (j != INT_MAX) {			n++;			temp[n]=matrix[i][column];			total++;		}	}	free_dvector(temp);	return total;}/* sums the entries in a given column of a matrix/* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long ul_sumcolumn(unsigned long **matrix, int length, int column){	int i=0;	unsigned long total=0;			for (i=0 ; i<length ; i++) {		total+=matrix[i][column];	}	return total;}/* sums rows of an matrix and returns an array with those values/* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long *ul_sumrows(unsigned long **matrix, int taxa, int lists){int i=0,j=0;unsigned long *array;array=ulvector(lists);for (i=0 ; i<lists ; i++) array[i]=0;for (i=0 ; i<taxa ; i++)	for(j=0 ; j<lists ; j++)		array[j]+=matrix[j][i];return array;}/* count rows of an matrix and returns an array with those values/* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long *ul_countrows(unsigned long **matrix, int taxa, int lists){int i=0,j=0;unsigned long *array;array=ulvector(lists);for (i=0 ; i<lists ; i++) array[i]=0;for (i=0 ; i<taxa ; i++)	for(j=0 ; j<lists ; j++)		if (matrix[j][i]>0) array[j]+=1;return array;}/* returns an array with the entries from a given column of a matrix with the constraint/* that a given column of the matrix must be unique (the two columns need not be the same). /* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long *ul_pullcolumn(unsigned long **matrix, int length, int unique_column, int value_column){int i=0, j=0, n=0;unsigned long *unique, *value, *final;int total=1;unique=ulvector(length);value=ulvector(length);for (i=0 ; i<length ; i++) {	unique[i] = 0;	value[i] = 0;	}		unique[0]=matrix[0][unique_column];value[0]=matrix[0][value_column];	for (i=0 ; i<length ; i++) {	for (j=0 ; j<=n ; j++)		if (matrix[i][unique_column] == unique[j]) {			j=INT_MAX;			break;			}	if (j != INT_MAX) {		n++;		unique[n]=matrix[i][unique_column];		value[n]=matrix[i][value_column];		total++;		}	}final=ulvector(total);for (i=0 ; i<total ; i++) 	final[i] = value[i];free_ulvector(unique);free_ulvector(value);return final;}/* returns an array with the entries from a given column of a matrix with the constraint/* that a given column of the matrix must be unique (the two columns need not be the same). /* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */double *d_pullcolumn(double **matrix, int length, int unique_column, int value_column){int i=0, j=0, n=0;double *unique, *value, *final;int total=1;unique=dvector(length);value=dvector(length);unique[0]=matrix[0][unique_column];value[0]=matrix[0][value_column];	for (i=0 ; i<length ; i++) {	for (j=0 ; j<=n ; j++)		if (matrix[i][unique_column] == unique[j]) {			j=INT_MAX;			break;			}	if (j != INT_MAX) {		n++;		unique[n]=matrix[i][unique_column];		value[n]=matrix[i][value_column];		total++;		}	}final=dvector(total);for (i=0 ; i<total ; i++) 	final[i] = value[i];free_dvector(unique);free_dvector(value);return final;}/* return an array of means based on matrix sent /* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */float *ul_matrixmean(unsigned long **matrix, int bins, int bootreps){	int i, j;	float *answer;	unsigned long *total;	total=ulvector(bins);	for (i=0 ; i<bins ; i++)		total[i]=0;	for (i=0 ; i<bins ; i++)		for (j=0 ; j<bootreps ; j++)			total[i]+=matrix[i][j];				answer=fvector(bins);	for (i=0 ; i<bins ; i++)		answer[i] = 0.f;	for (i=0 ; i<bins ; i++)		answer[i] = (1.0*total[i])/(1.0*bootreps);		free_ulvector(total);	return answer;}/* return an array of column means based on float matrix sent /* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */float *f_matrixmean(float **matrix, int bins, int bootreps){	int i, j;	float *answer;	float *total;	total=fvector(bins);	for (i=0 ; i<bins ; i++) {		total[i]=0.f;	}			for (i=0 ; i<bins ; i++) {		for (j=0 ; j<bootreps ; j++) {			total[i]+=matrix[i][j];		}	}				answer=fvector(bins);	for (i=0 ; i<bins ; i++) {		answer[i] = 0.f;	}	for (i=0 ; i<bins ; i++) {		answer[i] = total[i]/(1.0*bootreps);	}		free_fvector(total);	return answer;}/* return an array of 95% confidence intervals based on matrix sent, high and low /* a conservative estimate at small sample sizes/* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long **ul_matrixconfidence(unsigned long **matrix, int bins, int bootreps, float confidence){	int i, j;	unsigned long **interval;	unsigned long *temp;	int hi=0, lo=0;		/* calculate which array cell to select */	/* -1 and -2 are because arrays run from 0 instead of 1 */	lo = trunc((bootreps-(bootreps*confidence))/2) - 1;	hi = (bootreps-lo) - 2;	if (lo < 0) {		lo =0;		hi = bootreps -1;	}	interval=ulmatrix(bins, 2);		/* memory space for ci's */	for (i=0 ; i<bins ; i++)		for (j=0 ; j<2 ; j++)			interval[i][j]=0;	temp=ulvector(bootreps);				/* memory space for temp matrix */	for (i=0 ; i<bootreps ; i++)		temp[i]=0;	for (i=0 ; i<bins ; i++) {		for (j=0 ; j<bootreps ; j++)		/* copy bin's reps to array */			temp[j]=matrix[i][j]; 		temp=ulshellsort_dec(temp, bootreps);	/* sort array */		interval[i][0] = temp[lo];			/* select 95% low */		interval[i][1] = temp[hi];			/* select 95% high */	}	free_ulvector(temp);	return interval;}/* return an array of 95% confidence intervals based on matrix sent, high and low /* a conservative estimate at small sample sizes/* written M. Kosnik 1999.09.15/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */float **f_matrixconfidence(float **data, int bins, int bootreps, float confidence){	int i, j;	float **interval;	float *temp;	int hi=0, lo=0;		/* calculate which array cell to select */	/* -1 and -2 are because arrays run from 0 instead of 1 */	lo = trunc((bootreps-(bootreps*confidence))/2) - 1;	hi = (bootreps-lo) - 2;	if (lo < 0) {		lo =0;		hi = bootreps -1;	}		interval = fmatrix(bins, 2);		/* memory space for ci's */	for (i=0 ; i<bins ; i++)		for (j=0 ; j<2 ; j++)			interval[i][j]=0.f;	temp = fvector(bootreps);				/* memory space for temp matrix */	for (i=0 ; i<bootreps ; i++)		temp[i]=0.f;	for (i=0 ; i<bins ; i++) {		for (j=0 ; j<bootreps ; j++)		/* copy bin's reps to array */			temp[j]=data[i][j];		temp=fshellsort_inc(temp, bootreps);	/* sort array */		interval[i][0] = temp[lo];			/* select 95% low */		interval[i][1] = temp[hi];			/* select 95% high */	}	free_fvector(temp);	return interval;}/* returns a matrix replacing non 0 values with 1 in sent matrix/* needs a datamatrix to convert, and the dimensions of the matrix/* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long **ul_convert_data_to_pa(unsigned long **data, int taxa, int lists){	int i=0,j=0;	unsigned long **matrix;	matrix=ulmatrix(lists, taxa);	for (i=0 ; i<lists ; i++)		for (j=0 ; j<taxa ; j++) {			if (data[i][j] != 0) matrix[i][j] = 1;			else matrix[i][j] = 0;		}	return matrix;}/*	converts a species matrix to a "group" matrix/*	needs:/*		data: data matrix/*		listngrps: list of which species go into which groups/*		number of groups, taxa, and lists/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long **species_to_group(unsigned long **data, unsigned long *listngrps, int ngrps, int ntaxa, int nlists){int i, j;						/* loop variables */unsigned long **gmatrix;		/* list by group matrix w/ abundances*/int *gnumbers;					/* lists group identifiers */int ng=1;						/* current group array slot */gmatrix=ulmatrix(nlists, ngrps);for (i=0 ; i<nlists ; i++)	for (j=0 ; j<ngrps ; j++)		gmatrix[i][j]=0;gnumbers=ivector(ngrps);for (i=0 ; i<ngrps ; i++)	gnumbers[i]=0;gnumbers[0]=listngrps[0];				/* remove replicate numbers */for (i=0 ; i<ntaxa ; i++) {	for (j=0 ; j<ng ; j++) 		if (listngrps[i] == gnumbers[j]) {			listngrps[i]=j;			j=INT_MAX;			break;		}	if (j != INT_MAX) {		gnumbers[ng]=listngrps[i];		listngrps[i]=ng;		ng++;		}	}listngrps[0]=0;			for (j=0 ; j<ntaxa ; j++) {	for (i=0 ; i<nlists ; i++)		gmatrix[i][listngrps[j]] += data[i][j];	}free_ivector(gnumbers);return gmatrix;}/*	take a species matrix and a species group array/*	spit out the diversity of each group in each list/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long *group_m_from_species_m(unsigned long **data, unsigned long *listngrps, int ngrps, int nlists, int ntaxa){unsigned long *array;int i, j;array = ulvector(nlists*ngrps);for (i=0 ; i<nlists*ngrps ; i++)	array[i]=0;for (i=0 ; i<nlists ; i++)	for (j=0 ; j<ntaxa ; j++) {		if (data[i][j] > 0)			array[i*ngrps+listngrps[j]]++;		}return array;}/* converts a linear matrix of occurances and other information into a list by taxon matrix/* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long **makerectmatrix(unsigned long **listmatrix, int length, int taxa, int lists, int listc, int taxac, int abunc){int i=0, j=0;					/*loop variables*/int taxon=0;					/*taxon column*/int list=0;						/*list row*/int tn=0, ln=0;					/*current number of lists and taxa*/int *taxa_num;					/*list of taxon numbers*/int *list_num;					/*list of list numbers*/unsigned long **rectmatrix;		/*list by taxon matrix*/taxa_num=ivector(taxa);for (i=0 ; i<taxa ; i++) taxa_num[i] = 0;list_num=ivector(lists);for (i=0 ; i<lists ; i++) list_num[i] = 0;rectmatrix=ulmatrix(lists, taxa);for (i=0 ; i<lists ; i++)	for (j=0 ; j<taxa ; j++) rectmatrix[i][j] = 0;taxa_num[0]=listmatrix[0][taxac];list_num[0]=listmatrix[0][listc];for (i=0 ; i<length ; i++) {	for (j=0 ; j<=tn ; j++)	{		if (listmatrix[i][taxac] == taxa_num[j]) {			taxon = j;			j=INT_MAX;			break;			}		}	if (j != INT_MAX) {		tn++;		taxa_num[tn]=listmatrix[i][taxac];		taxon=tn;		}	for (j=0 ; j<=ln ; j++)	{		if (listmatrix[i][listc] == list_num[j]) {			list = j;			j=INT_MAX;			break;			}		}	if (j != INT_MAX) {		ln++;		list_num[ln]=listmatrix[i][listc];		list=ln;		}	rectmatrix[list][taxon]=listmatrix[i][abunc];	} free_ivector(taxa_num);free_ivector(list_num);return rectmatrix;}