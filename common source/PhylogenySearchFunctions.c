#define PhylogenySearchFunctions#include "PhylogenySearchFunctions.h"/*CALCULATES PARSIMONY LENGTHRETURN TREE AND LENGTH*************************************************************/void Parsimony(int **matrix, int *ctype, int SOTU)	{int 	a, b, c, d, e, f, g, h, i, j, k, n, p, q, s, t, u, ch, debug, SP, gap, deltas, sd;int		**branches, *branchbuffer, **syn, *synbuffer, **chdis, *chdisbuffer, **rdis, *rdisbuffer;	/* FIND PARSIMONY LENGTH *//* chdis gives # of differences with '?' considered different *//* rdis gives # of differences ignoring '?' */for (a=0; a<SOTU-1; ++a)	{	rdis[a][a]=chdis[a][a]=0;	for (b=a+1; b<SOTU; ++b)	{		rdis[a][b]=rdis[b][a]=chdis[a][b]=chdis[b][a]=0;		for (c=0; c<nchars; ++c)	{			if (matrix[a][c]==UNKNOWN || matrix[b][c]==UNKNOWN)				chdis[a][b]=chdis[b][a]=chdis[b][a]+1;			else if (matrix[a][c]!=matrix[b][c] && (matrix[a][c]!=GAP && matrix[b][c]!=GAP))	{				if (ctype[c]==1)	{					chdis[a][b]=chdis[b][a]=chdis[b][a]+1;					rdis[a][b]=rdis[b][a]=rdis[b][a]+1;					}				else	{					chdis[a][b]=chdis[b][a]=chdis[a][b]+abs(matrix[a][c]-matrix[b][c]);					rdis[a][b]=rdis[b][a]=rdis[b][a]+abs(matrix[a][c]-matrix[b][c]);					}				}			}		}	}/* establish the initial order */order[0]=0;order[1]=1;for (a=2; a<SOTU; ++a)	{	b=a-1;	while ((chdis[0][a]<chdis[0][order[b]] || (chdis[0][a]==chdis[0][order[b]] && rdis[0][a]<rdis[0][order[b]])))	{		order[b+1]=order[b];		--b;		}	order[b+1]=a;	}for (n=0; n<5*SOTU; ++n)	{	/* determine order for search */	if (n>0)	{		b=e=0;		for (a=1; a<SOTU; ++a)	{			if (apo[a]>e)	{				e=apo[a];				b=1;				}			else if (apo[a]==e)	++b;			}		c=0;		for (a=1; a<SOTU-c; ++a)	{			f=order[a];			if (apo[f]==e)	{				for (d=a; d<SOTU-c-1; ++d)					order[d]=order[d+1]; 				++c;				order[SOTU-c]=f;				--a;				}			}		}		for (a=0; a<2*SOTU; ++a)		for (b=0; b<2*SOTU; ++b)	syn[a][b]=syn[b][a]=0;	/* clear species and nodal conditions for tree-dependent variables */	for (a=0; a<2*SOTU; ++a)	{		apo[a]=0;	 	if (a!=SOTU)	for (c=0; c<nchars; ++c)	changes[a][c]=-1;		else			for (c=0; c<nchars; ++c)	changes[a][c]=0;		}		for (a=0; a<SOTU; ++a)	{		divers[a]=0;		for (b=0; b<POLY; ++b)	desc[a][b]=-1;		}		for (a=SOTU; a<2*SOTU; ++a)	{		for (b=0; b<2*SOTU; ++b)	{			syn[a][b]=syn[b][a]=0;			rdis[a][b]=rdis[b][a]=0;			chdis[a][b]=chdis[b][a]=0;			}		}			clade=0;	desc[0][0]=0;	desc[0][1]=order[1];	divers[0]=2;	for (a=0; a<2*SOTU; ++a)	{		node[a]=0;		anc[a]=SOTU;		}//	node[0]=0;//	node[order[1]]=0;	/* set up base of tree */	a=order[1];	for (c=0; c<nchars; ++c)	{		if (matrix[0][c]==matrix[a][c])	matrix[SOTU][c]=matrix[0][c];		else if (matrix[0][c]==UNKNOWN)	{			if (matrix[a][c]!=GAP)	matrix[SOTU][c]=matrix[a][c];			else					matrix[SOTU][c]=UNKNOWN;			}		else if (matrix[a][c]==UNKNOWN)	{			if (matrix[0][c]!=GAP)	matrix[SOTU][c]=matrix[0][c];			else					matrix[SOTU][c]=UNKNOWN;			}		else						matrix[SOTU][c]=matrix[0][c];				/* find changes so that synapomorphies with taxa can be found */		if ((matrix[SOTU][c]!=GAP && matrix[SOTU][c]!=UNKNOWN) && (matrix[a][c]!=GAP && matrix[a][c]!=UNKNOWN))	{			if (matrix[SOTU][c]!=matrix[a][c])					changes[a][c]=matrix[a][c];			}		if ((matrix[SOTU][c]!=GAP && matrix[SOTU][c]!=UNKNOWN) && (matrix[0][c]!=GAP && matrix[0][c]!=UNKNOWN))	{			if (matrix[SOTU][c]!=matrix[0][c])					changes[0][c]=matrix[0][c];			}		/* tally synapomorphies bn. taxa - only bother if the character differs from the nodal value */		if (changes[0][c]!=-1)	{			for (d=0; d<SOTU; ++d)	{				if (changes[0][c]==matrix[d][c])	syn[0][d]=syn[d][0]=syn[d][0]+1;				else if (ctype[c]==0)	{					i=matrix[0][c]-matrix[SOTU][c];					j=matrix[d][c]-matrix[SOTU][c];					if ((i<0 && j<0) || (i>0 && j>0))	{						if (i<j)	syn[0][d]=syn[d][0]=syn[d][0]+i;						else		syn[0][d]=syn[d][0]=syn[d][0]+j;						}					}				}			}		if (changes[a][c]!=-1)	{			for (d=0; d<SOTU; ++d)	{				if (changes[a][c]==matrix[d][c])	syn[a][d]=syn[d][a]=syn[d][a]+1;				else if (ctype[c]==0)	{					i=matrix[a][c]-matrix[SOTU][c];					j=matrix[d][c]-matrix[SOTU][c];					if ((i<0 && j<0) || (i>0 && j>0))	{						if (i<j)	syn[a][d]=syn[d][a]=syn[d][a]+i;						else		syn[a][d]=syn[d][a]=syn[d][a]+j;						}					}				}			}		}	/* base of tree is set; now find distances among taxa */	for (a=0; a<SOTU; ++a)	{		chdis[a][SOTU]=chdis[SOTU][a]=0;		for (c=0; c<nchars; ++c)	{			if (matrix[a][c]==UNKNOWN || matrix[SOTU][c]==UNKNOWN)					chdis[SOTU][a]=++chdis[a][SOTU];			else if (matrix[a][c]!=matrix[SOTU][c] && (matrix[a][c]!=GAP && matrix[SOTU][c]!=GAP))	{				if (ctype[c]==1)	{ 					chdis[a][SOTU]=++chdis[SOTU][a];					rdis[a][SOTU]=++rdis[SOTU][a];					}				else	{					chdis[a][SOTU]=chdis[SOTU][a]=chdis[SOTU][a]+abs(matrix[a][c]-matrix[SOTU][c]);					rdis[a][SOTU]=rdis[SOTU][a]=rdis[SOTU][a]+abs(matrix[a][c]-matrix[SOTU][c]);					}				}			}		}	apo[desc[0][0]]=rdis[SOTU][desc[0][0]];	apo[desc[0][1]]=rdis[SOTU][desc[0][1]];	/* now link OTUs to OTU / HTU with which it shares the most synapomorphies */	for (k=2; k<SOTU; ++k)	{		/* find closest species */		a=order[k];		apo[a]=0;		kin=chdis[a][sis=desc[cl=0][cls=0]];		for (b=0; b<=clade; ++b)	{			for (c=0; c<divers[b]; ++c)	{				d=desc[b][c];				if (d==sis)	{					++c;					d=desc[b][c];					}				if (c==divers[b])	break;				/* if new species is more similar, then it is the new contestant */				if (chdis[a][d]<kin)	{					kin=chdis[a][d];					sis=d;					cl=b;					cls=c;					}				/* if tied, link it to the more primitive species */				else if (chdis[a][d]==kin)	{					if (d<SOTU && d>=SOTU)	{						kin=chdis[a][d];						sis=d;						cl=b;						cls=c;						}					/* take the one with the fewest differences if tied */					else if (rdis[a][d]<rdis[sis][a])	{						kin=chdis[a][d];						sis=d;						cl=b;						cls=c;						}					else if (rdis[a][d]==rdis[sis][a])	{						if (syn[d][a]>syn[sis][a])	{							kin=chdis[a][d];							sis=d;							cl=b;							cls=c;							}						else if (apo[d]<apo[sis])	{							kin=chdis[a][d];							sis=d;							cl=b;							cls=c;							}					/* if equally similar, then flip a coin */						else if (apo[d]==apo[sis])	{							e=(((unsigned int) rand())%100);							if (e>50)	{								sis=d;								cl=b;								cls=c;								kin=chdis[a][d];								}							}						}					}				}			}		/* "sister" species identical to previous node - make a polytomy */				if (apo[sis]==0 && divers[cl]<POLY)	{			cls=kin=0;			/* first, find potential synapomorphies with other species in node */			for (c=0; c<nchars; ++c)	{				if ((matrix[sis][c]!=UNKNOWN && matrix[a][c]!=UNKNOWN) && (matrix[sis][c]!=GAP && matrix[a][c]!=GAP))	{					if (matrix[sis][c]!=matrix[a][c])	{						changes[a][c]=matrix[a][c];						for (b=0; b<divers[cl]; ++b)	{							d=desc[cl][b];							if (matrix[d][c]==matrix[a][c])	syn[a][d]=++syn[d][a];							else if (ctype[c]==0)	{								i=matrix[a][c]-matrix[sis][c];								j=matrix[d][c]-matrix[sis][c];								if ((i<0 && j<0) || (i>0 && j>0))	{									if (abs(i)<abs(j))										syn[a][d]=syn[d][a]=syn[d][a]+abs(i);									else										syn[a][d]=syn[d][a]=syn[d][a]+abs(i);									}								}							}	/* examine other members of clade only */						}					}					}			for (b=0; b<divers[cl]; ++b)	{				d=desc[cl][b];				if (syn[a][d]>kin)	{					kin=syn[a][d];					sis=d;					cls=b;					newcl=1;					}				else if (syn[a][d]>0 && syn[a][d]==kin)	{					if (chdis[a][d]<chdis[a][sis])	{						kin=syn[a][d];						sis=d;						cls=b;						}					else if (chdis[a][d]==chdis[a][sis])	{						if (rdis[a][d]<rdis[a][sis])	{							 kin=syn[a][d];							 sis=d;							cls=b;							 }						else if (rdis[a][d]==rdis[a][sis])	{							e=(((unsigned int) rand())%100);							if (e>50)	{								sis=d;								kin=syn[a][d];								cls=b;								}							}						}					}				}			/* re-calculate nodal conditions */			if (apo[sis]==0)	{				for (c=0; c<nchars; ++c)	{					if (matrix[cl+SOTU][c]==UNKNOWN && (matrix[a][c]!=UNKNOWN && matrix[a][c]!=GAP))	{						d=0;						f=-1;						for (e=0; e<divers[cl]; ++e)	{							if (matrix[desc[cl][e]][c]==GAP || matrix[desc[cl][e]][c]==UNKNOWN)								++d;							else if (matrix[desc[cl][e]][c]==matrix[a][c])								e=d=divers[cl];							}						/* make change if:						   a. other species have unknown conditions.						   b. new species shares state with another species in node */						if (e==divers[cl])	{							matrix[cl+SOTU][c]=matrix[a][c];							if (cl>0)	{								d=node[cl+SOTU];								if (matrix[d+SOTU][c]!=matrix[cl+SOTU][c] && (matrix[d+SOTU][c]!=UNKNOWN && matrix[d+SOTU][c]!=GAP))									changes[cl+SOTU][c]=matrix[cl+SOTU][c];								}							/* adjust distances and synapomorphies */							for (d=0; d<SOTU+clade; ++d)	{								if ((matrix[d][c]!=GAP && matrix[d][c]!=UNKNOWN) && matrix[d][c]==matrix[cl+SOTU][c])	{									chdis[cl+SOTU][d]=chdis[d][cl+SOTU]=chdis[d][cl+SOTU]+1;									/* modify synapomorphies */									if (cl>0)	{										if (changes[cl+SOTU][c]==matrix[d][c])	syn[cl+SOTU][d]=syn[d][cl+SOTU]=syn[d][cl+SOTU]+1;										else if (changes[cl+SOTU][c]!=-1 && ctype[c]==0)	{											i=matrix[d][c]-matrix[node[cl]+SOTU][c];											j=matrix[cl+SOTU][c]-matrix[node[cl]+SOTU][c];											if ((i>0 && j>0) || (i<0 && j<0))	{												if (abs(i) < abs(j))													syn[cl+SOTU][d]=syn[d][cl+SOTU]=syn[d][cl+SOTU]+abs(i);												else													syn[cl+SOTU][d]=syn[d][cl+SOTU]=syn[d][cl+SOTU]+abs(j);												}	/* end adjustment for ordered chars */											}										}		/* end modification of synapomorphies */									}		/* compare only coded characters */								}		/* compare all other taxa */							}	/* routine when nodal unknown now can be coded */						}					}	/* end check to see if new species changes unknown */				newcl=0;				b=divers[cl]-1;				while (desc[cl][b]>a && b>=0)	{					desc[cl][b+1]=desc[cl][b];					--b;					}				desc[cl][b+1]=a;				++divers[cl];				apo[a]=rdis[cl+SOTU][a];				f=SOTU+cl;				node[a]=cl;				}	/* only do this if you failed to find a sister species */			}		if (apo[sis]>0 || divers[cl]>POLY)	{		/* make new clade */			newcl=1;			++clade;			if (sis<a)	{				desc[clade][0]=sis;				desc[clade][1]=a;				}			else	{				desc[clade][0]=a;				desc[clade][1]=sis;				}			divers[clade]=2;			apo[clade+SOTU]=0;			f=SOTU+clade;			node[a]=node[sis]=clade;			}		/* if it is a new clade, calculate ancestral conditions and then find patristic dis */		/* f here is the new node	*/		if (newcl==1)	{			/* modify base of tree, sorting taxa as you do */			for (c=cls; c<divers[cl]; ++c)	desc[cl][c]=desc[cl][c+1];			desc[cl][divers[cl]-1]=f;			node[f]=cl;			/* now calculate characters for node */			for (g=0; g<SOTU+clade-1; ++g)				chdis[g][f]=chdis[f][g]=0;			d=desc[clade][0];	/* d: sister taxon 1	  */			e=desc[clade][1];	/* e: sister taxon 2	  */			anc[e]=anc[d]=f;	/* f: ancestor 			  */			g=anc[f]=cl+SOTU;		/* anc[f]: grand-ancestor */					for (c=0; c<nchars; ++c)	{				if (matrix[d][c]==matrix[e][c])					matrix[f][c]=matrix[d][c];				/* do something here to handle gaps & chimaeras */				/* d unknown but e known */				else if ((matrix[d][c]==GAP || matrix[d][c]==UNKNOWN) && (matrix[e][c]!=GAP || matrix[e][c]!=UNKNOWN))					matrix[f][c]=matrix[e][c];				/* if d unknown but e gap, make it unknown */				else if (matrix[d][c]==UNKNOWN && matrix[e][c]==GAP)					matrix[f][c]=matrix[d][c];				/* e unknown but d known */				else if ((matrix[e][c]==GAP || matrix[e][c]==UNKNOWN) && (matrix[d][c]!=GAP || matrix[d][c]!=UNKNOWN))					matrix[f][c]=matrix[d][c];				/* if e unknown but d gap, make it unknown */				else if (matrix[e][c]==UNKNOWN && matrix[d][c]==GAP)					matrix[f][c]=matrix[e][c];				/* mismatch of coded characters */				else	{					/* if ancestral state matches daughter taxon, use that */					if (matrix[g][c]!=UNKNOWN && matrix[g][c]!=GAP)	{						if (matrix[d][c]==matrix[g][c]) 		matrix[f][c]=matrix[g][c];						else if (matrix[e][c]==matrix[g][c])	matrix[f][c]=matrix[g][c];						/* outgroup condition doesn't match anything */						else	{							/* if ordered, use the average of 2 sisters and grandparent */							if (ctype[c]==0)	{								matrix[f][c]=0;								matrix[f][c]=matrix[d][c]+matrix[e][c]+matrix[g][c];								matrix[f][c]=matrix[f][c]/3;								}							else	{								/* 1st: use overall most primitive taxon */								if (chdis[d][g]<chdis[e][g])		matrix[f][c]=matrix[d][c];								else if (chdis[e][g]<chdis[d][g])	matrix[f][c]=matrix[e][c];								else	{									/* 2nd: use overall most primitive taxon */									if (FA[d]<FA[e])			matrix[f][c]=matrix[d][c];									else if (FA[e]<FA[d])		matrix[f][c]=matrix[e][c];									else	{										/* 3rd: toss a coin */										h=(((unsigned int) rand())%100);										if (h<50)	matrix[f][c]=matrix[d][c];										else		matrix[f][c]=matrix[e][c];										}									}								}							}						}					else if (matrix[g][c]==UNKNOWN)						matrix[f][c]=UNKNOWN;					else if (matrix[g][c]==GAP)						matrix[f][c]=GAP;					}				for (h=0; h<SOTU+clade; ++h)	{					if (matrix[f][c]==GAP)	break;					/* add to chdis no matter what; add to rdis only if not UNKNOWN */ 					if (matrix[f][c]!=matrix[h][c])	{						if (ctype[c]==1)	{							chdis[h][f]=++chdis[f][h];							if (matrix[f][c]!=UNKNOWN && matrix[h][c]!=UNKNOWN)	rdis[h][f]=++rdis[f][h];							}						else	{							if (matrix[f][c]==UNKNOWN || matrix[h][c]==UNKNOWN)	chdis[h][f]=++chdis[f][h];							else	{								chdis[h][f]=chdis[f][h]=chdis[f][h]+abs(matrix[f][c]-matrix[h][c]);								rdis[h][f]=rdis[f][h]=rdis[f][h]+abs(matrix[f][c]-matrix[h][c]);								}							}						}					}				}			apo[f]=rdis[g][f];			apo[e]=rdis[f][e];			apo[d]=rdis[f][d];						/* find synapomorphies shared with each taxon */			/* list character changes, with condition giving new state & -1 giving no change */			/* make sure that synapomorphies are recalculated for graduated species */			for (c=0; c<nchars; ++c)	{				if (matrix[d][c]!=matrix[f][c])					if ((matrix[d][c]!=UNKNOWN && matrix[d][c]!=GAP) && (matrix[f][c]!=UNKNOWN && matrix[f][c]!=GAP))						changes[d][c]=matrix[d][c];				if (matrix[e][c]!=matrix[f][c])					if ((matrix[e][c]!=UNKNOWN && matrix[e][c]!=GAP) && (matrix[f][c]!=UNKNOWN && matrix[f][c]!=GAP))						changes[e][c]=matrix[e][c];				if (matrix[g][c]!=matrix[f][c])	{					if ((matrix[g][c]!=UNKNOWN && matrix[g][c]!=GAP) && (matrix[f][c]!=UNKNOWN && matrix[f][c]!=GAP))	{						changes[f][c]=matrix[f][c];						/* change apomorphies of sister species to synapomorphies of clade */						if (changes[f][c]==changes[sis][c])	{							changes[sis][c]=-1;							for (h=0; h<SOTU+clade; ++h)	{								/* deduct synapomorphies from graduated species */								if (matrix[h][c]==matrix[sis][c] && (matrix[h][c]!=UNKNOWN && matrix[h][c]!=GAP))									syn[sis][h]=syn[h][sis]=syn[h][sis]-1;								else if (ctype[c]==0)	{									if ((matrix[h][c]!=UNKNOWN && matrix[h][c]!=GAP) && (matrix[sis][c]!=UNKNOWN && matrix[sis][c]!=GAP))	{										/* compare graduate to *old* node; deduct synapmorphies */										i=matrix[sis][c]-matrix[g][c];										j=matrix[h][c]-matrix[g][c];										if ((i<0 && j<0) || (i>0 && j>0))	{											if (abs(i)<abs(j))												syn[sis][h]=syn[h][sis]=syn[h][sis]-abs(i);											else												syn[sis][h]=syn[h][sis]=syn[h][sis]-abs(j);											}										}									}								}							}						}					}				}	/* end recalculation of distances among taxa */						for (h=0; h<SOTU+clade; ++h)	{				for (c=0; c<nchars; ++c)	{					if (changes[d][c]==matrix[h][c] && changes[d][c]>-1)						syn[d][h]=syn[h][d]=syn[h][d]+1;					/* if ordered, then mismatches might still have synapomorphies */					else if (ctype[c]==0 && changes[d][c]>-1)	{						i=matrix[d][c]-matrix[f][c];						j=matrix[h][c]-matrix[f][c];						if ((i<0 && j<0) || (i>0 && j>0))	{							if (abs(i) < abs(j))	syn[d][h]=syn[h][d]=syn[h][d]+abs(i);							else					syn[d][h]=syn[h][d]=syn[h][d]+abs(j);							}						}					if (changes[e][c]==matrix[h][c] && changes[e][c]>-1)						syn[e][h]=syn[h][e]=syn[h][e]+1;					/* if ordered, then mismatches might still have synapomorphies */					else if (ctype[c]==0 && changes[e][c]>-1)	{						i=matrix[e][c]-matrix[f][c];						j=matrix[h][c]-matrix[f][c];						if ((i<0 && j<0) || (i>0 && j>0))	{							if (abs(i) < abs(j))	syn[e][h]=syn[h][e]=syn[h][e]+abs(i);							else					syn[e][h]=syn[h][e]=syn[h][e]+abs(j);							}						}					if (changes[f][c]==matrix[h][c] && changes[f][c]>-1)						syn[f][h]=syn[h][f]=syn[h][f]+1;					/* if ordered, then mismatches might still have synapomorphies */					else if (ctype[c]==0 && changes[f][c]>-1)	{						i=matrix[f][c]-matrix[f][c];						j=matrix[h][c]-matrix[f][c];						if ((i<0 && j<0) || (i>0 && j>0))	{							if (abs(i) < abs(j))	syn[f][h]=syn[h][f]=syn[h][f]+abs(i);							else					syn[f][h]=syn[h][f]=syn[h][f]+abs(j);							}						}					}				}			/* if graduated sis is an OTU but it has no apomorphies, then collapse that node into a polytomy */			if (sis>=SOTU && apo[sis]==0)	{				/* find sis's spot in new clade */				h=0;				/* eliminate sis  */				while (desc[f-SOTU][h]<sis)	{					++h;					}				/* decrease diversity before adding in new species */				desc[f-SOTU][h]=-1;				--divers[f-SOTU];				/* replace sis with any higher numbers */				for (b=h; b<divers[f-SOTU]; ++b)	desc[f-SOTU][b]=desc[f-SOTU][b+1];				/* now add taxa from sis to node f-SOTU */				for (b=0; b<divers[sis-SOTU]; ++b)	{					h=divers[f-SOTU]-1;					while (desc[f-SOTU][h]>desc[sis-SOTU][b])	{						desc[f-SOTU][h+1]=desc[f-SOTU][h];						--h;						}					desc[f-SOTU][h+1]=desc[sis-SOTU][b];					++divers[f-SOTU];					}								/* now put everything back into node sis-SOTU */				/* no need to adjust matrix because matrix[sis]==matrix[f] */				for (b=0; b<divers[f-SOTU]; ++b)					desc[sis-SOTU][b]=desc[f-SOTU][b];				divers[sis-SOTU]=divers[g-SOTU];								/* eliminate new clade from records */				for (b=0; b<POLY; ++b)	desc[f-SOTU][b]=-1;				divers[f-SOTU]=0;				--clade;								/* now, check to see if species have synapomorphies that break up polytomy */				p=q=SOTU*4;				for (b=0; b<divers[f-SOTU]-1; ++b)	{					s=desc[f-SOTU][b];					u=ch=0;					for (h=b+1; h<divers[f-SOTU]; ++h)	{						t=desc[f-SOTU][h];						for (c=0; c<nchars; ++c)	{							if (ctype[c]!=0)	if (changes[s][c]==changes[t][c])	++ch;							else	{								i=matrix[s][c]-matrix[f][c];								j=matrix[t][c]-matrix[f][c];								if ((i<0 && j<0) || (i>0 && j>0))	{									if (abs(i)<abs(j))	ch=ch+abs(i);									else				ch=ch+abs(j);									}								}							}						}					if (ch>u)	{						p=s;	/* new sister taxa */						q=t;						u=ch;	/* synapomorphies linking them */						}					}									/* if new sister species are found, then re-do all of this with those taxa */				if (ch>0)	{					++clade;					desc[clade][0]=p;					desc[clade][1]=q;					node[p]=node[q]=clade;					/* take new sister species out of node f-SOTU */					for (b=0; b<2; ++b)	{						for (h=0; h<divers[f-SOTU]; ++h)	{							if (desc[f-SOTU][h]==desc[clade][b])	{								for (u=h; u<divers[f-SOTU]; ++u)	desc[f-SOTU][u]=desc[f-SOTU][u+1];								--divers[f-SOTU];								--h;								}							}						}					desc[f-SOTU][divers[f-SOTU]]=clade;					++divers[f-SOTU];										apo[p]=apo[q]=ch;					for (c=0; c<nchars; ++c)	{						if ((ctype[c]!=0 && changes[p][c]==changes[q][c]) && changes[p][c]!=-1)	{							changes[clade][c]=changes[p][c];							changes[p][c]=changes[q][c]=-1;							++apo[clade];						/* START HERE */						else if ((ctype[c]==0 && changes[p][c]==changes[q][c]) && changes[p][c]!=-1)	{														}						}					}				}			}	/* end tabulation for new clade */ 				/* if species is added to polytomy, then apomorphies = difference bn. node and species */		else	{			/* list character changes, with condition giving new state & -1 giving no change */			/* f here is the node into which a has been dumped */			for (c=0; c<nchars; ++c)	{				if (matrix[a][c]!=matrix[f][c])	{					if ((matrix[a][c]!=UNKNOWN && matrix[a][c]!=GAP) && (matrix[f][c]!=UNKNOWN && matrix[f][c]!=GAP))	{						changes[a][c]=matrix[a][c];						}					}				if (changes[a][c]>-1)	{					for (d=0; d<SOTU+clade; ++d)	{						if (matrix[d][c]==changes[a][c])							syn[a][d]=syn[d][a]=syn[d][a]+1;						else if (ctype[c]==0)	{							i=matrix[a][c]-matrix[f][c];							j=matrix[d][c]-matrix[f][c];							if ((i<0 && j<0) || (i>0 && j>0))	{								if (abs(i)<abs(j))	syn[d][a]=syn[a][d]=syn[a][d]+abs(i);								else				syn[d][a]=syn[a][d]=syn[a][d]+abs(j);								}							}						}					}	/* end addition of synapomorphies */ 				}	/* end search of characters */			}	/* end addition to polytomy */		}			/* here would be the place to swap branches */	b=e=0;	for (a=1; a<SOTU; ++a)	{		if (apo[a]>e)	{			e=apo[a];			b=1;			}		else if (apo[a]==e)	++b;		}	deltas=0;	for (a=0; a<=clade; ++a)	{		c=a+SOTU;		for (b=0; b<divers[a]; ++b)	{			d=desc[a][b];			deltas=deltas+apo[d];			}		}			sd = 0;	for (a=clade; a>=0; --a)	{		g=SOTU*10;		FA[a+SOTU]=10000;			/* find age of node */		for (b=0; b<divers[a]; ++b)	{			d=desc[a][b];			if (FA[d]<FA[a+SOTU])	FA[a+SOTU]=FA[d];			if (apo[d]==0 && d<SOTU)	g=d;			}		/* no ancestor present */		if (g>SOTU)	{			for (b=0; b<divers[a]; ++b)	{				d=desc[a][b];				sd=sd+(FA[a+SOTU]-FA[b]);				}			}		else	{			for (b=0; b<divers[a]; ++b)	{				d=desc[a][b];				if (FA[d]<FA[g])					sd=sd+(FA[g]-FA[d]);				else if ((FA[d]-1)>LA[g])					sd=sd+((FA[d]-1)-LA[g]);				}			}		}			if (n==0 || deltas<PARSIMONY)	{		PARSIMONY=deltas;		for (a=0; a<=clade; ++a)	{			for (b=0; b<POLY; ++b)				tree[a][b]=desc[a][b];			trdiv[a]=divers[a];			SD=sd;			}		}	else if (deltas==PARSIMONY && sd<SD)	{		for (a=0; a<=clade; ++a)	{			for (b=0; b<POLY; ++b)				tree[a][b]=desc[a][b];			trdiv[a]=divers[a];			SD=sd;			}		}			}	/* complete another search */}