/** stratcompatfullplusplusplus - determines whether a compatible character pair are compatible with stratigraphy or not.  /* switched from unsigned long to double on 2011-10-19: that way, "half" can be credited for ties	*//* Requires:/*	ranges - a matrix of first and last appearances where:/*		ranges[x][0]=first appearance;/*		ranges[x][1]=last appearanc;/*	matrix - cladistic character matrix;/*	states - number of states for ach character;/*	charcomps - compatibility of each character;/*	ch1 - 1st character being compared;/*	ch2 - 2nd character being compared;/*	notu - number of taxa;/*  tiebreak - 0 means ignore ties, 1 means use earliest richness as a tie-breaker/*	UNKNOWN - coding for an unknown character;/*	INAP - coding for an inapplicable character;/*/* Returns:/*	stratcomp - an array telling you whether the character shows gaps in its  stratigraphic range or not.		stratcomp[0]: character 1		stratcomp[1]: character 2		stratcomp[2]: character 1 states		stratcomp[3]: character 2 states		stratcomp[4]: state comparisons (2 for binary; possibly more for multistate)		stratcomp[5]: general stratigraphic compatibility!		stratcomp[6]: strict stratigraphic compatibility		stratcomp[7]: super strict stratigraphic compatibility		stratcomp[8]: divergent (0) vs. hierarchical (1) stratigraphic compatibility		stratcomp[9]: hierarchical stratigraphic compatibility consistent with anagenesis		stratcomp[10]: hierarchical stratigraphic compatibility consistent with budding		stratcomp[11]: compatibility suggests 10<-01->11 rather than 10->01->11		stratcomp[12]: compatibility suggests 10->01->11 rather than 10<-01->11		stratcomp[13]: stratigraphy suggests 10<-01->11 rather than 10->01->11		stratcomp[14]: stratigraphy suggests 10->01->11 rather than 10<-01->11		stratcomp[15]: relative diversity of younger swing pair in SIN cases		stratcomp[16]: center of gravity for oldest state pair		stratcomp[17]: center of gravity for intermediate state pair		stratcomp[18]: when hierarchical ancestral pair goes extinct;		stratcomp[19]: when divergent ancestral pair goes extinct;		stratcomp[20]: purely hierarchical comparisons		stratcomp[21]: purely divergent comparisons****************************************************************************************************************************/stratcompatfullplusdisparity(long **ranges, long **matrix, int *states, unsigned long *charcomps, int ch1, int ch2, int notu, int onset, int term, int tiebreaker, int UNKNOWN, int INAP);{int	a, b, c, d, f, p, t;int	maxocc, st1, st2, ttlprs=0, maxst;//int	cc, sp, maxocc, st1, st2, sc1, sc2, rc, scf1, scf2, scu1, scu2, prs, m1, m2, ttlprs=0, maxst;//int cl[20], cr[20];int	swing, end1, end2, cpe1, cpe2;						/* these are the "swing" states between characters + important info, with "swing" giving pair #	*//*int	kp1, kp2;										/* key pairs			*//*int	prdv1, prdv2;									/* key pair diversities	*/int cp1, cp2, cp3;int epd1, epd2;											/* diversity of end pairs for incompatible pairs	*/unsigned long **combos;/*long **pairfnd;*/long **pairs, **allpairs, **pairrng, **pairfnd;long gap[3];long prfl[3][2];double *stratcomp;double cgan, cgcl;										/* 2013-04-12: center of gravity	*/int ancp, desc1, desc2;									/* 2013-04-12: ancestral pair		*/int hier, divr;int trioonset, trioterm;long *S;//long pairs[3][2];/* 2011-10-19: NEW APPROACH!  	1. Put all pairs into a pair x 2 matrix	2. Put in a 3-tiered for loop to find all combinations of 3 pairs;	3. If there is a swing-pair, then analyze this pair.****************************************************/maxocc=maxlmatrixcol(ranges, notu, 1);maxst=imax(states[ch1],states[ch2]);pairrng=statepairranges(ranges, matrix, states, ch1, ch2, notu, UNKNOWN, INAP);	/* get ranges for state pairs	*/combos=ulmatrix(2,1+(a=imax(states[ch1],states[ch2])));/* added again on 2013-04-12: find beginning and end of clade	*///onset=minlmatrixcol(ranges,notu,0);//end=maxlmatrixcol(ranges,notu,0);for (st1=0; st1<states[ch1]; ++st1)	{	for (st2=0; st2<states[ch2]; ++st2)	{		a=st1*states[ch2]+st2;		/* find the number of combinations in which each states of both characters appears	*/		if (pairrng[a][0]<=maxocc && pairrng[a][0]>=0)	{			++combos[0][st1];			++combos[1][st2];			++ttlprs;			/* total pairs observed: if this is less than 3, then we can quit now!	*/			}		}	}free_ulmatrix(combos,2,1+(a=imax(states[ch1],states[ch2])));stratcomp=dvector(22);cleardvector(stratcomp,22,0);stratcomp[0]=ch1;stratcomp[1]=ch2;stratcomp[2]=states[ch1];stratcomp[3]=states[ch2];S=lvector(term+1);if (ttlprs>2)	{	allpairs=lmatrix(ttlprs,2);	p=0;	for (st1=0; st1<states[ch1]; ++st1)	{		for (st2=0; st2<states[ch2]; ++st2)	{			a=st1*states[ch2]+st2;			/* find the number of combinations in which each states of both characters appears	*/			if (pairrng[a][0]<=maxocc && pairrng[a][0]>=0)	{				allpairs[p][0]=st1;				allpairs[p][1]=st2;				++p;			/* total pairs observed: if this is less than 3, then we can quit now!	*/				}			}		}	/* make sure that pairfnd uses (st1*states[ch2])+states[ch2] throughout, and not simply the pair number!	*/	pairfnd=statepairfinds(ranges, matrix, states, ch1, ch2, notu, UNKNOWN, INAP);	/* get pre/abs for state pairs	*/	/* now, go through all combinations of three pairs, and exampine those that have a linking pair	*/	pairs=lmatrix(3,2);	for (a=0; a<(ttlprs-2); ++a)	{		pairs[0][0]=allpairs[a][0];		pairs[0][1]=allpairs[a][1];		/* get first-last appearances of pair a	*/		prfl[0][0]=pairrng[cp1=(pairs[0][0]*states[ch2])+pairs[0][1]][0];		prfl[0][1]=pairrng[cp1][1];		/* determine if this pair has a gap in it	*/		gap[0]=0;		for (d=prfl[0][0]; d<=prfl[0][1]; ++d)	{			if (pairfnd[cp1][d]==0)	{				gap[0]=1;				d=prfl[0][1];				}			}		for (b=a+1; b<(ttlprs-1); ++b)	{			pairs[1][0]=allpairs[b][0];			pairs[1][1]=allpairs[b][1];			/* get first-last appearances of pair b	*/			prfl[1][0]=pairrng[cp2=(pairs[1][0]*states[ch2])+pairs[1][1]][0];			prfl[1][1]=pairrng[cp2][1];			/* determine if this pair has a gap in it	*/			gap[1]=0;			for (d=prfl[1][0]; d<=prfl[1][1]; ++d)	{				if (pairfnd[cp2][d]==0)	{					gap[1]=1;					d=prfl[1][1];					}	/* gap found	*/				}			for (c=b+1; c<ttlprs; ++c)	{				pairs[2][0]=allpairs[c][0];				pairs[2][1]=allpairs[c][1];				/* get first-last appearances of pair c	*/				prfl[2][0]=pairrng[cp3=(pairs[2][0]*states[ch2])+pairs[2][1]][0];				prfl[2][1]=pairrng[cp3][1];				/* determine if this pair has a gap in it	*/				gap[2]=0;				for (d=prfl[2][0]; d<=prfl[2][1]; ++d)	{					if (pairfnd[cp3][d]==0)	{						gap[2]=1;						d=prfl[2][1];						}					}				/* determine whether this set is linked: if so, then swing will be positive	*/				swing=findswingpair(pairs,3,maxst);				if (swing>-1)	{					stratcomp[4]+=1.0f;							/* another comparison made						*/					end1=0;					end2=2;					if (swing==0)						end1=1;					else if (swing==2)						end2=1;										/* make end1 older than end2	*/					if (prfl[end1][0]>prfl[end2][0])	{						d=end1;						end1=end2;						end2=d;						}					/* insert something here so that pairfnd's first number points to ALL pairs, not just the three being considered	*/					cpe1=(pairs[end1][0]*states[ch2])+pairs[end1][1];					cpe2=(pairs[end2][0]*states[ch2])+pairs[end2][1];/*					cpsw=(pairs[swing][0]*states[ch2])+pairs[swing][1];	/* this might not be needed	*/										/* if swing pair appears after both end pairs appear, then this is stratigraphically incompatible	*/					if ((prfl[swing][0]>prfl[end1][0]) && (prfl[swing][0]>prfl[end2][0]))	{						/* WORK HERE 2011-10-20	*/												d=prfl[swing][0];	/* first appearance of swing	*/						/* if second appearing pair is more diverse, then assume that it is ancestral	*/						epd1=pairfnd[cpe1][d-1]+pairfnd[cpe1][d];						epd2=pairfnd[cpe2][d-1]+pairfnd[cpe2][d];						if ((pairfnd[cpe1][d-1]+pairfnd[cpe1][d]) < (pairfnd[cpe2][d-1]+pairfnd[cpe2][d]))							stratcomp[14]+=1.0f;				/* "hierarchical" stratigraphic incompatibility	*/						else if ((pairfnd[cpe1][d-1]+pairfnd[cpe1][d]) == (pairfnd[cpe2][d-1]+pairfnd[cpe2][d]))	{							stratcomp[13]+=0.5f;				/* split between "hierarchical" & "divergent" stratigraphic incompatibility	*/							stratcomp[14]+=0.5f;				/* split between "hierarchical" & "divergent" stratigraphic incompatibility	*/							}						else							stratcomp[13]+=1.0f;				/* "divergent" stratigraphic incompatibility	*/												/* calculate relative diversity of younger morphotype & add it																*/						/* if neither is present immediately before or after, then they had equal diversity											*/						if ((epd1+epd2)>0)	stratcomp[15]+=((double) (pairfnd[cpe2][d-1]+pairfnd[cpe2][d]))/(((double) (pairfnd[cpe1][d-1]+pairfnd[cpe1][d]))+((double) (pairfnd[cpe2][d-1]+pairfnd[cpe2][d])));						else				stratcomp[15]+=0.5;						/* determine which character was more apt to change, and thus whether end1 or end2 is more apt to be ancestral	*/						/* old routine	*///						m1=m2=RAND_MAX;//						for (d=0; d<prs; ++d)	{//							if (pairs[d][0]==keyst1 && prfl[d][0]<m1)	m1=prfl[d][0];//							if (pairs[d][1]==keyst2 && prfl[d][0]<m2)	m2=prfl[d][0];//							}						/* if the older state is from the less compatible character, then increment	*///						if ((m1<m2 && charcomps[ch2]>charcomps[ch1]) || (m2<m1 && charcomps[ch1]>charcomps[ch2]))	++stratcomp[11];//						else if (m2==m1 || charcomps[ch2]==charcomps[ch1])											++stratcomp[12];						/* new routine	*/						/* use the character with greater compatibility. If character 1, then assume that 00 evolved from 01, not 10	*/ 						/* That means finding whether end1 or end2 matches swing for character 1										*/						if (charcomps[ch1]>charcomps[ch2])	{							/* assume that swing evolved from end2: 10->01->11	*/							if (pairs[end1][0]==pairs[swing][0])								stratcomp[11]+=1.0f;							/* assume that swing evolved from end1: 01<-10->11	*/							else								stratcomp[12]+=1.0f;							}						else if (charcomps[ch1]<charcomps[ch2])	{							/* assume that swing evolved from end1: 01<-10->11	*/							if (pairs[end2][0]==pairs[swing][0])								stratcomp[12]+=1.0f;							/* assume that swing evolved from end2: 10->01->11	*/							else								stratcomp[11]+=1.0f;							}						/* split tie	*/						else	{							stratcomp[11]+=0.5f;							stratcomp[12]+=0.5f;							}												}	/* end case of stratigraphic incompatibility	*/											else	{						stratcomp[5]+=1.0f;							/* general stratigraphic compatibility						*/												/* divergent vs. hierarchical compatibility	*///						if (prfl[swing][0]>prfl[end1][0] && prfl[swing][0]<=prfl[end2][0])	{						hier=divr=0;						if (prfl[swing][0]>prfl[end1][0])		hier=1;						else if (prfl[swing][0]<prfl[end1][0])	divr=1;						else if (tiebreaker==1)	{							/* routine if 2 appear at the same time	*/							if (prfl[end2][0]>prfl[swing][0])	{								desc1=(pairs[end1][0]*states[ch2])+pairs[end1][1];		/* 2013-04-12: get number of state pair for ranges */								desc2=(pairs[swing][0]*states[ch2])+pairs[swing][1];	/* 2013-04-16: get number of state pair for ranges */								if (pairfnd[desc1][prfl[swing][0]] > pairfnd[desc2][prfl[end1][0]])									hier=1;								else if (pairfnd[desc1][prfl[swing][0]] < pairfnd[desc2][prfl[end1][0]])									divr=1;								}	/* end test to see whether one of the two oldest pairs is more diverse than the other	*/							}						/* routine for clearly hierarchical	*///						if (prfl[swing][0]>prfl[end1][0])	{						if (hier==1)	{							/*  e1	sw	e2								¥	¥	¥								¥	¥---¥								¥---¥								¥			*/							stratcomp[8]+=1.0f;						/*  tally hierarchical compatilibility						*/							stratcomp[20]+=1.0f;					/*  2013-04-13: purely hierarchical compatilibility						*/							/* 2013-04-12: AGAIN (and hope it sticks): find center of gravity for original state pair			*/							ancp=(pairs[end1][0]*states[ch2])+pairs[end1][1];		/* 2013-04-12: get number of state pair for ranges */							desc1=(pairs[swing][0]*states[ch2])+pairs[swing][1];	/* 2013-04-16: get number of state pair for ranges */							desc2=(pairs[end2][0]*states[ch2])+pairs[end2][1];		/* 2013-04-16: get number of state pair for ranges */							/* 2013-04-16: get clade shape for just these three state-pairs	*/							trioterm=trioonset=prfl[end1][0];							for (t=0; t<3; ++t)	if (prfl[t][1]>trioterm)	trioterm=imin(prfl[t][1],term);							for (t=onset; t<=term; ++t)	S[t]=pairfnd[ancp][t]+pairfnd[desc1][t]+pairfnd[desc2][t];														cgcl=centerofgravityfromrichness(S,trioonset,trioterm);					/* CoG for whole clade, time standardized	*/							cgan=centerofgravityfromrichness(pairfnd[ancp],trioonset,trioterm);		/* CoG for ancestral paraclade, time standardized	*///							stratcomp[16]=cg[1]/ccg[0];//							stratcomp[16]=cg[1]/ccg[1];							/* in the end, I decided to use the time standardized equation and make it a proportion of the total clade's time-standardized CoG	*/							/* this should account for differences in clade durations as well as multistate trios taking up only part of the clade's history	*///							stratcomp[16]=(((1+trioterm-trioonset) - (cg[1]/ccg[0]))/(1+trioterm-trioonset)) / (((1+trioterm-trioonset) - (ccg[1]/ccg[0]))/(1+trioterm-trioonset));							stratcomp[16]=(1-cgan)/(1-cgcl);							/************ end clade shape part ************/														/* record how long ancestral state pair survives	*/							t=imin(prfl[end1][1],term);							/* end of ancestral pair: but do not let it exceed clade age	*/							stratcomp[18]=((double) (1+(t-trioonset)))/((double) (1+(trioterm-trioonset)));							/* ask whether hierarchical compatibility is consistent with anagenesis or budding					*/							if (prfl[swing][0]>=prfl[end1][1])								stratcomp[9]+=0.5f;					/* consistent with anagenesis								*/							else								stratcomp[10]+=0.5f;				/* consistent with budding									*/							if (prfl[end2][0]>=prfl[swing][1])								stratcomp[9]+=0.5f;					/* consistent with anagenesis								*/							else								stratcomp[10]+=0.5f;				/* consistent with budding									*/							/* end1 should overlap with swing and swing should overlap with end2		*/ 							if (((prfl[end1][1]+1)>=prfl[swing][0]) && ((prfl[swing][1]+1)>=prfl[end2][0]))	{								stratcomp[6]+=1.0f;					/* no gap between morphotypes								*/								/* super-strict requires no gaps at all!														*/								f=sumlvector(gap,3);								if (f==0)		stratcomp[7]+=1.0f;	/* no gaps within or between morphotypes					*/ 								}							}	/* end routine for clearly hierarchical															*/						/* routine for clearly divergent	*///						else if (prfl[swing][0]<prfl[end1][0])	{						else if (divr==1)	{							/*  e1	sw	e2								¥	¥	¥								¥	¥---¥								¥---¥									¥		*/							stratcomp[21]+=1.0f;									/* 2013-04-15: purely divergent compatilibility						*/							/* ask whether hierarchical compatibility is consistent with anagenesis or budding					*/							/* 2013-04-12: AGAIN (and hope it sticks): find center of gravity for original state pair			*/							ancp=(pairs[swing][0]*states[ch2])+pairs[swing][1];	/* 2013-04-16: get number of state pair for ranges */							desc1=(pairs[end1][0]*states[ch2])+pairs[end1][1];		/* 2013-04-12: get number of state pair for ranges */							desc2=(pairs[end2][0]*states[ch2])+pairs[end2][1];		/* 2013-04-16: get number of state pair for ranges */							/* 2013-04-16: get clade shape for just these three state-pairs	*/							trioterm=trioonset=prfl[swing][0];							for (t=0; t<3; ++t)	if (prfl[t][1]>trioterm)	trioterm=imin(prfl[t][1],term);							for (t=onset; t<=term; ++t)	S[t]=pairfnd[ancp][t]+pairfnd[desc1][t]+pairfnd[desc2][t];							cgcl=centerofgravityfromrichness(S,trioonset,trioterm);					/* CoG for whole clade, time standardized	*/							cgan=centerofgravityfromrichness(pairfnd[ancp],trioonset,trioterm);		/* CoG for ancestral paraclade, time standardized	*/							stratcomp[17]=(1-cgan)/(1-cgcl);														/* record how long ancestral state pair survives	*/							t=imin(prfl[swing][1],term);							/* end of ancestral pair: but do not let it exceed clade age	*/							stratcomp[19]=((double) (1+(t-trioonset)))/((double) (1+(trioterm-trioonset)));							/* strict stratigraphic compatibility achieved if swing state overlaps with both derived states	*/							if (((prfl[swing][1]+1)>=prfl[end1][0]) && ((prfl[swing][1]+1)>=prfl[end2][0]))	{								stratcomp[6]+=1.0f;					/* no gap between morphotypes								*/								/* super-strict requires no gaps at all!														*/								f=sumlvector(gap,3);								if (f==0)	stratcomp[7]+=1.0f;				/* no gaps within or between morphotypes					*/ 								}	/* end search for strict stratigraphic compatibiilty	*/							}	/* end check of strict and superstrict stratigraphic compatibility for divergent stratigraphic compatibility	*/						/* if the first two morphotypes appear at the same time, then it as a split	*///						else if (prfl[swing][0]==prfl[end1][0])	{						else if (hier==0 && divr==0)	{							/*  e1	sw	e2								¥	¥	¥								¥	¥---¥								¥   ¥								¥-?-¥	*/							/* if end1 or swing disappears before end2 appears OR if end1 or swing disappears first when both disappear before end1, then assume it is not ancestral	*//*							if ((prfl[end1][1]+1)<prfl[end2][0] && (prfl[swing][1]+1)>=prfl[end2][0])	*/							/* otherwise, assume that this could be either hierarchical or divergent									*/							stratcomp[8]+=0.5f;						/* skip CoG stuff for 							/* now worry about budding and anagenesis.  First, it's 50% that it's divergent, so all values are chopped in half			*/							/*		2nd, the first two pairs can only fit budding as they are contemporaneous											*/							stratcomp[10]+=0.25f;					/* end1 & swing consistent with budding IF the pair is hierarchical		    		*/							/* ask whether possible hierarchical compatibility is consistent with anagenesis or budding									*/							if (prfl[end2][0]>=prfl[swing][1])								stratcomp[9]+=0.25f;				/* consistent with anagenesis: but only half because it might not be hierarchical	*/							else								stratcomp[10]+=0.25f;				/* one pair definitely consistent with budding, other might be		    			*/														/* we know that end1 and swing overlap; the quesiton is whether swing overlaps with end2	*/							if ((prfl[swing][1]+1)>=prfl[end2][0])	{								stratcomp[6]+=1.0f;					/* no gap between morphotypes								*/								/* super-strict requires no gaps at all!														*/								f=sumlvector(gap,3);								if (f==0)		stratcomp[7]+=1.0f;	/* no gaps within or between morphotypes					*/ 								}							}	/* end routine for ambivalent															*/						/* WORK HERE 2011-10-20	*/						}	/* end case of stratigraphic compatibility	*/					}	/* end case of compatible trio of character pairs	*/				}	/* end possible 3rd pairs	*/			}	/* end possible 2nd pairs	*/		}	/* end possible 1st pairs	*/		free_lmatrix(pairs,3,2);	free_lmatrix(allpairs,ttlprs,2);	free_lmatrix(pairfnd,states[ch1]*states[ch2],1+maxocc);	}	/* end cases of 2+ pairs of character states	*/free_lvector(S);free_lmatrix(pairrng,states[ch1]*states[ch2],2);return stratcomp;}