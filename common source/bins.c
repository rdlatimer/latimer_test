/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//*/*	Matthew Kosnik: mkosnik@uchicago.edu/*/*	This file is copyright (C) 2000 Matthew Kosnik/*/*	This program is free software; you can redistribute it and/or modify it /*	under the terms of version 2 the GNU General Public License as published /*	by the Free Software Foundation./*/*	This program is distributed in the hope that it will be useful, but WITHOUT/*	ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or /*	FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for /*	more details./*/*	To view a copy of the license go to:/*	http://www.fsf.org/copyleft/gpl.html/*	To receive a copy of the GNU General Public License write the Free Software/* 	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA./*/*	Copies of this source code are available without cost from:/*	http://geosci.uchicago.edu/paleo/csource//*/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */#define mak_bin_functions#include "bins.h"/* counts the number of things in each bin and places that value in returned array/* counts replicates once/* written M. Kosnik 1999.05.23/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *countperbin1(unsigned long **data, int column, int length, int bins){	int i=0, j=0;	int *array;	array = ivector(bins);	for (i=0 ; i<bins ; i++)		array[i]=0;		for (i=1 ; i<=length ; i++) {		if ((data[i][column] != data[i-1][column])||(data[i][0] != data[i-1][0]))			array[j]+=1;		if (data[i][0] != data[i-1][0])			j++;		}	return array;}/* counts the number of things in each bin and places that value in returned array/* counts replicates twice/* written M. Kosnik 1999.05.23/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *countperbin2(unsigned long **data, int length, int bins){	int i=0, j=0;	int *array;	array = ivector(bins);	for (i=0 ; i<bins ; i++)		array[i]=0;		for (i=1 ; i<=length ; i++) {		array[j]+=1;		if (data[i][0] != data[i-1][0])			j++;		}	return array;}/* sums the number of things in each bin and places that value in returned array/* written M. Kosnik 1999.05.23/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *sumbin(unsigned long **data, int column, int length, int bins){	int i=0, j=0;	int *array;	array = ivector(bins);	for (i=0 ; i<bins ; i++)		array[i]=0;		array[0]+=data[0][column];	for (i=1 ; i<length ; i++) {		if (data[i][0] != data[i-1][0]) j++;		array[j]+=data[i][column];	}		return array;}/* sums the number of things in each bin and places that value in returned array/* written M. Kosnik 1999.05.23/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *sumbin2(unsigned long **data, int count_column, int bin_column, int length, int numbins){	int i=0, j=0;	int *array;	array = ivector(numbins);	for (i=0 ; i<numbins ; i++)		array[i]=0;		array[0]+=data[0][count_column];	for (i=1 ; i<length ; i++) {		if (data[i][bin_column] != data[i-1][bin_column]) j++;		array[j]+=data[i][count_column];	}		return array;}/* condense lists within bins into single lists/* needs, data matrix to be condensed and a array indicating which bin each list is in/* number of items in the lists, number of lists, number of bins/* debugged, works on test file MAK 1999.05.24/* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long **condense_bins(unsigned long **data, unsigned long *listbins, int taxa, int lists, int bins){	int i=0,j=0;	int bin=0, nbins=1;	unsigned long *array;	unsigned long **purpose;	array=ulvector(lists);	purpose=ulmatrix(bins, taxa);		for (i=0 ; i<lists ; i++) array[i]=0;	for (i=0 ; i<taxa ; i++)		for(j=0 ; j<bins ; j++) purpose[j][i]=0;		array[0]=listbins[0];	for(j=0 ; j<lists ; j++){		for(i=0 ; i<nbins ; i++) 			if (listbins[j]==array[i]){				bin = i;				i=INT_MAX;				break;			}		if (i != INT_MAX) {			array[nbins]=listbins[j];			bin=nbins;			nbins++;		}		for (i=0 ; i<taxa ; i++)			purpose[bin][i]+=data[j][i];	}	free_ulvector(array);	return purpose;}/* condense lists within bins into single lists/* needs, data matrix to be condensed and a array indicating which bin each list is in/* number of items in the lists, number of lists, number of bins/* debugged, works on test file MAK 1999.05.24/* written M. Kosnik 1999.05.24/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long **condense_bins2(unsigned long **data, int ntaxa, int nbins, int min){	int i=0,j=0, k=0;	unsigned long **purpose;	purpose=ulmatrix(nbins, ntaxa);		for (i=0 ; i<ntaxa ; i++)		for(j=0 ; j<nbins ; j++) 			purpose[j][i]=0;		for(i=0 ; i<nbins ; i++) {		for(k=0 ; k < min ; k++) {			for (j=0 ; j<ntaxa ; j++) {				purpose[i][j] += data[(min*i)+k][j];			}		}	}					return purpose;}/* written M. Kosnik 1999.08.25/* output bin diversity based on data array and bin information/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */unsigned long *bintabulation (unsigned long **data, int numtaxa, int numlists, int numbins, unsigned long *listbins2){	unsigned long **raw_bin;				/* rarefied bins (bin by taxon presence/absence) */	unsigned long *bin_div;					/* species diversity of rarefied bins for current replicate */	int i;		raw_bin = condense_bins(data, listbins2, numtaxa, numlists, numbins);	p_ulong_matrix(raw_bin,numbins,numtaxa);		bin_div = ul_countrows(raw_bin, numtaxa, numbins);	for (i=0 ; i<numbins ;i++) 		printf ("%5.3f",bin_div[i]);	printf ("\n");			free_ulmatrix(raw_bin, numbins, numtaxa);	return bin_div;}