						else if (prfl[swing][0]==prfl[end1][0] && prfl[swing][0]<=prfl[end2][0])	{							/*  e1	sw	e2								¥	¥	¥								¥	¥---¥								¥   ¥								¥---¥	*/							/* if end1 or swing disappears before end2 appears OR if end1 or swing disappears first when both disappear before end1, then assume it is not ancestral	*//*							if ((prfl[end1][1]+1)<prfl[end2][0] && (prfl[swing][1]+1)>=prfl[end2][0])	*/							/* swing outlasts end1, so assume that it is ancestral to end2	*/							if ((prfl[end1][1]+1)<prfl[end2][0] && prfl[swing][1]>prfl[end1][1])	{							/*  e1	sw	e2									¥	¥									¥	¥									¥								¥   ¥								¥---¥	*/								stratcomp[8]+=1.0f;								/* 2013-04-12: AGAIN (and hope it sticks): find center of gravity for original state pair			*/								ancp=(pairs[end1][0]*states[ch2])+pairs[end1][1];		/* 2013-04-12: get number of state pair for ranges */								cg=cladeshapefromrichness(pairfnd[ancp],onset,end);								stratcomp[16]=cg[1]/c0;								/* record how long ancestral state pair survives	*/								for (t=onset; t<end && pairfnd[ancp][t]>0; ++t);								stratcomp[18]=((double) (t-onset))/((double) (1+(end-onset)));								}							/* end1 outlasts swing, so assume that it is ancestral to end2	*/							else if ((prfl[end1][1]+1)<prfl[end2][0] && prfl[swing][1]<prfl[end1][1])	{								stratcomp[8]+=0.0f;								/* 2013-04-12: AGAIN (and hope it sticks): find center of gravity for original state pair			*/								ancp=(pairs[swing][0]*states[ch2])+pairs[swing][1];		/* 2013-04-12: get number of state pair for ranges */								cg=cladeshapefromrichness(pairfnd[ancp],onset,end);								stratcomp[17]=cg[1]/c0;								/* record how long ancestral state pair survives	*/								for (t=onset; t<end && pairfnd[ancp][t]>0; ++t);								stratcomp[19]=((double) (t-onset))/((double) (1+(end-onset)));								}							/* otherwise, assume that this could be either hierarchical or divergent									*/							else	{								stratcomp[8]+=0.5f;								ancp=(pairs[swing][0]*states[ch2])+pairs[swing][1];		/* 2013-04-12: get number of state pair for ranges */								cg=cladeshapefromrichness(pairfnd[ancp],onset,end);								stratcomp[16]=cg[1]/c0;								/* record how long ancestral state pair survives	*/								for (t=onset; t<end && pairfnd[ancp][t]>0; ++t);								stratcomp[18]=((double) (t-onset))/((double) (1+(end-onset)));								free_dvector(cg);																ancp=(pairs[swing][0]*states[ch2])+pairs[swing][1];		/* 2013-04-12: get number of state pair for ranges */								cg=cladeshapefromrichness(pairfnd[ancp],onset,end);								stratcomp[17]=cg[1]/c0;								/* record how long ancestral state pair survives	*/								for (t=onset; t<end && pairfnd[ancp][t]>0; ++t);								stratcomp[19]=((double) (t-onset))/((double) (1+(end-onset)));								}							/* now worry about budding and anagenesis.  First, it's 50% that it's divergent, so all values are chopped in half			*/							/*		2nd, the first two pairs can only fit budding as they are contemporaneous											*/							stratcomp[10]+=0.25f;					/* end1 & swing consistent with budding IF the pair is hierarchical		    		*/							/* ask whether possible hierarchical compatibility is consistent with anagenesis or budding									*/							if (prfl[end2][0]>=prfl[swing][1])								stratcomp[9]+=0.25f;				/* consistent with anagenesis: but only half because it might not be hierarchical	*/							else								stratcomp[10]+=0.25f;				/* one pair definitely consistent with budding, other might be		    			*/														/* we know that end1 and swing overlap; the quesiton is whether swing overlaps with end2	*/							if ((prfl[swing][1]+1)>=prfl[end2][0])	{								stratcomp[6]+=1.0f;					/* no gap between morphotypes								*/								/* super-strict requires no gaps at all!														*/								f=sumlvector(gap,3);								if (f==0)		stratcomp[7]+=1.0f;	/* no gaps within or between morphotypes					*/ 								}							}	/* end routine for clearly hierarchical															*/