		if (ch<ttlintegr)	{			cset=ch/(b=setinfo[1]);		/* 0É4 go to cset = 0 if there are 5 per set	*/			cch=b*cset;					/* find "control" character	*/			b=0;			for (sp=0; sp<notu; ++sp)	{				if (matrix[sp][cch]==1 && sp!=taxachange[ch][steps[ch]-1])	{					for (a=0; a<trpd[sp]; ++a)	{						branches[b]=sp;						++b;						}					}				}			for (cl=0; cl<nodes; ++cl)	{				sp2=cl+notu;				sp=tree[cl][1];				if (matrix[sp][cch]==1 && sp2!=taxachange[ch][steps[ch]-1])	{					for (a=0; a<trpd[sp2]; ++a)	{						branches[b]=sp2;						++b;						}					}				}			br=(int)((double)rand() / ((double)RAND_MAX + 1) * b);			while (br==b)	br=(int)((double)rand() / ((double)RAND_MAX + 1) * b);			/* have binary characters change on branches - if they are not autapomorphic, then they need to diagnose multiple species THIS WAS REMOVED 10/14/2003			else				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (avnodes-used));*/			sp2=sp=branches[br];	/*		if (sp>=notu)	sp2=tree[cl=(sp-notu)][1];	/* test species	*/			/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			/* sp2 is sampled taxon; sp is "test" species to see if this region of the tree can change;				cl is the clade number if sp2 is a clade and not a species	*/	/*		f=1;			while ((matrix[sp2][cch]==0 || f==0) || (trpd[sp]==0 || br>=(ttlbr-used)))	{				f=0;				br=(int)((double)rand() / ((double)RAND_MAX + 1) * b);				sp2=sp=branches[br];				if (sp>=notu)	sp2=tree[cl=(sp-notu)][1];				if (matrix[sp2][cch]==1)	{					f=1; 					for (a=0; a<steps[ch]; ++a)	if (sp==taxachange[ch][a])	f=0;					}					}	/*			while (matrix[sp2][cch]==0)	{					br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));					sp2=sp = branches[br];					if (sp>=notu)	sp2=tree[sp-notu][1];					}					}	/* end search for appropriate branch	*/			}	if (ch<ttlintegr)	{		if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{			if (nstates[ch]==2)					invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);			else if (ctype[ch]==1)				invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);			else if (ctype[ch]==0)	{				invmatrix[ch][sp]=matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);				/* make sure no negative numbers are kept! */				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				}			ev=1;	/* this means that there was a change */			}		else if (sp>notu)	{			d=0;			/* make sure that there are taxa with scorable conditions for this character 		*/			/* and also that not all the descendants have changed already for this character 	*/			/* (the latter can be omitted as evolution cannot know this - but it makes the 		*/			/* output easier to compare to empirical studies.)									*/					for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;				else	{					for (c=0; c<steps[ch]; ++c)	{						if (taxachange[ch][c]==sp2)	{							++d;							c=steps[ch];							}						}					}		/* if any taxa have not yet changed, then d < clade diversity */				}	/* end search for scored taxa */				/* if d is less than clade diversity, then proceed with change */			if (d<tree[sp-notu][0])	{				/* if character is an unordered multistate, then we need an array	*/				/* that tells how each state changed withing the clade				*/				if (ctype[ch]==1)	{					/* routine for unordered multistates */					if (nstates[ch]>2)	{						evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);						}					/* routine for binaries */					else	{						evolvebinaryinclade(tree[sp-notu],matrix,ch);						}					}	/* end routine for unordered / binary characters */				/* routine for ordered multistate */				else {					/* flip is used only for multistates */					flip = ((int) (100 * rand() / RAND_MAX));					if (flip<bias[ch])	flip=1;					else				flip=-1;					evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);					multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);					}				/* now make sure that there was change */				for (c=0; c<notu; ++c)	{					if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;					invmatrix[ch][c]=matrix[c][ch];					}				}	/* end conditional loop */			}	/* end routine for clade */		if (ev==1)	{			++mpd[sp];			taxachange[ch][steps[ch]]=sp;			++steps[ch];			++indch[ch];//				if (dch==1)	++indch[ch];			++deltas;			++st;	/* we increment this only if we have made a change */			}		}	/* this will be a second change for these characters	*/	if (ch<ttlintegr)	{	//		x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);	/* see if whole set or just character changes	*/		cset=ch/(b=setinfo[1]);		/* 0É4 go to cset = 0 if there are 5 per set	*/		cch=b*cset;					/* find "control" character	*/				b=0;		for (sp=0; sp<notu+nodes; ++sp)	{			sp2=sp;			if (sp==notu)	++sp;			if (sp>notu)	sp2=tree[sp-notu][1];	/* first species in clade: use this to see if clade is eligible for change	*/			if (matrix[sp2][cch]==1 && trpd[sp]>0)	{				f=0;				for (c=0; c<steps[ch]; ++c)	if (taxachange[ch][c]==sp)	f=1;				if (f==0)	{					d=b;					for (b=d; b<d+trpd[sp]; ++b)	branches[b]=sp;					}				}			}		used=ttlbr-b;	/* this will be the key for choosing the branch	*/		}	if (ch<ttlintegr)	{		cset=ch/(b=setinfo[1]);		/* 0É4 go to cset = 0 if there are 5 per set	*/		equalivector(branches,availablesets[cset],ttlbrset[cset]);		br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbrset[cset]-used));		sp = branches[br];		}	/* character states already not apomorphic: it can hit a species now	*/	else	{		equalivector(branches,available,ttlbr);		while (sp<(notu-1))	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			/* have binary characters change on branches - if they are not autapomorphic, then they need to diagnose multiple species THIS WAS REMOVED 10/14/2003			else				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (avnodes-used));*/			sp = branches[br];					/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			}	/* have change diagnose 2+ species at first, just to make sure it isn't autapomorphic	*/	