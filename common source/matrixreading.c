/* Routines to summarize matrices/arrays already in computer/* 		memory.  Use filereading.c for getting similar information from files./*	Peter Wagner	05/02/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */#define matrixanalysis#include "matrixanalysis.h"#define matrixchange#include "matrixchange.h"#define matrixreading#include "matrixreading.h"#define memory#include "memory.h"#define minmax#include "minmax.h"#define mak_sort_functions#include "sort.h"#include <stdlib.h>#include <stdio.h>#include <time.h>#include <math.h>#include <string.h>/* Calculates the number of states for each character given a matrix./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	UNKNOWN: code for unknown states/*	INAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *numberstates(long **omat, int notu, int nchars, int UNKNOWN, int INAP){int	a, b, ch, sp, st;int *nstates, *unst;nstates=ivector(nchars);/* find the maximum state number */st=0;for (ch=0; ch<nchars; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]>st && (omat[sp][ch]!=INAP && omat[sp][ch]!=UNKNOWN))			st=omat[sp][ch];		}	}unst=ivector(st+1);/* determine how species each state  has */for (ch=0; ch<nchars; ++ch)	{	st=0;	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]!=UNKNOWN && omat[sp][ch]!=INAP)	{			b=0;			for (a=0; a<st; ++a)	{				if (omat[sp][ch]==unst[a])	{					b=1;					a=st;					}				}			if (b==0)	{				unst[st]=omat[sp][ch];				++st;				}			}		}	nstates[ch]=st;	}free_ivector(unst);return nstates;}/* Finds the minimum state for each character given a matrix./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	UNKNOWN: code for unknown states/*	INAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *mincharstates(long **omat, int notu, int nchars, int UNKNOWN, int INAP){int	ch, sp;int *mnst;mnst=ivector(nchars);clearivector(mnst,nchars,10000);/* find the minimum state number */for (ch=0; ch<nchars; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]<mnst[ch] && (omat[sp][ch]!=INAP && omat[sp][ch]!=UNKNOWN))			mnst[ch]=omat[sp][ch];		}	}return mnst;}/* Finds the minimum state for each character given a matrix./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	UNKNOWN: code for unknown states/*	INAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *maxcharstates(long **omat, int notu, int nchars, int UNKNOWN, int INAP){int	ch, sp;int *mxst;mxst=ivector(nchars);/* find the minimum state number */for (ch=0; ch<nchars; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]>mxst[ch] && (omat[sp][ch]!=INAP && omat[sp][ch]!=UNKNOWN))			mxst[ch]=omat[sp][ch];		}	}return mxst;}/* Calculates the number of states for each character given a matrix./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	UNKNOWN: code for unknown states/*	INAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *numb_states(long **omat, int *nstates, int notu, int nchars, int UNKNOWN, int INAP){int	a, b, ch, sp, st;int *unst;clearivector(nstates,nchars,0);/* find the maximum state number */st=0;for (ch=0; ch<nchars; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]>st && (omat[sp][ch]!=INAP && omat[sp][ch]!=UNKNOWN))			st=omat[sp][ch];		}	}unst=ivector(st+1);/* determine how species each state  has */for (ch=0; ch<nchars; ++ch)	{	st=0;	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]!=UNKNOWN && omat[sp][ch]!=INAP)	{			b=0;			for (a=0; a<st; ++a)	{				if (omat[sp][ch]==unst[a])	{					b=1;					a=st;					}				}			if (b==0)	{				unst[st]=omat[sp][ch];				++st;				}			}		}	nstates[ch]=st;	}free_ivector(unst);return nstates;}/* Calculates the number of states for a particular character given a matrix./*/* Requires:/*	states: taxon X character matrix of character states/*	notu: number of taxa/*	UNKNOWN: code for unknown states/*	INAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int no_states(long **omat, int CH, int notu, int UNKNOWN, int INAP){int	a, b, sp, st;int *unst;/* find the maximum state number */st=0;for (sp=0; sp<notu; ++sp)	{	if (omat[sp][CH]>st && (omat[sp][CH]!=INAP && omat[sp][CH]!=UNKNOWN))		st=omat[sp][CH];	}/* determine how species each state  has */unst=ivector(st+1);st=0;for (sp=0; sp<notu; ++sp)	{	if (omat[sp][CH]!=UNKNOWN && omat[sp][CH]!=INAP)	{		b=0;		for (a=0; a<st; ++a)	{			if (omat[sp][CH]==unst[a])	{				b=1;				a=st;				}			}		if (b==0)	{			unst[st]=omat[sp][CH];			++st;			}		}	}free_ivector(unst);return st;}/* Calculates the number of species with derived conditions./*/* Requires:/*	omat: taxon X character matrix of character states/*	nstates: number of states per character (added 10/5/2003)/*	notu: number of taxa/*	nchars: number of characters/*	UNKNOWN: code for unknown states/*	INAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *autapomorphies(long **omat, int *nstates, int notu, int nchars, int UNKNOWN, int INAP)/*int *autapomorphies(long **omat, int *nstates, int notu, int nchars)	*/{int	ch, st, sp, max;int *autap, *tallied;autap=ivector(nchars);max=maxiarray(nstates,nchars);tallied=ivector(max);/* determine how many species each states has */for (ch=0; ch<nchars; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]!=UNKNOWN && omat[sp][ch]!=INAP)	{			st=omat[sp][ch];			if (st>=0 && st<nstates[ch])	++tallied[st];			}		}	/* calculate autaporphies as sum of taxa scored minus the number scored for the most common state */	autap[ch]=sumivector(tallied,nstates[ch]) - maxiarray(tallied,nstates[ch]);	clearivector(tallied,nstates[ch],0);	}free_ivector(tallied);return autap;}int *tallyautaps (long **omat, int *nstates, int notu, int nchars){int ch, st, sp, max;int *autap, *tallied;autap=ivector(nchars);max=maxiarray(nstates,nchars);tallied=ivector(max);for (ch=0; ch<nchars; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]>0 && omat[sp][ch]<nstates[ch])	{			st=omat[sp][ch];			++tallied[st];			}		}	st=nstates[ch];	autap[ch]=sumivector(tallied,nstates[ch])-maxiarray(tallied,nstates[ch]);	clearivector(tallied,nstates[ch],0);	}free_ivector(tallied);return autap;}/* Calculates the number of species with derived conditions for a single character CH./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	chn: character being examined/*	UNKNOWN: code for unknown states/*	INAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int autapo_char(long **omat, int notu, int chn, int UNKNOWN, int INAP){int	st, sp, states=0;int *tallied, autap;for (sp=0; sp<notu; ++sp)	if (omat[sp][chn]>states && (omat[sp][chn]!=INAP && omat[sp][chn]!=UNKNOWN))	states=omat[sp][chn];++states;		/* if a binary character, then states will equal 1; we need it to equal 2 */tallied=ivector(states);clearivector(tallied,states,0);/* determine how many species each states has */for (sp=0; sp<notu; ++sp)	{	if (omat[sp][chn]!=UNKNOWN && omat[sp][chn]!=INAP)	{		st=omat[sp][chn];		if (st>=0 && st<states)	++tallied[st];		}	}autap=sumivector(tallied,states) - maxiarray(tallied,states);free_ivector(tallied);return autap;/*autap=stmax=0;for (st=0; st<=max; ++st)	{	if (tallied[st]>stmax)	{		stmax=tallied[st];		}	}for (st=0; st<=max; ++st)	if (st!=OutCond)	autap=autap+tallied[st];*/}/* Initialize and return an array giving the maximum changes per character. *//* Requires:	matrix - character matrix	nchars - number of characters	notu - number of taxa;	nstates - number of states per character;	*******************************************************************************************************************************************/int *maxchanges(long **matrix, int nchars, int notu, int *nstates, int *ctype, int INAP, int UNKNOWN){int	c, s, u, m;int *maxdelta, *strich;/*long *ordered, *revordered;	*/m=maxiarray(nstates,nchars);strich=ivector(m+1);/*ordered=lvector(notu);/*revordered=lvector(notu);	*/maxdelta=ivector(nchars);/*	Determine the maximum number of changes per character	*/for (c=0; c<nchars; ++c)	{	u=0;	clearivector(strich,m+1,0);	for (s=0; s<notu; ++s)	{		if (matrix[s][c]!=INAP && matrix[s][c]!=UNKNOWN)	++strich[matrix[s][c]];		else	++u;		}	maxdelta[c]=notu-(maxiarray(strich,m+1)+u);/*	for (s=0; s<notu; ++s)	ordered[s]=revordered[s]=matrix[s][c];	/*	ordered=lshellsort_inc(ordered,notu);/*	revordered=lshellsort_dec(revordered,notu);	*/		/* Eliminate unknown and/or inapplicable *//*	u=0;/*	for (s=0; s<(notu-u) && (ordered[0]==UNKNOWN || ordered[0]==INAP); ++s)	{/*		for (t=s; t<(notu-u)-1; ++t)	ordered[t]=ordered[t+1];/*		--s;/*		++u;/*		}/*	for (s=0; s<(notu-u) && (revordered[0]==UNKNOWN || revordered[0]==INAP); ++s)	{/*		for (t=s; t<(notu-u)-1; ++t)	revordered[t]=revordered[t+1];/*		--s;/*		++u;/*		}	/*	for (s=0; s<(notu-u) && (revordered[s]>ordered[s]); ++s)	{/*		if (ctype[c]==1)	++maxdelta[c];/*		else				maxdelta[c]=maxdelta[c]+(revordered[s]-ordered[s]);/*		}	*//*	max=0;	maxdelta[c]=notu;	for (t=0; t<notu; ++t)	if (matrix[t][c]==INAP || matrix[t][c]==UNKNOWN)	--maxdelta[c];	for (s=minst[c]; s<=minst[c]+nstates[c]; ++s)	{		ch=0;		for (t=0; t<notu; ++t)			if (matrix[t][c]==s)	++ch;		if (ch>max)	max=ch;		if (max>=(notu/2))	s=minst[c]+nstates[c];		}	maxdelta[c]=maxdelta[c]-max;	if (maxdelta[c]>(notu-1))	maxdelta[c]=notu-1;	/* restrict maximum changes to one less than # of taxa */	}/*free_lvector(ordered);/*free_lvector(revordered);	*/free_ivector(strich);return maxdelta;}/* Calculates the number of species with unknown./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	UNKNOWN: code for unknown states/*	INAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *unknownstates(long **omat, int notu, int nchars, int UNKNOWN, int INAP){int	ch, sp;int *missing;missing=ivector(nchars);for (ch=0; ch<nchars; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]==INAP || omat[sp][ch]==UNKNOWN)			++missing[ch];		}	}return missing;}/* Rescales matrices so the minimum value is 0 for each column./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	UNKNOWN: code for unknown states/*	INAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */long **scalematrix(long **matrix, int notu, int nchars, int UNKNOWN, int INAP, int scale){int	ch, sp, min;for (ch=0; ch<nchars; ++ch)	{	/* first, find out if the character needs to be rescaled */	min=RAND_MAX;	for (sp=0; sp<notu; ++sp)	{		if (matrix[sp][ch]<min && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))			min=matrix[sp][ch];		}			if (min!=scale)	{		for (sp=0; sp<notu; ++sp)	{			if (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP)				matrix[sp][ch]=matrix[sp][ch]-(min-scale);			}	/* reset scored characters up or down so that scale is the lowest */		}	/* only bother if the lowest does not match the scale */	}	return matrix;}/* applicabletaxa: finds number of applicable taxa for a character/*/* Requires: ***************************************************************************************/int *applicabletaxa(long **mat, int nchars, int notu, int INAP){int	ch, sp, *ap;ap=ivector(nchars);for (ch=0; ch<nchars; ++ch)	for (sp=0; sp<notu; ++sp)	if (mat[sp][ch]!=INAP)	++ap[ch];return ap;}/* inapplicables: finds number of dependent characters in a matrix/*/* Requires: /*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	INAP: code for inapplicable characters***************************************************************************************/int inapplicables(long **omat, int notu, int nchars, int INAP){int	ch, sp;int depend=0;for (ch=0; ch<nchars; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]==INAP)	{			++depend;			sp=notu;			}		} 	}return depend;}/* inaplist: finds number of dependent characters in a matrix/*/* Requires: /*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	INAP: code for inapplicable characters***************************************************************************************/int *inaplist(long **omat, int notu, int nchars, int INAP, int depend){int	ch, sp, d=0;int *deplist;deplist=ivector(depend);for (ch=0; ch<nchars && d<depend; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (omat[sp][ch]==INAP)	{			deplist[d]=ch;			++d;			sp=notu;			}		} 	}return deplist;}/* findindependents: finds the independent character on which a dependent character depends/*/* Requires: /*	omat: row X col matrix of integers/*	rows: number of rows/*	col: number of columns/*	find: value being sought/*	start: row at which search starts/*	end: row at whcih search ends/*/* Returns:/*	found: 0 if absent, 1 if present***************************************************************************************/int *findindependents(long **cmat, int notu, int INAP, int UNKNOWN, int depend, int *dependents){int	c, ch1, ch2, sp, found, st;int *independent;int	*test1, *test2;independent=ivector(depend);test1=ivector(notu);test2=ivector(notu);for (c=0; c<depend; ++c)	{	independent[c]=-1;	ch2=dependents[c];	for (sp=0; sp<notu; ++sp)	test2[sp]=cmat[sp][ch2];	/* only botherlooking at earlier characters */	found=0;	for (ch1=ch2-1; ch1>=0 && found==0; --ch1)	{				for (sp=0; sp<notu; ++sp)	test1[sp]=cmat[sp][ch1];		/* find the state for character 1 matching inapplicables from character 2 */ 		for (sp=0; cmat[sp][ch2]!=INAP; sp=sp)	++sp;		st=cmat[sp][ch1];		/* if the matching state is unknown, then ch1 should not be the character 		*/		/* if the matching state is inapplicable, then ch1 should not be the character 	*/		if (st!=UNKNOWN && st!=INAP)	{			/* first see if scored dependents co-occur with only one state */			found=1;			for (sp=0; sp<notu && found==1; ++sp)				if ((cmat[sp][ch2]!=INAP && cmat[sp][ch2]!=UNKNOWN) && cmat[sp][ch1]!=st)					found=0;						/* if this does not work, then see if inapplicable co-occurs with only one state */			if (found==0)	{				found=1;				for (sp=0; sp<notu && found==1; ++sp)					if (cmat[sp][ch2]==INAP && cmat[sp][ch1]!=st)						found=0;				}			}		if (found==1)	independent[c]=ch1;		}	/* end search for a logical dependent character for ch2 */	}	/* end search of inapplicable characters */free_ivector(test1);free_ivector(test2);return(independent);}/* findinlmatrix: determines whether a value is in some part of a matrix/*/* Requires: /*	omat: row X col matrix of integers/*	rows: number of rows/*	col: number of columns/*	find: value being sought/*	start: row at which search starts/*	end: row at whcih search ends/*/* Returns:/*	found: 0 if absent, 1 if present***************************************************************************************/int findinlmatrix(long **omat, int rows, int col, int find, int start, int end){int a, b, found=0;for (b=0; b<col && found==0; ++b)	{	for (a=start; a<end && found==0; ++a)	{		if (omat[a][b]==find)	found=1;		}	}return found;}/* compareivector: determines whether two integer vectors are identical/*/* Requires: /*	v1: vector 1/*	v2: vector 2/*	N: number of cells/*/* Returns:/*	f: 0 if true, 1 if false***************************************************************************************/int compareivector(int *v1, int *v2, int N){int a, f=0;for (a=0; a<N && f==0; ++a)	if (v1[a]!=v2[a])	f=1;return f;}/* maxentryivector: finds the maximum number of times any value is entered in an array/*/* Requires: /*	v: vector/*	n: number of cells/*/* Returns:/*	c: maximum count***************************************************************************************/int maxentryivector(int *v, int n){int	a, b, m;int *v2;v2=ivector(n);equalivector(v2,v,n);v2=ishellsort_inc(v2,n);b=m=1;for (a=1; a<n; ++a)	{	/* if same as previous, increment b*/	if (v2[a]==v2[a-1])	++b;	/* if different, then reset b; first, see if this is the biggest b */	else	{		if (b>m)		m=b;		b=0;		}	}free_ivector(v2);return m;}/* maxentryivector: finds the maximum value entered in an array/*/* Requires: /*	v: vector/*	n: number of cells/*/* Returns:/*	c: maximum count***************************************************************************************int maxinivector(int *v, int n){int	a;int *v2;v2=ivector(n);v2=equalivector(v2,v,n);v2=ishellsort_inc(v2,n);a=v2[n-1];free_ivector(v2);return a;}	*//* maxentryivector: finds the maximum value entered in an array/*/* Requires: /*	v: vector/*	n: number of cells/*/* Returns:/*	c: maximum count***************************************************************************************int mininivector(int *v, int n){int	a;int *v2;v2=ivector(n);v2=equalivector(v2,v,n);v2=ishellsort_inc(v2,n);a=v2[0];free_ivector(v2);return a;}	*//* countentryivector: finds the number of unique entries/*/* Requires: /*	v: vector/*	n: number of cells/*/* Returns:/*	b: number of unique entries***************************************************************************************/int countentryivector(int *v, int n){int	a, b;int *v2;v2=ivector(n);equalivector(v2,v,n);v2=ishellsort_inc(v2,n);b=1;for (a=1; a<n; ++a)	{	/* if different, then count */	if (v2[a]!=v2[a-1])		++b;	}free_ivector(v2);return b;}/* maxinlmatrix: finds the maximum number within a long matrix/*/* Requires: /*	mat: matrix of long/*	R: number of rows/*	C: number of columns/*/* Returns:/*	max: maximum value***************************************************************************************/int maxinlmatrix(long **mat, int R, int C){int a, b;int	max=0;for (a=0; a<R; ++a)	{	for (b=0; b<C; ++b)	{		if (mat[a][b]>max)	max=mat[a][b];		}	}return max;}/* maxinclmatrix: finds the maximum number within a long matrix/*/* Requires: /*	cmat: matrix of character states/*	notu: number of taxa/*	nchar: number of characters/*	UNKNOWN: unknown code (ignored)/*	INAP: inapplicable code (ignored)/*/* Returns:/*	max: maximum value***************************************************************************************/int maxinclmatrix(long **cmat, int notu, int nchar, int UNKNOWN, int INAP){int sp, ch;int	max=0;for (sp=0; sp<notu; ++sp)	{	for (ch=0; ch<nchar; ++ch)	{		if (cmat[sp][ch]>max && (cmat[sp][ch]!=INAP && cmat[sp][ch]!=UNKNOWN))	max=cmat[sp][ch];		}	}return max;}/* maxstringlength - Reads a list of names and finds the longest/* Requires:/*		strings - a matrix of characters (e.g., names)/*		N - the number of strings (i.e., # of rows)/*		eol - character denoting the end of the line/* Returns:/*		max - length of the longest name****************************************************************************/int	maxstringlength(char **strings, int N, char eol){int	n, m, max=0;for (n=0; n<N; ++n)	{	for (m=0; strings[n][m]!=eol; m=m)	++m;	if (m>max)	max=m;	}++max;return max;}/* maxstringlength - Reads a list of names and finds the longest/* Requires:/*		strings - a matrix of characters (e.g., names)/*		N - the number of strings (i.e., # of rows)/*		eol - character denoting the end of the line/* Returns:/*		max - length of the longest name****************************************************************************/int	*stringlengths(char **strings, int N, char eol){int	n, m;int *l;l=ivector(N);for (n=0; n<N; ++n)	{	for (m=0; strings[n][m]!=eol; m=m)	++m;	l[n]=m;	}return l;}/* colminclmatrix - reads through a cladistic matrix column and returns the lowest value/* Requires:/*		mat - a matrix of long/*		notu - the number of taxa (i.e., # of rows)/*		c - character number in question/*		INAP: code for inapplicable characters/*		UNKNOWN: code for unknown characters/* Returns:/*		max - length of the longest name****************************************************************************/int colminclmatrix(long **mat, int notu, int c, int UNKNOWN, int INAP){int	r, min=RAND_MAX;for (r=0; r<notu; ++r)	{	while ((mat[r][c]==UNKNOWN || mat[r][c]==INAP) && r<notu)	++r;	if (r>=notu)	break;	if (mat[r][c]<min)	min=mat[r][c];		}return min;}/* colminclmatrix - reads through a cladistic matrix column and returns the lowest value/* Requires:/*		mat - a matrix of long/*		notu - the number of taxa (i.e., # of rows)/*		c - character number in question/*		INAP: code for inapplicable characters/*		UNKNOWN: code for unknown characters/* Returns:/*		max - length of the longest name****************************************************************************/int colmaxclmatrix(long **mat, int notu, int c, int UNKNOWN, int INAP){int	r, max=-1*RAND_MAX;for (r=0; r<notu; ++r)	{	while ((mat[r][c]==UNKNOWN || mat[r][c]==INAP) && r<notu)	++r;	if (r>=notu)	break;	if (mat[r][c]>max)	max=mat[r][c];		}return max;}/* countuniqivector - counts the number of unique values in a vector of integer;/* Requires:/*		mat - a matrix of long/*		notu - the number of taxa (i.e., # of rows)/*		c - character number in question/*		INAP: code for inapplicable characters/*		UNKNOWN: code for unknown characters/* Returns:/*		max - length of the longest name****************************************************************************/int countuniqivector(int *v, int n){int	a, un=1;int *sorted;/* read v into sorted, and then sort sorted */sorted=ivector(n);equalivector(sorted,v,n);sorted=ishellsort_inc(sorted,n);/* count the number of times sorted[a] differs from sorted[a-1] - that is the number of unique elements */for (a=1; a<n; ++a)	if (sorted[a]!=sorted[a-1])	++un;free_ivector(sorted);return un;}/* countuniqlvector - counts the number of unique values in a vector of long;/* Requires:/*		v - a vector of long/*		n - the length of the vector (i.e., # of rows)/*		c - character number in question/*		INAP: code for inapplicable characters/*		UNKNOWN: code for unknown characters/* Returns:/*		max - length of the longest name****************************************************************************/int countuniqlvector(long *v, int n){int	a, un=1;long *sorted;/* read v into sorted, and then sort sorted */sorted=lvector(n);equallvector(sorted,v,n);sorted=lshellsort_inc(sorted,n);/* count the number of times sorted[a] differs from sorted[a-1] - that is the number of unique elements */for (a=1; a<n; ++a)	if (sorted[a]!=sorted[a-1])	++un;free_lvector(sorted);return un;}/* countuniqlvector - counts the number of unique values in a vector of long;/* Requires:/*		v - a vector of long/*		n - the length of the vector (i.e., # of rows)/*		c - character number in question/*		INAP: code for inapplicable characters/*		UNKNOWN: code for unknown characters/* Returns:/*		max - length of the longest name****************************************************************************/int countstatescharvector(long *chvector, int notu, int UNKNOWN, int INAP){int	a, st=1;long *sorted;/* read v into sorted, and then sort sorted */sorted=lvector(notu);equallvector(sorted,chvector,notu);sorted=lshellsort_inc(sorted,notu);/* count the number of times sorted[a] differs from sorted[a-1] - that is the number of unique elements */for (a=1; a<notu; ++a)	{	if (sorted[a]!=sorted[a-1])	{		if ((sorted[a]!=UNKNOWN && sorted[a]!=INAP) && (sorted[a-1]!=UNKNOWN && sorted[a-1]!=INAP))	++st;		}	}free_lvector(sorted);return st;}/* maxinlmatrixrow: finds the maximum number within a particular column of a long matrix/*/* Requires: /*	mat: matrix of long/*	rows: number of rows/*	col: number of columns/*/* Returns:/*	max: maximum value***************************************************************************************int maxinlmatrixcol(long **mat, int rows, int col){int r;int	max=0;for (r=0; r<rows; ++r)	if (mat[r][col]>max)	max=mat[r][col];return max;}	*//* mininlmatrixcol: finds the minimum number within a particular column of a long matrix/*/* Requires: /*	mat: matrix of long/*	rows: number of rows/*	col: number of columns/*/* Returns:/*	max: maximum value***************************************************************************************int mininlmatrixcol(long **mat, int rows, int col){int r;int	min=RAND_MAX;for (r=0; r<rows; ++r)	if (mat[r][col]<min)	min=mat[r][col];return min;}	*//* staterichness: counts the number of taxa with each state/*/* Requires: /*	mat: matrix of long/*	rows: number of rows/*	col: number of columns/*/* Returns:/*	max: maximum value***************************************************************************************/long **staterichness(long **mat, int notu, int nchar, int inap, int unknown) {int	ch, sp, s;int	mxst;long **strich;mxst=maxinclmatrix(mat,notu,nchar,inap,unknown);strich=lmatrix(nchar,mxst+1);for (ch=0; ch<nchar; ++ch)	{	for (sp=0; sp<notu; ++sp)	{		if (mat[sp][ch]!=inap && mat[sp][ch]!=unknown)	{			s=mat[sp][ch];			++strich[ch][s];			}	/* tally richness for ch-s */		}	/* end search of species */	}	/* end search of characters */return strich;}/* readXcube: emulates a 3D matrix mat[i][j][k], with [j]&[k] handled by the column cells;Requires:	mat: 2D matrix of X;	i: cell in dimension 1;	j: cell in dimension 2;	k: cell in dimension 3;	mxk: maximum number of cells in dimension k  ***************************************************************************************/int readicube(int **mat, int i, int j, int k, int mxk){int x;x=mat[i][(j*mxk)+k];return x;}long readlcube(long **mat, int i, int j, int k, int mxk) {long x;x=mat[i][(j*mxk)+k];return x;}unsigned long readucube(unsigned long **mat, int i, int j, int k, int mxk) {unsigned long x;x=mat[i][(j*mxk)+k];return x;}float readfcube(float **mat, int i, int j, int k, int mxk) {float x;x=mat[i][(j*mxk)+k];return x;}double readdcube(double **mat, int i, int j, int k, int mxk) {double x;x=mat[i][(j*mxk)+k];return x;}/* assignXcube: emulates a 3D matrix mat[i][j][k], with [j]&[k] handled by the column cells;Requires:	mat: 2D matrix of double;	i: cell in dimension 1;	j: cell in dimension 2;	k: cell in dimension 3;	mxk: maximum number of cells in dimension k  	x: the value going into mat[i][j][k];***************************************************************************************/void **assignicube(int **mat, int i, int j, int k, int mxk, int x) {mat[i][(j*mxk)+k] = x;}void **assignlcube(long **mat, int i, int j, int k, int mxk, long x) {mat[i][(j*mxk)+k] = x;}void **assignucube(unsigned long **mat, int i, int j, int k, int mxk, unsigned long x) {mat[i][(j*mxk)+k] = x;}void **assignfcube(float **mat, int i, int j, int k, int mxk, float x) {mat[i][(j*mxk)+k] = x;}void **assigndcube(double **mat, int i, int j, int k, int mxk, double x) {mat[i][(j*mxk)+k] = x;}/*charstateunkncombos - calculates the probability of X compatibilities given Y steps and observed matrix.Requires:	nstates: array giving the number of states per character	chuns: number of unknowns per character	nchars: number of charactersReturns:	combo: combo[a][0] gives the number of states and final[a][1] gives the number of unknowns.**********************************************************************************************************************************************************/long **charstateunkncombos (int *nstates, int *chuns, int nchars){int	c, d, f, g, cmb=1;long **dummy, **combo;dummy=lmatrix(nchars,2);for (c=0; c<nchars; ++c)	{	/* go down on dummy[d][0], then again on dummy[d][1]; if a new combo is found, then insert it; if not, then skip it	*/	for (d=0; d<cmb; ++d)	{		/* once you find combos with the same number of states....	*/		if (d==(cmb-1))	{			dummy[d][0]=nstates[c];			dummy[d][1]=chuns[c];			++cmb;			d=cmb;			}		else if (dummy[d][0]==nstates[c])	{			for (f=d; f<cmb; ++f)	{				/* if a higher chuns is found OR if a lower one is the last paired with this # of character states, then add combo	*/				if (dummy[f][1]>chuns[c] || (dummy[f][1]<chuns[c] && (dummy[f+1][0]>nstates[c] || f==(cmb-1))))	{					for (g=cmb; g>f; --g)	{						dummy[g][0]=dummy[g-1][0];						dummy[g][1]=dummy[g-1][1];						}	/* increment others upwards	*/					dummy[f][0]=nstates[c];					dummy[f][1]=chuns[c];					++cmb;					d=f=cmb;					}				else if (dummy[f][1]==chuns[c])					d=f=cmb;				}			}		/* case where we find x states for the first time, including when we've found a new highest state	*/		else if (dummy[d][0]>nstates[c])	{			for (g=cmb; g>d; --g)	{				dummy[g][0]=dummy[g-1][0];				dummy[g][1]=dummy[g-1][1];				}	/* increment others upwards	*/			dummy[d][0]=nstates[c];			dummy[d][1]=chuns[c];			++cmb;			d=cmb;			}	/* end case for	new number of states */		}	/* end test to see if next combo of states & unknowns is new	*/	}--cmb;combo=lmatrix(cmb+1,2);for (c=0; c<cmb; ++c)	{	combo[c][0]=dummy[c][0];	combo[c][1]=dummy[c][1];	}combo[c][0]=-1;combo[c][1]=cmb;return combo;}void *extractlongcolumn(long **matrix, long *column, int col, int rows){int a;for (a=0; a<rows; ++a)	column[a]=matrix[a][col];return (0);}long **charactersbystates(int *states, int nchars, int maxst){int c, mc, ch, st, maxS=0;long **charsbystates;for (st=2; st<maxst; ++st)	{	mc=0;	for (ch=0; ch<nchars; ++ch)	{		if (states[ch]==st)	++mc;		}	if (mc>maxS)	maxS=mc;	if (maxS>nchars/2)	st=maxst;	}charsbystates=lmatrix(maxst,maxS);for (st=2; st<maxst; ++st)	{	c=0;	for (ch=0; ch<nchars; ++ch)	{		if (states[ch]==st)	{			charsbystates[st][c]=ch;			++c;			}		}	}return charsbystates;}unsigned long *categorizeulmatrix(unsigned long **Data, int Cat, int Mem, int N){int c, i, j, m;unsigned long *category;j=maxulmatrixcol(Data,N,Cat);++j;category=ulvector(j);c=Data[0][Cat];++category[c];for (i=1; i<N; ++i)	{	c=Data[i][Cat];	m=Data[i][Mem];	if (Data[i-1][Cat]!=c || Data[i-1][Mem]!=m)	{		++category[c];		}	}return (category);}/* Calculates the number of states for each character given a matrix./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	UNKNOWN: code for unknown states/*	INAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int *countunscoredtaxa(long **chmat, int notu, int nchars, int UNKNOWN, int INAP){int	ch, sp;int *missing;missing=ivector(nchars);clearivector(missing,nchars,0);/* find the maximum state number */for (ch=0; ch<nchars; ++ch)	for (sp=0; sp<notu; ++sp)		if (chmat[sp][ch]==INAP || chmat[sp][ch]==UNKNOWN)	++missing[ch];	return missing;}/* Calculates the number of states for each character given a matrix./*/* Requires:/*	omat: taxon X character matrix of character states/*	notu: number of taxa/*	nchars: number of characters/*	UNKNOWN: code for unknown states/*	INAP: code for inapplicable characters/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */int tally_unscored_for_taxon(long **chmat, int sp, int nchars, int UNKNOWN, int INAP){int	ch;int missing=0;/* find the maximum state number */for (ch=0; ch<nchars; ++ch)	if (chmat[sp][ch]==((long) INAP) || chmat[sp][ch]==((long) UNKNOWN))	++missing;return missing;}