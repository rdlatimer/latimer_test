/* stratcompatparambstest: simulations for stratigraphic compatibility with parameters determined by best fit for stratigraphic dataRequires:	taxonname: group analyzed	citation: source of data	summary: summary of observed data	mbl: simulation parameters	omatrix: observed matrix	ctype: character types	nstates: states per character	bias: character evolution bias	maxch: maximum change per character	depend: character dependencies	notu: number of taxa	nchars: number of characters	compat: compatibility type (general or hierarchical)	RUNS: simulations	debug: 1 to seed based on replications, 0 for time	UNKNOWN: code for unknown states	INAP: code for inapplicable statesReturns:	simmary[0]: p observed general stratigraphic compatibility	simmary[1]: p observed strict stratigraphic compatibility	simmary[2]: p observed hierarchical stratigraphic compatibility	simmary[3]: expected general stratigraphic compatibility	simmary[4]: expected strict stratigraphic compatibility	simmary[5]: expected hierarchical stratigraphic compatibility	simmary[6]: p proportional hierarchical stratigraphic compatibility	simmary[7]: expected proportional hierarchical stratigraphic compatibility	simmary[8]: p hierarchical compatibility consistent with anagenesis	simmary[9]:	expected hierarchical compatibility consistent with anagenesis	simmary[10]: p observed “reversal” character being less compatible	simmary[11]: expected number of stratigraphically incompatible pairs in which “reversed” character is less compatible	simmary[12]: p observed average compatibility of stratigraphically compatible pairs	simmary[13]: expected compatibility of stratigraphically compatible pairs	simmary[14]: p observed average compatibility of stratigraphically incompatible pairs	simmary[15]: expected compatibility of stratigraphically incompatible pairsNOTE: Should I add expected compatibility of SIN & GSC characters?  Ummm.... sure, why not?TO REDO:	simmary[0]: P[observed general stratigraphic compatibility]	simmary[1]: E[general stratigraphic compatibility]	simmary[2]: P[observed strict stratigraphic compatibility]	simmary[3]: E[strict stratigraphic compatibility]	simmary[4]: P[observed super strict compatible character pairs]	simmary[5]: E[super strict compatible character pairs]	simmary[6]: P[observed hierarchical stratigraphic compatibility]	simmary[7]: E[hierarchical stratigraphic compatibility]	simmary[8]: P[observed proportion hierarchical stratigraphic compatibility;]	simmary[9]: E[proportion hierarchical stratigraphic compatibility;]	simmary[10]: P[observed hierarchical stratigraphic compatible pairs consistent with anagenesis]	simmary[11]: E[hierarchical stratigraphic compatible pairs consistent with anagenesis]	simmary[12]: P[observed hierarchical stratigraphic compatible pairs consistent with budding]	simmary[13]: E[hierarchical stratigraphic compatible pairs consistent with budding]	simmary[14]: P[observed compatibilty implies divergent stratigraphically incompatibilty (SIN)]	simmary[15]: E[compatibilty implies divergent SIN]	simmary[16]: P[observed compatibilty implies hierarchical stratigraphically incompatibilty SIN]	simmary[17]: E[stratigraphy implies hierarchical SIN]	simmary[18]: P[observed stratigraphy implies divergent SIN]	simmary[19]: E[stratigraphy implies divergent SIN]	simmary[20]: P[observed stratigraphy implies hierarchical SIN]	simmary[21]: E[stratigraphy implies hierarchical SIN]	simmary[22]: P[observed proportion of younger end state pair in SIN characters]	simmary[23]: E[proportion of younger end state pair in SIN characters]	simmary[24]: P[compatibility of stratigraphically compatible pairs]	simmary[25]: E[compatibility of stratigraphically compatible pairs]	simmary[26]: P[compatibility of SIN pairs]	simmary[27]: E[compatibility of SIN pairs]	simmary[28]: P[diff. in compatibility between SC & SIN pairs]	simmary[29]: E[diff. in compatibility between SC & SIN pairs]double	*genstratcomp, *strstratcomp, *hierstratcmp, *hierstratprp;double	*supstratcomp, *gapfreepairs, *hierstratana, *hierstratbud;double	*compdivSIN, *comphierSIN, *stratdivSIN, *strathierSIN;double	*propend2cp, *compSCP, *compSIN;****************************************************************************/double *stratcompatparambstest(char taxonname[90], char citation[90], double *summary, double *mbl, long **omatrix, int *ctype, int *nstates, int *bias, int *maxch, int *depend, int notu, int nchars, int compat, int RUNS, char excl, int debug, int UNKNOWN, int INAP){/* part one - matrix properties */int		d, r, s;int		c, c1, c2;int		keep;int 	clades;int		hierflop=0;int		*simauts;//int	uninf, out=0, uninfcompat, posscompat, auts, ttlcompat, comptype=0;long  	**simatrix, **ranges;long	**tree, **vtree;//long	**dbtree;double	*sstrcmp;unsigned long **compmat;unsigned long	*charcomps;//double	*genstratcomp, *strstratcomp, *hierstratcmp, *hierstratprp,*scha,*sih;double	*genstratcomp, *strstratcomp, *hierstratcmp, *hierstratprp;double	*supstratcomp, *hierstratana, *hierstratbud;double	*compdivSIN, *comphierSIN, *stratdivSIN, *strathierSIN;double	*propend2cp, *avecompscp, *avecompsin, *avecompdif;double	*simmary;double	cp;double	tiegs=0.0f, tiess=0.0f, tiehs=0.0f, tiehp=0.0f, tiescha=0.0f, tiesih=0.0f, tieavecscp=0.0f, tieavecsin=0.0f, tieavecdif=0.0f;double	tiexs=0.0f, tieha=0.0f, tiehb=0.0f, tiesincd=0.0f, tiesinch=0.0f, tiesinsd=0.0f, tiesinsh=0.0f, tiesind2=0.0f;//double	**genrstcmpcor, **strcstcmpcor, **hierstcmpcor;//long	**histories;long	secs;char	outfile[120];FILE	*output, *debugoutput;if (RUNS%2==0)	++RUNS;			/* it's easier to use an odd number....	*/time(&secs);srand((unsigned int) secs);genstratcomp=dvector(RUNS);		/* tallies sstrcomp[5], for simmary[0,1]				*/strstratcomp=dvector(RUNS);		/* tallies sstrcomp[6], for simmary[2,3]				*/	supstratcomp=dvector(RUNS);		/* tallies sstrcomp[7], for simmary[8,9]				*/hierstratcmp=dvector(RUNS);		/* tallies sstrcomp[8], for simmary[4,5]				*/hierstratprp=dvector(RUNS);		/* tallies sstrcomp[8]/sstrcomp[5], for simmary[6,7]	*/hierstratana=dvector(RUNS);		/* tallies sstrcomp[9], for simmary[10,11]				*/hierstratbud=dvector(RUNS);		/* tallies sstrcomp[10], for simmary[12,13]				*/compdivSIN=dvector(RUNS);		/* tallies sstrcomp[11], for simmary[14,15]				*/comphierSIN=dvector(RUNS);		/* tallies sstrcomp[12], for simmary[16,17]				*/stratdivSIN=dvector(RUNS);		/* tallies sstrcomp[13], for simmary[18,19]				*/strathierSIN=dvector(RUNS);		/* tallies sstrcomp[14], for simmary[20,21]				*/propend2cp=dvector(RUNS);		/* tallies sstrcomp[15], for simmary[22,23]				*/avecompscp=dvector(RUNS);		/* tallies for simmary[24,25]							*/avecompsin=dvector(RUNS);		/* tallies for simmary[26.27]							*/avecompdif=dvector(RUNS);		/* tallies for simmary[28,29]							*/ranges=lmatrix(notu,2);simatrix=lmatrix(notu,nchars);simmary=dvector(30);d=0;							/* for debugging	*/for (r=d; r<RUNS; ++r)	{	/* 2011-03-28: BLOWOUT at r=5	*/	genstratcomp[r]=strstratcomp[r]=hierstratcmp[r]=hierstratprp[r]=0.0f;	supstratcomp[r]=hierstratana[r]=hierstratbud[r]=compdivSIN[r]=comphierSIN[r]=stratdivSIN[r]=strathierSIN[r]=propend2cp[r]=avecompscp[r]=avecompsin[r]=0.0f;	for (s=0; s<notu; ++s)	{		for (c=0; c<nchars; ++c)	{			if (omatrix[s][c]==UNKNOWN)				simatrix[s][c]=UNKNOWN;			else if (omatrix[s][c]==INAP)				simatrix[s][c]=INAP;			else				simatrix[s][c]=0;			}		}	if (debug==1)	{		srand((unsigned int) (r+1)*notu*nchars);		}		/* 	trees[notu-1]: branch length of otus			trees[notu]:   branch length of clades		trees[notu+1]: first appearances of otus		trees[notu+2]: last appearances of otus	**********************************************/	tree=evolvetree(notu,mbl,1);	clades=cladecountbytaxa(tree,notu);	/* pull range data out of back of tree matrix	*/	for (s=0; s<notu; ++s)	{		ranges[s][0]=tree[notu+1][s];		ranges[s][1]=tree[notu+2][s];		}	cleancladerangedata(ranges,notu);	vtree=VennTreePlus(tree,clades,notu,notu);	/* evolve character matrix, simatrix	*///	long **evolvetocompat(long **tree, int tcomp, int notu, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int *depend, int comptype, int UNKNOWN, int INAP)//	simatrix=evolvetocompat(tree,empcompat,notu,matrix,nchars,nstates,ctype,bias,chmax,depend,comptype,UNKNOWN,INAP);	simatrix=evolvetocompatibility(vtree, compat, notu, clades, simatrix, nchars, nstates, ctype, bias, maxch, depend, 0, UNKNOWN, INAP);		if (d>0)	{		debugoutput=fopen("SuspectMatrix.txt","w");		for (s=0; s<notu; ++s)	{			for (c=0; c<nchars; ++c)	{				if (simatrix[s][c]==UNKNOWN)	fprintf(debugoutput,"?\t");				else if (simatrix[s][c]==INAP)	fprintf(debugoutput,"—\t");				else							fprintf(debugoutput,"%d\t",simatrix[s][c]);				}			fprintf(debugoutput,"%d\t%d\n",ranges[s][0],ranges[s][1]);			}		fclose(debugoutput);		}//	simatrix=evolvematrix(vtree, notu, clades, simatrix, nchars, nstates, ctype, bias, maxch, 2*nchars, UNKNOWN, INAP);/*		sstates=numberstates(simatrix,notu,nchars,UNKNOWN,INAP);	*///	compat=nu_comp(nstates, notu, simatrix, ctype, nchars, 0, 0, UNKNOWN, INAP);	compmat=compatible(nstates,notu,simatrix,ctype,nchars,0,0,UNKNOWN,INAP);	charcomps=char_comp(nstates,notu,simatrix,ctype,nchars,0,0,UNKNOWN,INAP);	simauts=autapomorphies(simatrix,nstates,notu,nchars,UNKNOWN,INAP);	/* get the minimum number of derived states	*//*	for (c1=0; c1<nchars; ++c1)	++examples[compmat[c1][c1]];	*/	cp=0.0f;	for (c1=0; c1<(nchars-1); ++c1)	{		/* reinstated 2012-02-29	*/		if (excl=='y')		while ((simauts[c1]<2 || simauts[c1]>(notu-2)) && c1<(nchars-1))	++c1;		if (c1>=nchars)		break;		for (c2=(c1+1); c2<nchars; ++c2)	{			/* reinstated 2012-02-29	*/			if (excl=='y')		while ((simauts[c2]<2 || simauts[c2]>(notu-2)) && c2<(nchars-1))	++c2;			if (c2>=nchars)		break;			if (compmat[c1][c2]==1)	{				/*sstrcmp=stratcompatfull(ranges, simatrix, nstates, c1, c2, notu, UNKNOWN, INAP);	*/				/* 2011-10-14: changed to "plus"													*/				sstrcmp=stratcompatfullplusplus(ranges, simatrix, nstates, charcomps, c1, c2, notu, UNKNOWN, INAP);				/* rewrite this so that we simply take the median values from sstrcomp (simulated strat comp) for expectations	*/				/* and the distribution for p-values when examining the real results											*/				cp+=sstrcmp[4];										/* compatible comparisons						*/				genstratcomp[r]+=sstrcmp[5];						/* general stratigraphic consistency			*/				strstratcomp[r]+=sstrcmp[6];						/* strict stratigraphic consistency				*/				supstratcomp[r]+=sstrcmp[7];						/* superstrict stratigraphic consistency		*/				hierstratcmp[r]+=sstrcmp[8];						/* hierarchical stratigraphic consistency		*/				hierstratana[r]+=sstrcmp[9];						/* HSC consistent with anagenesis				*/				hierstratbud[r]+=sstrcmp[10];						/* HSC consistent with budding					*/				compdivSIN[r]+=sstrcmp[11];							/* compatibility-supported divergent SIN		*/				comphierSIN[r]+=sstrcmp[12];						/* compatibility-supported hierarchical SIN		*/				stratdivSIN[r]+=sstrcmp[13];						/* stratigraphy-supported divergent SIN			*/				strathierSIN[r]+=sstrcmp[14];						/* stratigraphy-supported hierarchical SIN		*/				propend2cp[r]+=sstrcmp[15];							/* relative diversity of younger SIN end pair	*/				if (sstrcmp[5]>0)				avecompscp[r]+=(((double) charcomps[c1])+((double) charcomps[c2]))/2;				if (sstrcmp[5]<sstrcmp[4])		avecompsin[r]+=(((double) charcomps[c1])+((double) charcomps[c2]))/2;/*				scha[r]+=sstrcmp[9];						/* hierarchical compatible pairs consistent with anagenesis			2011-10-14	*//*				sih[r]+=sstrcmp[11];						/* stratigraphically incompatible pairs consistent with hierarchy	2011-10-14	*/				/* 2011-10-14: tally compatibilities of stratigraphically compatible & incompatible character pairs	*//*				if (sstrcmp[5]==1)	{					avecompscp[r]+=((double) (charcomps[c1]+charcomps[c2]))/2;					scgw+=1.0;													/* this will tally characters, not state pairs						*//*					}				else	{					avecompsin[r]+=((double) (charcomps[c1]+charcomps[c2]))/2;					sci+=1.0;					}					/* this will give the proportion of compatibilities that are stratigraphically compatible by compatibility	*//*				genrstcmpcor[compmat[c1][c1]]+=sstrcmp[5];			/* general stratigraphic consistency		*//*				strcstcmpcor[compmat[c1][c1]]+=sstrcmp[6];			/* strict stratigraphic consistency			*//*				hierstcmpcor[compmat[c1][c1]]+=sstrcmp[8];			/* hierarchical stratigraphic consistency	*//*				genrstcmpcor[compmat[c2][c2]]+=sstrcmp[5];			/* general stratigraphic consistency		*//*				strcstcmpcor[compmat[c2][c2]]+=sstrcmp[6];			/* strict stratigraphic consistency			*//*				hierstcmpcor[compmat[c2][c2]]+=sstrcmp[8];			/* hierarchical stratigraphic consistency	*/				free_dvector(sstrcmp);				}			}		}		/* get proportions of hierarchical stratigraphic characters relative to total								*/	/* Also, get proportions of particular types of hierarchical stratigraphic characters						*/	hierstratprp[r]+=(hierstratcmp[r]/genstratcomp[r]);						/* proportional hierarchical stratigraphic compatibility	*/	/* if there is no hierarchical compatibility, then modify the routine: 2011-11-01	*/	if (hierstratcmp[r]>0)	{		hierstratana[r]/=hierstratcmp[r];										/* proportion of HSC matching anagenesis					*/		hierstratbud[r]/=hierstratcmp[r];										/* proportion of HSC demanding budding						*/		}	else	{		++hierflop;																/* tally runs in which there was no hierarchical compatibility	*/		hierstratana[r]=hierstratbud[r]=MAXRAND;		}	/* get average compatibilities of stratigraphically compatible and incompatible character pairs					*/	avecompscp[r]/=genstratcomp[r];											/* added 2011-10-14	*/	avecompsin[r]/=(cp-genstratcomp[r]);									/* added 2011-10-14	*/	avecompdif[r]=avecompscp[r]-avecompsin[r];								/* added 2011-11-01: because I sort these later, this is otherwise lost */	/* get proportion of SIN character pairs matching divergent or hierarchical patterns				*/	compdivSIN[r]/=(cp-genstratcomp[r]);									/* compatibility-supported divergent SIN		*/	comphierSIN[r]/=(cp-genstratcomp[r]);									/* compatibility-supported hierarchical SIN		*/	stratdivSIN[r]/=(cp-genstratcomp[r]);									/* stratigraphy-supported divergent SIN			*/	strathierSIN[r]/=(cp-genstratcomp[r]);									/* stratigraphy-supported hierarchical SIN		*/	propend2cp[r]/=(cp-genstratcomp[r]);									/* relative diversity of younger SIN end pair	*/	/* cp will vary a little from simulation to simulation because it is based on state numbers, so report things in proportions	*/	genstratcomp[r]/=((double) cp);											/* general stratigraphic consistency						*/	strstratcomp[r]/=((double) cp);											/* strict stratigraphic consistency							*/	supstratcomp[r]/=((double) cp);											/* super strict stratigraphic consistency					*/	hierstratcmp[r]/=((double) cp);											/* hierarchical stratigraphic consistency					*/	/* tally cases where simulated values are lower than observed values		*/	if (genstratcomp[r]<summary[0])		simmary[0]+=(1/((double) RUNS));	if (strstratcomp[r]<summary[1])		simmary[2]+=(1/((double) RUNS));	if (supstratcomp[r]<summary[2])		simmary[4]+=(1/((double) RUNS));	if (hierstratcmp[r]<summary[3])		simmary[6]+=(1/((double) RUNS));	if (hierstratprp[r]<summary[4])		simmary[8]+=(1/((double) RUNS));	if (hierstratana[r]<summary[5])		simmary[10]+=(1/((double) RUNS));	if (hierstratbud[r]<summary[6])		simmary[12]+=(1/((double) RUNS));	if (compdivSIN[r]<summary[7])		simmary[14]+=(1/((double) RUNS));	if (comphierSIN[r]<summary[8])		simmary[16]+=(1/((double) RUNS));	if (stratdivSIN[r]<summary[9])		simmary[18]+=(1/((double) RUNS));	if (strathierSIN[r]<summary[10])	simmary[20]+=(1/((double) RUNS));	if (propend2cp[r]<summary[11])		simmary[22]+=(1/((double) RUNS));	if (avecompscp[r]<summary[12])		simmary[24]+=(1/((double) RUNS));					/* added 2011-10-14	*/	if (avecompsin[r]<summary[13])		simmary[26]+=(1/((double) RUNS));					/* added 2011-10-14	*/	if (avecompdif[r]<(summary[12]-summary[13]))										simmary[27]+=(1/((double) RUNS));					/* added 2011-11-01: because I sort these later, this is otherwise lost */	/* tally cases where simulated values are exactly equal to observed values	*/	if (genstratcomp[r]==summary[0])	tiegs+=(1/((double) RUNS));	if (strstratcomp[r]==summary[1])	tiess+=(1/((double) RUNS));	if (supstratcomp[r]==summary[2])	tiexs+=(1/((double) RUNS));	if (hierstratcmp[r]==summary[3])	tiehs+=(1/((double) RUNS));	if (hierstratprp[r]==summary[4])	tiehp+=(1/((double) RUNS));	if (hierstratana[r]==summary[5])	tieha+=(1/((double) RUNS));	if (hierstratbud[r]==summary[6])	tiehb+=(1/((double) RUNS));	if (compdivSIN[r]==summary[7])		tiesincd+=(1/((double) RUNS));	if (comphierSIN[r]==summary[8])		tiesinch+=(1/((double) RUNS));	if (stratdivSIN[r]==summary[9])		tiesinsd+=(1/((double) RUNS));	if (strathierSIN[r]==summary[10])	tiesinsh+=(1/((double) RUNS));	if (propend2cp[r]==summary[11])		tiesind2+=(1/((double) RUNS));	if (avecompscp[r]==summary[12])		tieavecscp+=(1/((double) RUNS));					/* added 2011-10-14	*/	if (avecompsin[r]==summary[13])		tieavecsin+=(1/((double) RUNS));					/* added 2011-10-14	*/	if (avecompdif[r]==(summary[12]-summary[13]))										tieavecdif+=(1/((double) RUNS));					/* added 2011-11-01: because I sort these later, this is otherwise lost */	if ((r%10)==9)	{//			printf("Doing Rate = %5.4f",mbl[2]);		if (r>10)	{			printf("\b\b\b\b\b");					/* clear ", Tree %d"		*/			}		if (r>18 && r<100) 			printf("\b\b\b");		else if (r>99 && r<1000)	printf("\b\b\b\b");		else if (r>999)				printf("\b\b\b\b\b");		printf("Tree %d\n", r+1);		}		free_ulmatrix(compmat,nchars,nchars);	free_lmatrix(vtree,clades+1,notu);	free_lmatrix(tree,clades+3,notu);	}/* sort for medians	*/genstratcomp=dshellsort_inc(genstratcomp,RUNS); 	/* 0:  sort stratigraphic compatiblity						*/strstratcomp=dshellsort_inc(strstratcomp,RUNS); 	/* 1:  sort strict stratigraphic compatiblity				*/supstratcomp=dshellsort_inc(supstratcomp,RUNS);		/* 2:  sort super strict stratigraphic compatibility		*/hierstratcmp=dshellsort_inc(hierstratcmp,RUNS);		/* 3:  sort hierarchical stratigraphic compatiblity (HSC)	*/hierstratprp=dshellsort_inc(hierstratprp,RUNS);		/* 4:  sort proportion HSC									*/hierstratana=dshellsort_inc(hierstratana,RUNS);		/* 5:  sort HSC consistent with anagenesis					*/hierstratbud=dshellsort_inc(hierstratbud,RUNS);		/* 6:  sort HSC demanding budding							*/compdivSIN=dshellsort_inc(compdivSIN,RUNS);			/* 7:  sort compatibility suggests divergent SIN			*/comphierSIN=dshellsort_inc(comphierSIN,RUNS);		/* 8:  sort compatibility suggests hierarchical SIN			*/stratdivSIN=dshellsort_inc(stratdivSIN,RUNS);		/* 9:  sort stratigraphy suggests divergent SIN				*/strathierSIN=dshellsort_inc(strathierSIN,RUNS);		/* 10: sort stratigraphy suggests hierarchical SIN			*/propend2cp=dshellsort_inc(propend2cp,RUNS);			/* 11: sort relative diversity of derived end pair			*/avecompscp=dshellsort_inc(avecompscp,RUNS);			/* 12: sort average compatibilities of SC character pairs	*/avecompsin=dshellsort_inc(avecompsin,RUNS);			/* 13: sort average compatibilities of SIN character pairs	*/avecompdif=dshellsort_inc(avecompdif,RUNS);			/* 14: sort average differences between SC & SIN pairs		*//* get alpha values: if observed values are "low" then we want p[observed or lower]: so, add ties to total	*//* for "high" values, we do not need to do this: 1-simmary gives p[observed or more extreme] as we tallied only sims less than observed	*//* we want the probability of the observed OR MORE EXTREME; because we tallied every time the observed was lower than what we saw,		we don't need to do this when p> 0.5	*/if (simmary[0]<0.5)		simmary[0]+=tiegs;			/* general stratigraphic compatibility	*/if (simmary[2]<0.5)		simmary[2]+=tiess;			/* strict stratigraphic compatibility	*/if (simmary[4]<0.5)		simmary[4]+=tiexs;if (simmary[6]<0.5)		simmary[6]+=tiehs;if (simmary[8]<0.5)		simmary[8]+=tiehp;if (simmary[10]<0.5)	simmary[10]+=tieha;if (simmary[12]<0.5)	simmary[12]+=tiehb;if (simmary[14]<0.5)	simmary[14]+=tiesincd;if (simmary[16]<0.5)	simmary[16]+=tiesinch;if (simmary[18]<0.5)	simmary[18]+=tiesinsd;if (simmary[20]<0.5)	simmary[20]+=tiesinsh;if (simmary[22]<0.5)	simmary[22]+=tiesind2;if (simmary[24]<0.5)	simmary[24]+=tieavecscp;if (simmary[26]<0.5)	simmary[26]+=tieavecsin;if (simmary[28]<0.5)	simmary[28]+=tieavecsin;/* adjust for runs with no hierarchical compatibility	*/simmary[10]*=(((double) (RUNS-hierflop))/((double) RUNS));		/* adjust significance of anagenetic hierarchical compatibility	*/simmary[12]*=(((double) (RUNS-hierflop))/((double) RUNS));		/* adjust significance of budding hierarchical compatibility	*//* tally median expected stratigraphic compatibilities	*/simmary[1]=genstratcomp[RUNS/2];simmary[3]=strstratcomp[RUNS/2];simmary[5]=supstratcomp[RUNS/2];simmary[7]=hierstratcmp[RUNS/2];simmary[9]=hierstratprp[RUNS/2];simmary[11]=hierstratana[(RUNS-hierflop)/2];			/* accommodate runs with no hierarchical compatibility	*/simmary[13]=hierstratbud[(RUNS-hierflop)/2];			/* accommodate runs with no hierarchical compatibility	*/simmary[15]=compdivSIN[RUNS/2];simmary[17]=comphierSIN[RUNS/2];simmary[19]=stratdivSIN[RUNS/2];simmary[21]=strathierSIN[RUNS/2];simmary[23]=propend2cp[RUNS/2];simmary[25]=avecompscp[RUNS/2];simmary[27]=avecompsin[RUNS/2];simmary[29]=avecompdif[RUNS/2];/* return output to here!	*//* TEMPORARY!  UNTIL I'VE DEBUGGED THIS.....	*/keep=1;//keep=0;//printf("Enter '1' if you want output for this taxon: ");//scanf("%i",&keep);	if (keep==1)	{	strcpy(outfile,taxonname);	strcat(outfile,"_");	strcat(outfile,citation);	strcat(outfile,"_Expectations");	if (mbl[4]==0)	strcat(outfile,"_Bud.xls");	else			strcat(outfile,"_Bif.xls");		output=fopen(outfile,"w");	fprintf(output,"Run");	fprintf(output,"\tGeneral Stratigraphic Compatibility (SC)");	fprintf(output,"\tStrict SC");	fprintf(output,"\tSuper Strict SC");	fprintf(output,"\tHierarchical SC");	fprintf(output,"\tProportional HSC");	fprintf(output,"\tAnagenetic HSC");	fprintf(output,"\tBudding HSC");	fprintf(output,"\tDivergent SIN (Comp)");	fprintf(output,"\tHierarchical SIN (Comp)");	fprintf(output,"\tDivergent SIN (Strat)");	fprintf(output,"\tHierarchical SIN (Strat)");	fprintf(output,"\tProp Diversity Younger SIN Pair");	fprintf(output,"\tµ Character Compabibility (SC)");					/* added 2011-10-14	*/	fprintf(output,"\tµ Character Compabibility (SIN)");					/* added 2011-10-14	*/	fprintf(output,"\tµ Compabibility Diff (SC-SIN)\n");				/* added 2011-11-01	*/		for (r=0; r<RUNS; ++r)	{		fprintf(output,"%d",r+1);		fprintf(output,"\t%4.3f",genstratcomp[r]);		fprintf(output,"\t%4.3f",strstratcomp[r]);		fprintf(output,"\t%4.3f",supstratcomp[r]);		fprintf(output,"\t%4.3f",hierstratcmp[r]);		fprintf(output,"\t%4.3f",hierstratprp[r]);		if (hierstratana[r]<MAXRAND)	fprintf(output,"\t%4.3f",hierstratana[r]);		else							fprintf(output,"\t•");		if (hierstratbud[r]<MAXRAND)	fprintf(output,"\t%4.3f",hierstratbud[r]);		else							fprintf(output,"\t•");		fprintf(output,"\t%4.3f",compdivSIN[r]);		fprintf(output,"\t%4.3f",comphierSIN[r]);		fprintf(output,"\t%4.3f",stratdivSIN[r]);		fprintf(output,"\t%4.3f",strathierSIN[r]);		fprintf(output,"\t%4.3f",propend2cp[r]);		fprintf(output,"\t%4.3f",avecompscp[r]);					/* added 2011-10-14	*/		fprintf(output,"\t%4.3f",avecompsin[r]);					/* added 2011-10-14	*/		fprintf(output,"\t%4.3f\n",avecompdif[r]);					/* added 2011-11-01	*/		}	fclose(output);	}free_dvector(genstratcomp);free_dvector(strstratcomp);free_dvector(supstratcomp);		/* tallies sstrcomp[7], for simmary[8,9]				*/free_dvector(hierstratcmp);free_dvector(hierstratprp);free_dvector(hierstratana);		/* tallies sstrcomp[9], for simmary[10,11]				*/free_dvector(hierstratbud);		/* tallies sstrcomp[10], for simmary[12,13]				*/free_dvector(compdivSIN);		/* tallies sstrcomp[11], for simmary[14,15]				*/free_dvector(comphierSIN);		/* tallies sstrcomp[12], for simmary[16,17]				*/free_dvector(stratdivSIN);		/* tallies sstrcomp[13], for simmary[18,19]				*/free_dvector(strathierSIN);		/* tallies sstrcomp[14], for simmary[20,21]				*/free_dvector(propend2cp);		/* tallies sstrcomp[15], for simmary[22,23]				*/free_dvector(avecompscp);free_dvector(avecompsin);free_dvector(avecompdif);free_lmatrix(ranges,notu,2);return simmary;}/* stratcompatparambstest: simulations for stratigraphic compatibility with parameters determined by best fit for stratigraphic dataRequires:	taxonname: group analyzed	citation: source of data	summary: summary of observed data	mbl: simulation parameters	omatrix: observed matrix	ctype: character types	nstates: states per character	bias: character evolution bias	maxch: maximum change per character	depend: character dependencies	notu: number of taxa	nchars: number of characters	compat: compatibility type (general or hierarchical)	RUNS: simulations	debug: 1 to seed based on replications, 0 for time	excl: exclude autapomorphies	UNKNOWN: code for unknown states	INAP: code for inapplicable statesReturns:	simmary[0]: p observed general stratigraphic compatibility	simmary[1]: p observed strict stratigraphic compatibility	simmary[2]: p observed hierarchical stratigraphic compatibility	simmary[3]: expected general stratigraphic compatibility	simmary[4]: expected strict stratigraphic compatibility	simmary[5]: expected hierarchical stratigraphic compatibility	simmary[6]: p proportional hierarchical stratigraphic compatibility	simmary[7]: expected proportional hierarchical stratigraphic compatibility	simmary[8]: p hierarchical compatibility consistent with anagenesis	simmary[9]:	expected hierarchical compatibility consistent with anagenesis	simmary[10]: p observed “reversal” character being less compatible	simmary[11]: expected number of stratigraphically incompatible pairs in which “reversed” character is less compatible	simmary[12]: p observed average compatibility of stratigraphically compatible pairs	simmary[13]: expected compatibility of stratigraphically compatible pairs	simmary[14]: p observed average compatibility of stratigraphically incompatible pairs	simmary[15]: expected compatibility of stratigraphically incompatible pairsNOTE: Should I add expected compatibility of SIN & GSC characters?  Ummm.... sure, why not?TO REDO:	simmary[0]: P[observed general stratigraphic compatibility]	simmary[1]: E[general stratigraphic compatibility]	simmary[2]: P[observed strict stratigraphic compatibility]	simmary[3]: E[strict stratigraphic compatibility]	simmary[4]: P[observed super strict compatible character pairs]	simmary[5]: E[super strict compatible character pairs]	simmary[6]: P[observed hierarchical stratigraphic compatibility]	simmary[7]: E[hierarchical stratigraphic compatibility]	simmary[8]: P[observed proportion hierarchical stratigraphic compatibility;]	simmary[9]: E[proportion hierarchical stratigraphic compatibility;]	simmary[10]: P[observed hierarchical stratigraphic compatible pairs consistent with anagenesis]	simmary[11]: E[hierarchical stratigraphic compatible pairs consistent with anagenesis]	simmary[12]: P[observed hierarchical stratigraphic compatible pairs consistent with budding]	simmary[13]: E[hierarchical stratigraphic compatible pairs consistent with budding]	simmary[14]: P[observed compatibilty implies divergent stratigraphically incompatibilty (SIN)]	simmary[15]: E[compatibilty implies divergent SIN]	simmary[16]: P[observed compatibilty implies hierarchical stratigraphically incompatibilty SIN]	simmary[17]: E[stratigraphy implies hierarchical SIN]	simmary[18]: P[observed stratigraphy implies divergent SIN]	simmary[19]: E[stratigraphy implies divergent SIN]	simmary[20]: P[observed stratigraphy implies hierarchical SIN]	simmary[21]: E[stratigraphy implies hierarchical SIN]	simmary[22]: P[observed proportion of younger end state pair in SIN characters]	simmary[23]: E[proportion of younger end state pair in SIN characters]	simmary[24]: P[compatibility of stratigraphically compatible pairs]	simmary[25]: E[compatibility of stratigraphically compatible pairs]	simmary[26]: P[compatibility of SIN pairs]	simmary[27]: E[compatibility of SIN pairs]	simmary[28]: P[diff. in compatibility between SC & SIN pairs]	simmary[29]: E[diff. in compatibility between SC & SIN pairs]double	*genstratcomp, *strstratcomp, *hierstratcmp, *hierstratprp;double	*supstratcomp, *gapfreepairs, *hierstratana, *hierstratbud;double	*compdivSIN, *comphierSIN, *stratdivSIN, *strathierSIN;double	*propend2cp, *compSCP, *compSIN;****************************************************************************/double *stratcompatparambstestoutdated(char taxonname[90], char citation[90], double *summary, double *mbl, long **omatrix, int *ctype, int *nstates, int *bias, int *maxch, int *depend, int notu, int nchars, int compat, int RUNS, char excl, int debug, int UNKNOWN, int INAP){/* part one - matrix properties */int		d, r, s;int		c, c1, c2;int		keep;int 	clades;int		hierflop=0;int		*simauts;//int	uninf, out=0, uninfcompat, posscompat, auts, ttlcompat, comptype=0;long  	**simatrix, **ranges;long	**tree, **vtree;//long	**dbtree;double	*sstrcmp;unsigned long **compmat;unsigned long	*charcomps;//double	*genstratcomp, *strstratcomp, *hierstratcmp, *hierstratprp,*scha,*sih;double	*genstratcomp, *strstratcomp, *hierstratcmp, *hierstratprp;double	*supstratcomp, *hierstratana, *hierstratbud;double	*compdivSIN, *comphierSIN, *stratdivSIN, *strathierSIN;double	*propend2cp, *avecompscp, *avecompsin, *avecompdif;double	*simmary;double	cp;double	tiegs=0.0f, tiess=0.0f, tiehs=0.0f, tiehp=0.0f, tiescha=0.0f, tiesih=0.0f, tieavecscp=0.0f, tieavecsin=0.0f, tieavecdif=0.0f;double	tiexs=0.0f, tieha=0.0f, tiehb=0.0f, tiesincd=0.0f, tiesinch=0.0f, tiesinsd=0.0f, tiesinsh=0.0f, tiesind2=0.0f;//double	**genrstcmpcor, **strcstcmpcor, **hierstcmpcor;//long	**histories;long	secs;char	outfile[120];FILE	*output, *debugoutput;if (RUNS%2==0)	++RUNS;			/* it's easier to use an odd number....	*/time(&secs);srand((unsigned int) secs);genstratcomp=dvector(RUNS);		/* tallies sstrcomp[5], for simmary[0,1]				*/strstratcomp=dvector(RUNS);		/* tallies sstrcomp[6], for simmary[2,3]				*/	supstratcomp=dvector(RUNS);		/* tallies sstrcomp[7], for simmary[8,9]				*/hierstratcmp=dvector(RUNS);		/* tallies sstrcomp[8], for simmary[4,5]				*/hierstratprp=dvector(RUNS);		/* tallies sstrcomp[8]/sstrcomp[5], for simmary[6,7]	*/hierstratana=dvector(RUNS);		/* tallies sstrcomp[9], for simmary[10,11]				*/hierstratbud=dvector(RUNS);		/* tallies sstrcomp[10], for simmary[12,13]				*/compdivSIN=dvector(RUNS);		/* tallies sstrcomp[11], for simmary[14,15]				*/comphierSIN=dvector(RUNS);		/* tallies sstrcomp[12], for simmary[16,17]				*/stratdivSIN=dvector(RUNS);		/* tallies sstrcomp[13], for simmary[18,19]				*/strathierSIN=dvector(RUNS);		/* tallies sstrcomp[14], for simmary[20,21]				*/propend2cp=dvector(RUNS);		/* tallies sstrcomp[15], for simmary[22,23]				*/avecompscp=dvector(RUNS);		/* tallies for simmary[24,25]							*/avecompsin=dvector(RUNS);		/* tallies for simmary[26.27]							*/avecompdif=dvector(RUNS);		/* tallies for simmary[28,29]							*/ranges=lmatrix(notu,2);simatrix=lmatrix(notu,nchars);simmary=dvector(30);d=0;							/* for debugging	*/for (r=d; r<RUNS; ++r)	{	/* 2011-03-28: BLOWOUT at r=5	*/	genstratcomp[r]=strstratcomp[r]=hierstratcmp[r]=hierstratprp[r]=0.0f;	supstratcomp[r]=hierstratana[r]=hierstratbud[r]=compdivSIN[r]=comphierSIN[r]=stratdivSIN[r]=strathierSIN[r]=propend2cp[r]=avecompscp[r]=avecompsin[r]=0.0f;	for (s=0; s<notu; ++s)	{		for (c=0; c<nchars; ++c)	{			if (omatrix[s][c]==UNKNOWN)				simatrix[s][c]=UNKNOWN;			else if (omatrix[s][c]==INAP)				simatrix[s][c]=INAP;			else				simatrix[s][c]=0;			}		}	if (debug==1)	{		srand((unsigned int) (r+1)*notu*nchars);		}		/* 	trees[notu-1]: branch length of otus			trees[notu]:   branch length of clades		trees[notu+1]: first appearances of otus		trees[notu+2]: last appearances of otus	**********************************************/	tree=evolvetree(notu,mbl,1);	clades=cladecountbytaxa(tree,notu);	/* pull range data out of back of tree matrix	*/	for (s=0; s<notu; ++s)	{		ranges[s][0]=tree[notu+1][s];		ranges[s][1]=tree[notu+2][s];		}	cleancladerangedata(ranges,notu);	vtree=VennTreePlus(tree,clades,notu,notu);	/* evolve character matrix, simatrix	*///	long **evolvetocompat(long **tree, int tcomp, int notu, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int *depend, int comptype, int UNKNOWN, int INAP)//	simatrix=evolvetocompat(tree,empcompat,notu,matrix,nchars,nstates,ctype,bias,chmax,depend,comptype,UNKNOWN,INAP);	simatrix=evolvetocompatibility(vtree, compat, notu, clades, simatrix, nchars, nstates, ctype, bias, maxch, depend, 0, UNKNOWN, INAP);		if (d>0)	{		debugoutput=fopen("SuspectMatrix.txt","w");		for (s=0; s<notu; ++s)	{			for (c=0; c<nchars; ++c)	{				if (simatrix[s][c]==UNKNOWN)	fprintf(debugoutput,"?\t");				else if (simatrix[s][c]==INAP)	fprintf(debugoutput,"—\t");				else							fprintf(debugoutput,"%d\t",simatrix[s][c]);				}			fprintf(debugoutput,"%d\t%d\n",ranges[s][0],ranges[s][1]);			}		fclose(debugoutput);		}//	simatrix=evolvematrix(vtree, notu, clades, simatrix, nchars, nstates, ctype, bias, maxch, 2*nchars, UNKNOWN, INAP);/*		sstates=numberstates(simatrix,notu,nchars,UNKNOWN,INAP);	*///	compat=nu_comp(nstates, notu, simatrix, ctype, nchars, 0, 0, UNKNOWN, INAP);	compmat=compatible(nstates,notu,simatrix,ctype,nchars,0,0,UNKNOWN,INAP);	charcomps=char_comp(nstates,notu,simatrix,ctype,nchars,0,0,UNKNOWN,INAP);	simauts=autapomorphies(simatrix,nstates,notu,nchars,UNKNOWN,INAP);	/* get the minimum number of derived states	*//*	for (c1=0; c1<nchars; ++c1)	++examples[compmat[c1][c1]];	*/	cp=0.0f;	for (c1=0; c1<(nchars-1); ++c1)	{		/* reinstated 2012-02-29	*/		while ((simauts[c1]<2 || simauts[c1]>(notu-2)) && c1<(nchars-1))	++c1;		if (c1>=nchars)		break;		for (c2=(c1+1); c2<nchars; ++c2)	{			/* reinstated 2012-02-29	*/			while ((simauts[c2]<2 || simauts[c2]>(notu-2)) && c2<(nchars-1))	++c2;			if (c2>=nchars)		break;			if (compmat[c1][c2]==1)	{				/*sstrcmp=stratcompatfull(ranges, simatrix, nstates, c1, c2, notu, UNKNOWN, INAP);	*/				/* 2011-10-14: changed to "plus"													*/				sstrcmp=stratcompatfullplusplus(ranges, simatrix, nstates, charcomps, c1, c2, notu, UNKNOWN, INAP);				/* rewrite this so that we simply take the median values from sstrcomp (simulated strat comp) for expectations	*/				/* and the distribution for p-values when examining the real results											*/				cp+=sstrcmp[4];										/* compatible comparisons						*/				genstratcomp[r]+=sstrcmp[5];						/* general stratigraphic consistency			*/				strstratcomp[r]+=sstrcmp[6];						/* strict stratigraphic consistency				*/				supstratcomp[r]+=sstrcmp[7];						/* superstrict stratigraphic consistency		*/				hierstratcmp[r]+=sstrcmp[8];						/* hierarchical stratigraphic consistency		*/				hierstratana[r]+=sstrcmp[9];						/* HSC consistent with anagenesis				*/				hierstratbud[r]+=sstrcmp[10];						/* HSC consistent with budding					*/				compdivSIN[r]+=sstrcmp[11];							/* compatibility-supported divergent SIN		*/				comphierSIN[r]+=sstrcmp[12];						/* compatibility-supported hierarchical SIN		*/				stratdivSIN[r]+=sstrcmp[13];						/* stratigraphy-supported divergent SIN			*/				strathierSIN[r]+=sstrcmp[14];						/* stratigraphy-supported hierarchical SIN		*/				propend2cp[r]+=sstrcmp[15];							/* relative diversity of younger SIN end pair	*/				if (sstrcmp[5]>0)				avecompscp[r]+=(((double) charcomps[c1])+((double) charcomps[c2]))/2;				if (sstrcmp[5]<sstrcmp[4])		avecompsin[r]+=(((double) charcomps[c1])+((double) charcomps[c2]))/2;/*				scha[r]+=sstrcmp[9];						/* hierarchical compatible pairs consistent with anagenesis			2011-10-14	*//*				sih[r]+=sstrcmp[11];						/* stratigraphically incompatible pairs consistent with hierarchy	2011-10-14	*/				/* 2011-10-14: tally compatibilities of stratigraphically compatible & incompatible character pairs	*//*				if (sstrcmp[5]==1)	{					avecompscp[r]+=((double) (charcomps[c1]+charcomps[c2]))/2;					scgw+=1.0;													/* this will tally characters, not state pairs						*//*					}				else	{					avecompsin[r]+=((double) (charcomps[c1]+charcomps[c2]))/2;					sci+=1.0;					}					/* this will give the proportion of compatibilities that are stratigraphically compatible by compatibility	*//*				genrstcmpcor[compmat[c1][c1]]+=sstrcmp[5];			/* general stratigraphic consistency		*//*				strcstcmpcor[compmat[c1][c1]]+=sstrcmp[6];			/* strict stratigraphic consistency			*//*				hierstcmpcor[compmat[c1][c1]]+=sstrcmp[8];			/* hierarchical stratigraphic consistency	*//*				genrstcmpcor[compmat[c2][c2]]+=sstrcmp[5];			/* general stratigraphic consistency		*//*				strcstcmpcor[compmat[c2][c2]]+=sstrcmp[6];			/* strict stratigraphic consistency			*//*				hierstcmpcor[compmat[c2][c2]]+=sstrcmp[8];			/* hierarchical stratigraphic consistency	*/				free_dvector(sstrcmp);				}			}		}		/* get proportions of hierarchical stratigraphic characters relative to total								*/	/* Also, get proportions of particular types of hierarchical stratigraphic characters						*/	hierstratprp[r]+=(hierstratcmp[r]/genstratcomp[r]);						/* proportional hierarchical stratigraphic compatibility	*/	/* if there is no hierarchical compatibility, then modify the routine: 2011-11-01	*/	if (hierstratcmp[r]>0)	{		hierstratana[r]/=hierstratcmp[r];										/* proportion of HSC matching anagenesis					*/		hierstratbud[r]/=hierstratcmp[r];										/* proportion of HSC demanding budding						*/		}	else	{		++hierflop;																/* tally runs in which there was no hierarchical compatibility	*/		hierstratana[r]=hierstratbud[r]=MAXRAND;		}	/* get average compatibilities of stratigraphically compatible and incompatible character pairs					*/	avecompscp[r]/=genstratcomp[r];											/* added 2011-10-14	*/	avecompsin[r]/=(cp-genstratcomp[r]);									/* added 2011-10-14	*/	avecompdif[r]=avecompscp[r]-avecompsin[r];								/* added 2011-11-01: because I sort these later, this is otherwise lost */	/* get proportion of SIN character pairs matching divergent or hierarchical patterns				*/	compdivSIN[r]/=(cp-genstratcomp[r]);									/* compatibility-supported divergent SIN		*/	comphierSIN[r]/=(cp-genstratcomp[r]);									/* compatibility-supported hierarchical SIN		*/	stratdivSIN[r]/=(cp-genstratcomp[r]);									/* stratigraphy-supported divergent SIN			*/	strathierSIN[r]/=(cp-genstratcomp[r]);									/* stratigraphy-supported hierarchical SIN		*/	propend2cp[r]/=(cp-genstratcomp[r]);									/* relative diversity of younger SIN end pair	*/	/* cp will vary a little from simulation to simulation because it is based on state numbers, so report things in proportions	*/	genstratcomp[r]/=((double) cp);											/* general stratigraphic consistency						*/	strstratcomp[r]/=((double) cp);											/* strict stratigraphic consistency							*/	supstratcomp[r]/=((double) cp);											/* super strict stratigraphic consistency					*/	hierstratcmp[r]/=((double) cp);											/* hierarchical stratigraphic consistency					*/	/* tally cases where simulated values are lower than observed values		*/	if (genstratcomp[r]<summary[0])		simmary[0]+=(1/((double) RUNS));	if (strstratcomp[r]<summary[1])		simmary[2]+=(1/((double) RUNS));	if (supstratcomp[r]<summary[2])		simmary[4]+=(1/((double) RUNS));	if (hierstratcmp[r]<summary[3])		simmary[6]+=(1/((double) RUNS));	if (hierstratprp[r]<summary[4])		simmary[8]+=(1/((double) RUNS));	if (hierstratana[r]<summary[5])		simmary[10]+=(1/((double) RUNS));	if (hierstratbud[r]<summary[6])		simmary[12]+=(1/((double) RUNS));	if (compdivSIN[r]<summary[7])		simmary[14]+=(1/((double) RUNS));	if (comphierSIN[r]<summary[8])		simmary[16]+=(1/((double) RUNS));	if (stratdivSIN[r]<summary[9])		simmary[18]+=(1/((double) RUNS));	if (strathierSIN[r]<summary[10])	simmary[20]+=(1/((double) RUNS));	if (propend2cp[r]<summary[11])		simmary[22]+=(1/((double) RUNS));	if (avecompscp[r]<summary[12])		simmary[24]+=(1/((double) RUNS));					/* added 2011-10-14	*/	if (avecompsin[r]<summary[13])		simmary[26]+=(1/((double) RUNS));					/* added 2011-10-14	*/	if (avecompdif[r]<(summary[12]-summary[13]))										simmary[27]+=(1/((double) RUNS));					/* added 2011-11-01: because I sort these later, this is otherwise lost */	/* tally cases where simulated values are exactly equal to observed values	*/	if (genstratcomp[r]==summary[0])	tiegs+=(1/((double) RUNS));	if (strstratcomp[r]==summary[1])	tiess+=(1/((double) RUNS));	if (supstratcomp[r]==summary[2])	tiexs+=(1/((double) RUNS));	if (hierstratcmp[r]==summary[3])	tiehs+=(1/((double) RUNS));	if (hierstratprp[r]==summary[4])	tiehp+=(1/((double) RUNS));	if (hierstratana[r]==summary[5])	tieha+=(1/((double) RUNS));	if (hierstratbud[r]==summary[6])	tiehb+=(1/((double) RUNS));	if (compdivSIN[r]==summary[7])		tiesincd+=(1/((double) RUNS));	if (comphierSIN[r]==summary[8])		tiesinch+=(1/((double) RUNS));	if (stratdivSIN[r]==summary[9])		tiesinsd+=(1/((double) RUNS));	if (strathierSIN[r]==summary[10])	tiesinsh+=(1/((double) RUNS));	if (propend2cp[r]==summary[11])		tiesind2+=(1/((double) RUNS));	if (avecompscp[r]==summary[12])		tieavecscp+=(1/((double) RUNS));					/* added 2011-10-14	*/	if (avecompsin[r]==summary[13])		tieavecsin+=(1/((double) RUNS));					/* added 2011-10-14	*/	if (avecompdif[r]==(summary[12]-summary[13]))										tieavecdif+=(1/((double) RUNS));					/* added 2011-11-01: because I sort these later, this is otherwise lost */	if ((r%10)==9)	{//			printf("Doing Rate = %5.4f",mbl[2]);		if (r>10)	{			printf("\b\b\b\b\b");					/* clear ", Tree %d"		*/			}		if (r>18 && r<100) 			printf("\b\b\b");		else if (r>99 && r<1000)	printf("\b\b\b\b");		else if (r>999)				printf("\b\b\b\b\b");		printf("Tree %d\n", r+1);		}		free_ulmatrix(compmat,nchars,nchars);	free_lmatrix(vtree,clades+1,notu);	free_lmatrix(tree,clades+3,notu);	}/* sort for medians	*/genstratcomp=dshellsort_inc(genstratcomp,RUNS); 	/* 0:  sort stratigraphic compatiblity						*/strstratcomp=dshellsort_inc(strstratcomp,RUNS); 	/* 1:  sort strict stratigraphic compatiblity				*/supstratcomp=dshellsort_inc(supstratcomp,RUNS);		/* 2:  sort super strict stratigraphic compatibility		*/hierstratcmp=dshellsort_inc(hierstratcmp,RUNS);		/* 3:  sort hierarchical stratigraphic compatiblity (HSC)	*/hierstratprp=dshellsort_inc(hierstratprp,RUNS);		/* 4:  sort proportion HSC									*/hierstratana=dshellsort_inc(hierstratana,RUNS);		/* 5:  sort HSC consistent with anagenesis					*/hierstratbud=dshellsort_inc(hierstratbud,RUNS);		/* 6:  sort HSC demanding budding							*/compdivSIN=dshellsort_inc(compdivSIN,RUNS);			/* 7:  sort compatibility suggests divergent SIN			*/comphierSIN=dshellsort_inc(comphierSIN,RUNS);		/* 8:  sort compatibility suggests hierarchical SIN			*/stratdivSIN=dshellsort_inc(stratdivSIN,RUNS);		/* 9:  sort stratigraphy suggests divergent SIN				*/strathierSIN=dshellsort_inc(strathierSIN,RUNS);		/* 10: sort stratigraphy suggests hierarchical SIN			*/propend2cp=dshellsort_inc(propend2cp,RUNS);			/* 11: sort relative diversity of derived end pair			*/avecompscp=dshellsort_inc(avecompscp,RUNS);			/* 12: sort average compatibilities of SC character pairs	*/avecompsin=dshellsort_inc(avecompsin,RUNS);			/* 13: sort average compatibilities of SIN character pairs	*/avecompdif=dshellsort_inc(avecompdif,RUNS);			/* 14: sort average differences between SC & SIN pairs		*//* get alpha values: if observed values are "low" then we want p[observed or lower]: so, add ties to total	*//* for "high" values, we do not need to do this: 1-simmary gives p[observed or more extreme] as we tallied only sims less than observed	*//* we want the probability of the observed OR MORE EXTREME; because we tallied every time the observed was lower than what we saw,		we don't need to do this when p> 0.5	*/if (simmary[0]<0.5)		simmary[0]+=tiegs;			/* general stratigraphic compatibility	*/if (simmary[2]<0.5)		simmary[2]+=tiess;			/* strict stratigraphic compatibility	*/if (simmary[4]<0.5)		simmary[4]+=tiexs;if (simmary[6]<0.5)		simmary[6]+=tiehs;if (simmary[8]<0.5)		simmary[8]+=tiehp;if (simmary[10]<0.5)	simmary[10]+=tieha;if (simmary[12]<0.5)	simmary[12]+=tiehb;if (simmary[14]<0.5)	simmary[14]+=tiesincd;if (simmary[16]<0.5)	simmary[16]+=tiesinch;if (simmary[18]<0.5)	simmary[18]+=tiesinsd;if (simmary[20]<0.5)	simmary[20]+=tiesinsh;if (simmary[22]<0.5)	simmary[22]+=tiesind2;if (simmary[24]<0.5)	simmary[24]+=tieavecscp;if (simmary[26]<0.5)	simmary[26]+=tieavecsin;if (simmary[28]<0.5)	simmary[28]+=tieavecsin;/* adjust for runs with no hierarchical compatibility	*/simmary[10]*=(((double) (RUNS-hierflop))/((double) RUNS));		/* adjust significance of anagenetic hierarchical compatibility	*/simmary[12]*=(((double) (RUNS-hierflop))/((double) RUNS));		/* adjust significance of budding hierarchical compatibility	*//* tally median expected stratigraphic compatibilities	*/simmary[1]=genstratcomp[RUNS/2];simmary[3]=strstratcomp[RUNS/2];simmary[5]=supstratcomp[RUNS/2];simmary[7]=hierstratcmp[RUNS/2];simmary[9]=hierstratprp[RUNS/2];simmary[11]=hierstratana[(RUNS-hierflop)/2];			/* accommodate runs with no hierarchical compatibility	*/simmary[13]=hierstratbud[(RUNS-hierflop)/2];			/* accommodate runs with no hierarchical compatibility	*/simmary[15]=compdivSIN[RUNS/2];simmary[17]=comphierSIN[RUNS/2];simmary[19]=stratdivSIN[RUNS/2];simmary[21]=strathierSIN[RUNS/2];simmary[23]=propend2cp[RUNS/2];simmary[25]=avecompscp[RUNS/2];simmary[27]=avecompsin[RUNS/2];simmary[29]=avecompdif[RUNS/2];/* return output to here!	*//* TEMPORARY!  UNTIL I'VE DEBUGGED THIS.....	*/keep=1;//keep=0;//printf("Enter '1' if you want output for this taxon: ");//scanf("%i",&keep);	if (keep==1)	{	strcpy(outfile,taxonname);	strcat(outfile,"_");	strcat(outfile,citation);	strcat(outfile,"_Expectations");	if (mbl[4]==0)	strcat(outfile,"_Bud.xls");	else			strcat(outfile,"_Bif.xls");		output=fopen(outfile,"w");	fprintf(output,"Run");	fprintf(output,"\tGeneral Stratigraphic Compatibility (SC)");	fprintf(output,"\tStrict SC");	fprintf(output,"\tSuper Strict SC");	fprintf(output,"\tHierarchical SC");	fprintf(output,"\tProportional HSC");	fprintf(output,"\tAnagenetic HSC");	fprintf(output,"\tBudding HSC");	fprintf(output,"\tDivergent SIN (Comp)");	fprintf(output,"\tHierarchical SIN (Comp)");	fprintf(output,"\tDivergent SIN (Strat)");	fprintf(output,"\tHierarchical SIN (Strat)");	fprintf(output,"\tProp Diversity Younger SIN Pair");	fprintf(output,"\tµ Character Compabibility (SC)");					/* added 2011-10-14	*/	fprintf(output,"\tµ Character Compabibility (SIN)");					/* added 2011-10-14	*/	fprintf(output,"\tµ Compabibility Diff (SC-SIN)\n");				/* added 2011-11-01	*/		for (r=0; r<RUNS; ++r)	{		fprintf(output,"%d",r+1);		fprintf(output,"\t%4.3f",genstratcomp[r]);		fprintf(output,"\t%4.3f",strstratcomp[r]);		fprintf(output,"\t%4.3f",supstratcomp[r]);		fprintf(output,"\t%4.3f",hierstratcmp[r]);		fprintf(output,"\t%4.3f",hierstratprp[r]);		if (hierstratana[r]<MAXRAND)	fprintf(output,"\t%4.3f",hierstratana[r]);		else							fprintf(output,"\t•");		if (hierstratbud[r]<MAXRAND)	fprintf(output,"\t%4.3f",hierstratbud[r]);		else							fprintf(output,"\t•");		fprintf(output,"\t%4.3f",compdivSIN[r]);		fprintf(output,"\t%4.3f",comphierSIN[r]);		fprintf(output,"\t%4.3f",stratdivSIN[r]);		fprintf(output,"\t%4.3f",strathierSIN[r]);		fprintf(output,"\t%4.3f",propend2cp[r]);		fprintf(output,"\t%4.3f",avecompscp[r]);					/* added 2011-10-14	*/		fprintf(output,"\t%4.3f",avecompsin[r]);					/* added 2011-10-14	*/		fprintf(output,"\t%4.3f\n",avecompdif[r]);					/* added 2011-11-01	*/		}	fclose(output);	}free_dvector(genstratcomp);free_dvector(strstratcomp);free_dvector(supstratcomp);		/* tallies sstrcomp[7], for simmary[8,9]				*/free_dvector(hierstratcmp);free_dvector(hierstratprp);free_dvector(hierstratana);		/* tallies sstrcomp[9], for simmary[10,11]				*/free_dvector(hierstratbud);		/* tallies sstrcomp[10], for simmary[12,13]				*/free_dvector(compdivSIN);		/* tallies sstrcomp[11], for simmary[14,15]				*/free_dvector(comphierSIN);		/* tallies sstrcomp[12], for simmary[16,17]				*/free_dvector(stratdivSIN);		/* tallies sstrcomp[13], for simmary[18,19]				*/free_dvector(strathierSIN);		/* tallies sstrcomp[14], for simmary[20,21]				*/free_dvector(propend2cp);		/* tallies sstrcomp[15], for simmary[22,23]				*/free_dvector(avecompscp);free_dvector(avecompsin);free_dvector(avecompdif);free_lmatrix(ranges,notu,2);return simmary;}