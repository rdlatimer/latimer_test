#define MonteCarloPhylogenyFunctions#include "MonteCarloPhylogenyFunctions.h"#include "CompatibilityFunctions.h"#include "matrixanalysis.h"#include "matrixchange.h"#include "matrixreading.h"#include "memory.h"#include "minmax.h"#include "Probability.h"#include "TreeRead.h"#include "HistoricalDiversity.h"#include <stdlib.h>#include <stdio.h>#include <time.h>#include <math.h>#include <string.h>/* evolvetree - Evolves a paleontological tree, with notu taxa sampled over time/* Requires:	notu - # of sampled taxa/*				mbl - simulation parameters where	 				mbl[0] (MU) - Speciation rate/*					mbl[1] (LAMBDA) - Extinction rate/*					mbl[2] (FR) - Preservation rate/*					mbl[3] (VR) - Variance in preservation rate				FOSSILS - (1) fossils sampled, (0) no fossils sampled/*				SPECIATION - (1) bifurcation (0) budding cladogenesis/* Major Rewrite of Sampled Tree Construction 02/2003/* Rewritten to use real numbers from a single array (mbl)******************************************************************************************************/long **evolvetree(int SOTU, double *mbl, int FOSSILS){long	attempts, base=100000, MU, LAMBDA,FR, VR, SPECIATION;int		a, b, c, d, ee, charstandard, ch, latest, MaxDiv=6, chucks, brats;int		clade, otu, otu2, htu, sampled, initdiv, standingdiv, cumulativediv, stage, newby;int		species, anc, speciate, extinct, change, find, testnode, plesion, found0, oldfirst;int		reboot;int		sp, sp2, nodes, found;int		MaxTaxa, MaxStanding;int		*available, *f1, **forefathers, *ancestor;int		*extant, *observed, *obsbl, *commonanc, *bl;int		*fa, *la, *DBas;double	*tor, *tex;int		**PDMat, **CAMat;long	**tree;double	v, x, y, MOD;MU=base*mbl[0];LAMBDA=base*mbl[1];FR=base*mbl[2];VR=base*mbl[3];SPECIATION=mbl[4];v=expectedpropsampled(mbl[1],mbl[2]);v=1/v;MaxTaxa=10*v*SOTU;//if (FOSSILS=1)	MaxStanding=2*SOTU;//else			MaxStanding=3*SOTU;MaxStanding=3*SOTU;/* arrays for observed taxa - set to SOTU*/observed=ivector(SOTU);obsbl=ivector(SOTU);commonanc=ivector(SOTU);fa=ivector(SOTU);la=ivector(SOTU);DBas=ivector(SOTU);/* array for all elements of the tree */bl=ivector(2*SOTU);/* array for standing taxa - set to MaxStanding*/extant = ivector(MaxStanding+1);/* arrays for sampled and obsbl taxa - set to MaxTaxa */ancestor=ivector(MaxTaxa);	/* ancestor of each taxon */available=ivector(MaxTaxa);f1=ivector(MaxTaxa);		/* number of descendants for each taxon */tor=dvector(MaxTaxa);		/* true origination - this is a real number */tex=dvector(MaxTaxa);		/* true extinction - this is a real number */reboot=0;a=b=c=d=ee=anc=0;charstandard = 1; /*charbase/100;*/sp = ch = change = find = 0;clearivector(observed,SOTU,-1);clearivector(obsbl,SOTU,-1);clearivector(ancestor,MaxTaxa,-1);clearivector(extant,MaxStanding+1,-1);latest = -1;attempts = initdiv = standingdiv = cumulativediv = stage = extant[0] = sampled = 0;while (sampled < SOTU)	{	initdiv = standingdiv+1;	for (sp=0; (sp<=standingdiv && cumulativediv<MaxTaxa); ++sp)	{	/********************************************/	/*			Does Lineage Speciate?			*/	/********************************************/		if (sp<0 || sp>MaxStanding)	{			printf("ERROR 108: %d is the wrong number of species!\n", sp);			exit(0);			}		species = extant[sp];		tex[species]=stage+1;				if (f1[species]<MaxDiv)	speciate = (((unsigned int) rand())%base);		else					speciate = base;		MOD=MU;		if (sp>=initdiv)			MOD=((stage+1)-tor[species])*MOD;				if (SPECIATION==1)	ee=2;		else				ee=1;		if (speciate <= MOD && (standingdiv<(MaxStanding-ee)))		{			brats=1;			if (SPECIATION==1)	brats=2;			else	{				y=LAMBDA;				y=y/base;				if (tor[species]>stage)	v=(stage+1)-tor[species];				else					v=1;				x=Poisson(y, v, 2);				if (speciate<x*base)	brats=2;				}			/* go through each descendant */			for (a=0; a<brats; ++a)	{				++standingdiv;				++cumulativediv;				extant[standingdiv] = cumulativediv;				if (cumulativediv > MaxTaxa)	{					printf("ERROR Evolve 137 - In replication XXX");					printf(", more than %3d species were generated.  \n",MaxTaxa);					sampled=SOTU;					exit(0);						}				if (standingdiv<0 || standingdiv>MaxStanding)	{					printf("ERROR 144:  Standing diversity too high at %2d\n",standingdiv);					sampled=SOTU;					exit(0);						}							if (cumulativediv<0 || cumulativediv>=MaxTaxa || species<0 || species>=MaxTaxa)	{					printf("ERROR 148 - ancestor index out of range at %d and %d\n",species,cumulativediv);					sampled=SOTU;					exit(0);						}				ancestor[cumulativediv] = species;				anc = species;				++f1[anc];						/*******************************************************************************/		/* Ancestors become pseudo-extinct at bifurcation if that is what is happening */		/*******************************************************************************/				if (SPECIATION==1 && a==1)	{					tex[anc]=tor[cumulativediv]=tor[cumulativediv-1];					}				else	{					/* to must be after ancestor's to */					if (tor[anc]>stage)	v=((stage+1)-tor[anc])*base;					else				v=base;					b=v;					y = (((unsigned int) rand())%b);					if (tor[anc]<=stage)	tor[cumulativediv]=stage+(y/base);					else					tor[cumulativediv]=tor[anc]+(y/base);					}				}			}		if (FOSSILS==0 && standingdiv>=SOTU-1)	sp = initdiv;	/* quit if enough taxa are alive */		}	/****  End Speciation Round ****/ 				if (FOSSILS==1)	{		/********************************************/		/*				 Do Sampling				*/		/*  Separated from Speciation Loop 1/3/97   */		/********************************************/		if (sampled < SOTU)	{			for (sp=0; sp<=standingdiv; ++sp)	{				species = extant[sp];								/* Raw Species Number */				find = (((unsigned int) rand())%base)+1;//				if (f1[species]>=3 || cumulativediv>=(3*MaxStanding))	find = 0;				y=FR;				x=stage;				if (tor[species]>x)			MOD=(tex[species]-tor[species])*y;				else if (tor[species]<x)		MOD=(tex[species]-x)*y;								if (find <= MOD)	{					newby = 0;					/** First sampled species goes straight into the array **/					if (sampled==0)	{						observed[sampled]=species;						fa[sampled]=la[sampled]=stage;						++sampled;						}					/** Test whether a sampled species had gone unsampled **/					else	{						for (otu = 0; otu < sampled;  ++otu)	{							if (observed[otu] == species)	{								newby = 1;								la[otu]=stage;								otu = sampled;								}							}						if (newby == 0 && sampled < SOTU)	{							/* sort species as you go */							a=sampled-1;							while (observed[a]>species && a>=0)	{								observed[a+1]=observed[a];								fa[a+1]=fa[a];								la[a+1]=la[a];								--a;								}							observed[a+1] = species;							fa[a+1]=la[a+1]=stage;							++sampled;							if (sampled<0 || sampled>SOTU)	{								printf("ERROR 189: You somehow sampled %d\n",sampled);								exit(0);								}							if (sampled==SOTU)		sp = standingdiv;							}						}					latest = observed[sampled-1];					}	/* End Tallying of Sampled Horizon	*/				}	/*  End Sampling for Each Horizon	*/			}		}			else {		sampled = standingdiv;		/* if there are no fossils, "present" is when									   SOTU taxa evolve */		if (sampled==SOTU-1)	for (sp=0; sp<SOTU; ++sp)	observed[sp]=extant[sp];		}	if (sampled>=SOTU)	break;	/* don't bother with the rest if done */				/********************************************/		/*				Do Extinction				*/		/********************************************/	for (a=standingdiv; a>=0; --a)	{		/* sp = extant but not nec. sampled species */		extinct = (((unsigned int) rand())%base);				sp=extant[a];		y=LAMBDA;		x=stage;		/* take into account species that were there only part of the time */		if (tor[sp]>x)			MOD=(tex[sp]-tor[sp])*y;		else if (tor[sp]<x)		MOD=(tex[sp]-x)*y;		if (tex[sp]<(stage+1))	{			extinct=0;			MOD=base;			}//		if (f1[extant[sp]]>=3)	extinct = 0;		if (extinct < MOD)	{			/*  REMOVE SPECIES FROM EXTANT LIST */			for (b = a; b <= standingdiv; ++b)	extant[b] = extant[b+1];			extant[standingdiv] = -1;			--standingdiv;			if (sp<-1)	{				printf("ERROR 224 - you have more extinctions than species\n");				exit(0);				}			}		}	/*  End Extinction Simulation */	initdiv=standingdiv;				/****** REBOOT ROUTINE ******/	if (standingdiv < 0 || (cumulativediv>=MaxTaxa && sampled < SOTU))	{		latest = -1;		for (sp=0; sp<SOTU; ++sp)	{			extant[sp]=observed[sp]=ancestor[sp]=-1;			tor[sp]=fa[sp]=la[sp]=f1[sp]=0;			}		standingdiv = initdiv = cumulativediv = extant[0] = sampled = 0;		stage = 0;		++attempts;/*		if ((attempts%5)==0)	printf ("%2d tries and counting.\n",attempts); */		}				/** Reboot simulation **/	else	{		if (sampled < SOTU)	++stage;		/*  All SOTU species found	*/		else if (FOSSILS==0 && cumulativediv==((2*SOTU)-2))	{			for (sp=0; sp<=standingdiv; ++sp)		observed[sp] = extant[sp];			sampled = SOTU;			reboot=1;			}		/* if species index is out of range, then reboot the whole thing */		}	}MaxDiv=1+maxiarray(f1,cumulativediv);/* tree matrix - rows 0...(SOTU-1) rows are for possible nodes	*//*		row SOTU-1 is for species branch lengths				*//*		row SOTU   is for nodal branch lengths					*//*		row SOTU+1 is for species FAs							*//*		row SOTU+2 is for species LAs							*//*		the first cell of rows 0É(SOTU-1) give # branches		*//*			(i.e., 2 for bifurcation w. no sampled ancestor)	*/tree=lmatrix(SOTU+3,SOTU);clearlmatrix(tree,SOTU+3,SOTU,-1);for (a=cumulativediv+1; a<MaxTaxa; ++a)	f1[a]=ancestor[a]=0;if (observed[0]==-1)	{	printf("Taxa lost by line 257\a\n");	exit(0);	}/*********************************************************************************//*								Store True Phylogeny							 *//*********************************************************************************//**** LIST ANCESTORS OF EACH OBSERVED SPECIES ****/chucks=0;ancestor[0]=-1;/* find the distance from the base for each species */for (otu=0; otu<SOTU; ++otu)	{	sp=observed[otu];	anc=ancestor[sp];	if (anc>=0)		DBas[otu]=1;	for (a=1; anc>=0; ++a)	{		anc=ancestor[anc];		++DBas[otu];		}	}/* count the maximum number of ancestors */chucks=maxiarray(DBas,otu);/* list all of the ancestors for each species */forefathers=imatrix(SOTU,chucks+1);clearimatrix(forefathers,SOTU,chucks+1,-1);ancestor[0]=-1;for (otu=0; otu<SOTU; ++otu)	{	forefathers[otu][0]=sp=observed[otu];	anc=ancestor[sp];	for (a=1; anc>=0; ++a)	{		forefathers[otu][a]=anc;		anc=ancestor[anc];		}	}/* list the unsampled ancestors of each species *//* also, tally species with sampled descendants */free_ivector(f1);f1=ivector(SOTU);	/* 0: no sampled descendants; 1: 1+ sampled descendants */for (otu=0; otu<SOTU; ++otu)	{	obsbl[otu]=1;	found=0;	for (a=1; a<DBas[otu]; ++a)	{		anc=forefathers[otu][a];		for (b=otu-1; b>=0; --b)	{			if (observed[b]==anc)	{				found=1;				f1[b]=1;				/* end loops */				b=0;				a=DBas[otu];				}			}		if (found==0)	++obsbl[otu];		}	}/* create a matrix of branch distances between taxa *//* this gives distance to common ancestor, so the matrix is asymmetrical */PDMat=imatrix(otu,otu);CAMat=imatrix(otu,otu);for (otu=SOTU-1; otu>0; --otu)	{	for (otu2=otu-1; otu2>=0; --otu2)	{		for (a=0; a<=DBas[otu]; ++a)	{			sp=forefathers[otu][a];			for (b=0; b<=DBas[otu2]; ++b)	{				sp2=forefathers[otu2][b];				if (sp==sp2)	{					PDMat[otu][otu2]=a+1;					PDMat[otu2][otu]=b+1;					CAMat[otu][otu2]=CAMat[otu2][otu]=sp;					/* end loop */					b=DBas[otu2];					a=DBas[otu];					}				/* end loop if forefather[otu][a] cannot match forefather[otu2][any] */				else if (sp>sp2)	b=DBas[otu2];				}			}		}	}/* create a tree *//* keep track of common ancestors of each clade */nodes=found0=0;for (otu=SOTU-1; otu>0; --otu)	{	d=chucks;	for (otu2=otu-1; otu2>=0; --otu2)	{		if (PDMat[otu][otu2]<d)	{			d=PDMat[otu][otu2];			}		}	for (otu2=0; otu2<otu; ++otu2)	{		if (PDMat[otu][otu2]==d)	{			anc=CAMat[otu][otu2];			found=-1;			for (a=0; a<nodes; ++a)	{				/* existing nodes found */				if (commonanc[a]==CAMat[otu][otu2])	{					found=0;					/* check to see if the species already is in the nodes */					for (b=1; b<=tree[a][0]; ++b)	{						if (otu2==tree[a][b])		found=1;						}					if (found==0)	{						for (b=1; b<=tree[a][0]; ++b)	{							if (otu==tree[a][b])	found=2;							}						}					/* if neither species already found */					if (found==0)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					/* if older species already found */					else if (found==1)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						}					/* if younger species already found */					else if (found==2)	{						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					a=nodes+1;					otu2=otu;					}				}	/* end search for previously found node */			/* new nodes found */			if (found==-1)	{				commonanc[nodes]=CAMat[otu][otu2];				tree[nodes][0]=2;				tree[nodes][1]=otu2;				tree[nodes][2]=otu;				++nodes;				if (otu2==0)	found0=1;				otu2=otu;				}	/* new node added */			}		}	}/* make sure that oldest species is included in the tree somewhere **/if (found0==0)	{	otu=0;	d=chucks;	for (otu2=1; otu<SOTU; ++otu2)	if (PDMat[otu][otu2]<d)		d=PDMat[otu][otu2];	for (otu2=1; otu<SOTU; ++otu2)	{		if (PDMat[otu][otu2]==d)	{			tree[nodes][0]=2;			tree[nodes][1]=0;			tree[nodes][2]=otu2;			commonanc[nodes]=CAMat[0][otu2];			++nodes;			}		}	found0=1;	}	MaxDiv=2;for (a=0; a<nodes; ++a)	if (tree[a][0]>MaxDiv)	MaxDiv=tree[a][0];/*****  Sort Clades by Last Common Ancestor	*****/for (testnode=0; testnode<nodes; ++testnode)	{	d=commonanc[c=testnode];	for (clade=testnode+1; clade<nodes; ++clade)		if (commonanc[clade] <= d) d=commonanc[c=clade];	if (c != testnode)	{		commonanc[c]=commonanc[testnode];		commonanc[testnode]=d;		for (sp=0; sp<=MaxDiv; ++sp)	{			d=tree[testnode][sp];			tree[testnode][sp]=tree[c][sp];			tree[c][sp]=d;			}		}	}/**** WRITE OUT TREE ****/for (testnode=nodes-1; testnode>0; --testnode)	{	found=0;	sp=tree[testnode][1];	htu=testnode+SOTU;	for (plesion=testnode-1; found==0 && plesion>=0; --plesion)	{		for (a=1; a<=tree[plesion][0]; ++a)	{			sp2=tree[plesion][a];			/* ancestral node found */			if (sp2==sp)	{				if (sp<SOTU)	{					for (b=a+1; tree[plesion][b]<htu && b<=tree[plesion][0]; ++b)						tree[plesion][b-1]=tree[plesion][b];					tree[plesion][b-1]=htu;					}				/* different routine needed if clade */				else	{					oldfirst=tree[plesion][1];					for (b=a; tree[plesion][b-1]>htu; --b)	{						tree[plesion][b]=tree[plesion][b-1];						}					tree[plesion][b]=htu;					/* if first species was a clade but now is another clade */					/*   then the old must be replaced */					if (b==1 && oldfirst==tree[plesion][2])	{						sp=tree[plesion][2];						htu=tree[plesion][1];						}					}				/* if the first species was found, then it will be in lower clades 						*/				/* this means that the tree needs to be re-written or this node will never find a home  */				/*   So, swap the that species with the first species in tree[plesion] 					*/				/*     if a clade replaces a clade, htu remains unchanged */				if (a==1 || b==1)					htu=tree[plesion][1];				else					found=1;				a=tree[plesion][0];	/* end search */				}	/* end replacement of taxon within clade by node or new representative species */			}	/* end search of species within a lower node */		}	/* end search of nodes */	}		/************************  Determine Branch Lengths  ************************/for (a=0; a<SOTU; ++a)					bl[a] = obsbl[a];for (a=SOTU; a<(SOTU+nodes); ++a)		bl[a] = 0;/***    Replace Branch lengths from sampled Ancestors to Nodes    ***/ for (sp=0; sp<SOTU; ++sp)	{	if (f1[sp]>0)	{		for (b=0; b<nodes; ++b)	{			if (commonanc[b]==observed[sp])	{				bl[b+SOTU] = bl[sp];				bl[sp] = 0;				}			}		}	}/***   Nodes Subsume the Apomorphies of their Unsampled Immediate Ancestors   ***/ for (clade=nodes-1; clade>=0; --clade)	{	while (bl[clade+SOTU]>0 && clade>0)	--clade;	if (clade<0)	break;	found=0;	anc=commonanc[clade];	for (a=0; (found==0 && anc>-1); ++a)	{		++bl[clade+SOTU];		for (b=0; b<SOTU; ++b)	{			/* if ancestor is observed, prepare to stop the loop */			if (observed[b]==anc)	{				found=1;				b=SOTU;				}			/* once species are older than ancestor, abandon search to speed loop */			else if (observed[b]>anc)	b=SOTU;			}		anc=ancestor[anc];		}	}/* add branch lengths to tree  */for (a=0; a<SOTU; ++a)	tree[SOTU-1][a]=bl[a];for (b=0; b<nodes; ++b)	{	a=SOTU+b;	tree[SOTU][b]=bl[a];	}for (a=0; a<SOTU; ++a)	{	tree[SOTU+1][a]=fa[a];	tree[SOTU+2][a]=la[a];	}free_ivector(observed);free_ivector(obsbl);free_ivector(commonanc);free_ivector(fa);free_ivector(la);free_ivector(bl);free_ivector(extant);free_ivector(ancestor);free_ivector(available);free_ivector(f1);free_ivector(DBas);	free_dvector(tor);free_dvector(tex);free_imatrix(PDMat,otu,otu);free_imatrix(CAMat,otu,otu);return tree;}/* evolvetreeVenn - Evolves a paleontological tree, with notu taxa sampled over time, output as Venn tree./* Requires:	notu - # of sampled taxa/*				mbl - simulation parameters where	 				mbl[0] (MU) - Speciation rate/*					mbl[1] (LAMBDA) - Extinction rate/*					mbl[2] (FR) - Preservation rate/*					mbl[3] (VR) - Variance in preservation rate				FOSSILS - (1) fossils sampled, (0) no fossils sampled/*				SPECIATION - (1) bifurcation (0) budding cladogenesis/* Major Rewrite of Sampled Tree Construction 02/2003/* Rewritten to use real numbers from a single array (mbl)******************************************************************************************************/long **evolvetreeVenn(int SOTU, double *mbl, int FOSSILS){long	attempts, base=100000, MU, LAMBDA,FR, VR, SPECIATION;int		a, b, c, d, ee, charstandard, ch, latest, MaxDiv=6, chucks, brats;int		clade, otu, otu2, htu, sampled, initdiv, standingdiv, cumulativediv, stage, newby;int		species, anc, speciate, extinct, change, find, testnode, plesion, found0, oldfirst;int		reboot;int		sp, sp2, nodes, found;int		MaxTaxa, MaxStanding;int		*available, *f1, **forefathers, *ancestor;int		*extant, *observed, *obsbl, *commonanc, *bl;int		*fa, *la, *DBas;double	*tor, *tex;int		**PDMat, **CAMat;long	**tree;double	v, x, y, MOD;MU=base*mbl[0];LAMBDA=base*mbl[1];FR=base*mbl[2];VR=base*mbl[3];SPECIATION=mbl[4];v=expectedpropsampled(mbl[1],mbl[2]);v=1/v;MaxTaxa=10*v*SOTU;MaxTaxa=10*v*SOTU;//if (FOSSILS=1)	MaxStanding=2*SOTU;//else			MaxStanding=3*SOTU;MaxStanding=3*SOTU;/* arrays for observed taxa - set to SOTU*/observed=ivector(SOTU);obsbl=ivector(SOTU);commonanc=ivector(SOTU);fa=ivector(SOTU);la=ivector(SOTU);DBas=ivector(SOTU);/* array for all elements of the tree */bl=ivector(2*SOTU);/* array for standing taxa - set to MaxStanding*/extant = ivector(MaxStanding+1);/* arrays for sampled and obsbl taxa - set to MaxTaxa */ancestor=ivector(MaxTaxa);	/* ancestor of each taxon */available=ivector(MaxTaxa);f1=ivector(MaxTaxa);		/* number of descendants for each taxon */tor=dvector(MaxTaxa);		/* true origination - this is a real number */tex=dvector(MaxTaxa);		/* true extinction - this is a real number */reboot=0;a=b=c=d=ee=anc=0;charstandard = 1; /*charbase/100;*/sp = ch = change = find = 0;clearivector(observed,SOTU,-1);clearivector(obsbl,SOTU,-1);clearivector(ancestor,MaxTaxa,-1);clearivector(extant,MaxStanding+1,-1);latest = -1;attempts = initdiv = standingdiv = cumulativediv = stage = extant[0] = sampled = 0;while (sampled < SOTU)	{	initdiv = standingdiv+1;	for (sp=0; (sp<=standingdiv && cumulativediv<MaxTaxa); ++sp)	{	/********************************************/	/*			Does Lineage Speciate?			*/	/********************************************/		if (sp<0 || sp>MaxStanding)	{			printf("ERROR 108: %d is the wrong number of species!\n", sp);			exit(0);			}		species = extant[sp];		tex[species]=stage+1;				if (f1[species]<MaxDiv)	speciate = (((unsigned int) rand())%base);		else					speciate = base;		MOD=MU;		if (sp>=initdiv)			MOD=((stage+1)-tor[species])*MOD;				if (SPECIATION==1)	ee=2;		else				ee=1;		if (speciate <= MOD && (standingdiv<(MaxStanding-ee)))		{			brats=1;			if (SPECIATION==1)	brats=2;			else	{				y=LAMBDA;				y=y/base;				if (tor[species]>stage)	v=(stage+1)-tor[species];				else					v=1;				x=Poisson(y, v, 2);				if (speciate<x*base)	brats=2;				}			/* go through each descendant */			for (a=0; a<brats; ++a)	{				++standingdiv;				++cumulativediv;				extant[standingdiv] = cumulativediv;				if (cumulativediv > MaxTaxa)	{					printf("ERROR Evolve 137 - In replication XXX");					printf(", more than %3d species were generated.  \n",MaxTaxa);					sampled=SOTU;					exit(0);						}				if (standingdiv<0 || standingdiv>MaxStanding)	{					printf("ERROR 144:  Standing diversity too high at %2d\n",standingdiv);					sampled=SOTU;					exit(0);						}							if (cumulativediv<0 || cumulativediv>=MaxTaxa || species<0 || species>=MaxTaxa)	{					printf("ERROR 148 - ancestor index out of range at %d and %d\n",species,cumulativediv);					sampled=SOTU;					exit(0);						}				ancestor[cumulativediv] = species;				anc = species;				++f1[anc];						/*******************************************************************************/		/* Ancestors become pseudo-extinct at bifurcation if that is what is happening */		/*******************************************************************************/				if (SPECIATION==1 && a==1)	{					tex[anc]=tor[cumulativediv]=tor[cumulativediv-1];					}				else	{					/* to must be after ancestor's to */					if (tor[anc]>stage)	v=((stage+1)-tor[anc])*base;					else				v=base;					b=v;					y = (((unsigned int) rand())%b);					if (tor[anc]<=stage)	tor[cumulativediv]=stage+(y/base);					else				tor[cumulativediv]=tor[anc]+(y/base);					}				}			}		if (FOSSILS==0 && standingdiv>=SOTU-1)	sp = initdiv;	/* quit if enough taxa are alive */		}	/****  End Speciation Round ****/ 				if (FOSSILS==1)	{		/********************************************/		/*				 Do Sampling				*/		/*  Separated from Speciation Loop 1/3/97   */		/********************************************/		if (sampled < SOTU)	{			for (sp=0; sp<=standingdiv; ++sp)	{				species = extant[sp];								/* Raw Species Number */				find = (((unsigned int) rand())%base)+1;//				if (f1[species]>=3 || cumulativediv>=(3*MaxStanding))	find = 0;				y=FR;				x=stage;				if (tor[species]>x)			MOD=(tex[species]-tor[species])*y;				else if (tor[species]<x)		MOD=(tex[species]-x)*y;								if (find <= MOD)	{					newby = 0;					/** First sampled species goes straight into the array **/					if (sampled==0)	{						observed[sampled]=species;						fa[sampled]=la[sampled]=stage;						++sampled;						}					/** Test whether a sampled species had gone unsampled **/					else	{						for (otu = 0; otu < sampled;  ++otu)	{							if (observed[otu] == species)	{								newby = 1;								la[otu]=stage;								otu = sampled;								}							}						if (newby == 0 && sampled < SOTU)	{							/* sort species as you go */							a=sampled-1;							while (observed[a]>species && a>=0)	{								observed[a+1]=observed[a];								fa[a+1]=fa[a];								la[a+1]=la[a];								--a;								}							observed[a+1] = species;							fa[a+1]=la[a+1]=stage;							++sampled;							if (sampled<0 || sampled>SOTU)	{								printf("ERROR 189: You somehow sampled %d\n",sampled);								exit(0);								}							if (sampled==SOTU)		sp = standingdiv;							}						}					latest = observed[sampled-1];					}	/* End Tallying of Sampled Horizon	*/				}	/*  End Sampling for Each Horizon	*/			}		}			else {		sampled = standingdiv;		/* if there are no fossils, "present" is when									   SOTU taxa evolve */		if (sampled==SOTU-1)	for (sp=0; sp<SOTU; ++sp)	observed[sp]=extant[sp];		}	if (sampled>=SOTU)	break;	/* don't bother with the rest if done */				/********************************************/		/*				Do Extinction				*/		/********************************************/	for (a=standingdiv; a>=0; --a)	{		/* sp = extant but not nec. sampled species */		extinct = (((unsigned int) rand())%base);				sp=extant[a];		y=LAMBDA;		x=stage;		/* take into account species that were there only part of the time */		if (tor[sp]>x)			MOD=(tex[sp]-tor[sp])*y;		else if (tor[sp]<x)		MOD=(tex[sp]-x)*y;		if (tex[sp]<(stage+1))	{			extinct=0;			MOD=base;			}//		if (f1[extant[sp]]>=3)	extinct = 0;		if (extinct < MOD)	{			/*  REMOVE SPECIES FROM EXTANT LIST */			for (b = a; b <= standingdiv; ++b)	extant[b] = extant[b+1];			extant[standingdiv] = -1;			--standingdiv;			if (sp<-1)	{				printf("ERROR 224 - you have more extinctions than species\n");				exit(0);				}			}		}	/*  End Extinction Simulation */	initdiv=standingdiv;				/****** REBOOT ROUTINE ******/	if (standingdiv < 0 || (cumulativediv>=MaxTaxa && sampled < SOTU))	{		latest = -1;		for (sp=0; sp<SOTU; ++sp)	{			extant[sp]=observed[sp]=ancestor[sp]=-1;			tor[sp]=fa[sp]=la[sp]=f1[sp]=0;			}		standingdiv = initdiv = cumulativediv = extant[0] = sampled = 0;		stage = 0;		++attempts;/*		if ((attempts%5)==0)	printf ("%2d tries and counting.\n",attempts); */		}				/** Reboot simulation **/	else	{		if (sampled < SOTU)	++stage;		/*  All SOTU species found	*/		else if (FOSSILS==0 && cumulativediv==((2*SOTU)-2))	{			for (sp=0; sp<=standingdiv; ++sp)		observed[sp] = extant[sp];			sampled = SOTU;			reboot=1;			}		/* if species index is out of range, then reboot the whole thing */		}	}MaxDiv=1+maxiarray(f1,cumulativediv);/* tree matrix - rows 0...(SOTU-1) rows are for possible nodes	*//*		row SOTU-1 is for species branch lengths				*//*		row SOTU   is for nodal branch lengths					*//*		row SOTU+1 is for species FAs							*//*		row SOTU+2 is for species LAs							*//*		the first cell of rows 0É(SOTU-1) give # branches		*//*			(i.e., 2 for bifurcation w. no sampled ancestor)	*/tree=lmatrix(SOTU+3,SOTU);clearlmatrix(tree,SOTU+3,SOTU,-1);for (a=cumulativediv+1; a<MaxTaxa; ++a)	f1[a]=ancestor[a]=0;if (observed[0]==-1)	{	printf("Taxa lost by line 257\a\n");	exit(0);	}/*********************************************************************************//*								Store True Phylogeny							 *//*********************************************************************************//**** LIST ANCESTORS OF EACH OBSERVED SPECIES ****/chucks=0;ancestor[0]=-1;/* find the distance from the base for each species */for (otu=0; otu<SOTU; ++otu)	{	sp=observed[otu];	anc=ancestor[sp];	if (anc>=0)		DBas[otu]=1;	for (a=1; anc>=0; ++a)	{		anc=ancestor[anc];		++DBas[otu];		}	}/* count the maximum number of ancestors */chucks=maxiarray(DBas,otu);/* list all of the ancestors for each species */forefathers=imatrix(SOTU,chucks+1);clearimatrix(forefathers,SOTU,chucks+1,-1);ancestor[0]=-1;for (otu=0; otu<SOTU; ++otu)	{	forefathers[otu][0]=sp=observed[otu];	anc=ancestor[sp];	for (a=1; anc>=0; ++a)	{		forefathers[otu][a]=anc;		anc=ancestor[anc];		}	}/* list the unsampled ancestors of each species *//* also, tally species with sampled descendants */free_ivector(f1);f1=ivector(SOTU);	/* 0: no sampled descendants; 1: 1+ sampled descendants */for (otu=0; otu<SOTU; ++otu)	{	obsbl[otu]=1;	found=0;	for (a=1; a<DBas[otu]; ++a)	{		anc=forefathers[otu][a];		for (b=otu-1; b>=0; --b)	{			if (observed[b]==anc)	{				found=1;				f1[b]=1;				/* end loops */				b=0;				a=DBas[otu];				}			}		if (found==0)	++obsbl[otu];		}	}/* create a matrix of branch distances between taxa *//* this gives distance to common ancestor, so the matrix is asymmetrical */PDMat=imatrix(otu,otu);CAMat=imatrix(otu,otu);for (otu=SOTU-1; otu>0; --otu)	{	for (otu2=otu-1; otu2>=0; --otu2)	{		for (a=0; a<=DBas[otu]; ++a)	{			sp=forefathers[otu][a];			for (b=0; b<=DBas[otu2]; ++b)	{				sp2=forefathers[otu2][b];				if (sp==sp2)	{					PDMat[otu][otu2]=a+1;					PDMat[otu2][otu]=b+1;					CAMat[otu][otu2]=CAMat[otu2][otu]=sp;					/* end loop */					b=DBas[otu2];					a=DBas[otu];					}				/* end loop if forefather[otu][a] cannot match forefather[otu2][any] */				else if (sp>sp2)	b=DBas[otu2];				}			}		}	}/* create a tree *//* keep track of common ancestors of each clade */nodes=found0=0;for (otu=SOTU-1; otu>0; --otu)	{	d=chucks;	for (otu2=otu-1; otu2>=0; --otu2)	{		if (PDMat[otu][otu2]<d)	{			d=PDMat[otu][otu2];			}		}	for (otu2=0; otu2<otu; ++otu2)	{		if (PDMat[otu][otu2]==d)	{			anc=CAMat[otu][otu2];			found=-1;			for (a=0; a<nodes; ++a)	{				/* existing nodes found */				if (commonanc[a]==CAMat[otu][otu2])	{					found=0;					/* check to see if the species already is in the nodes */					for (b=1; b<=tree[a][0]; ++b)	{						if (otu2==tree[a][b])		found=1;						}					if (found==0)	{						for (b=1; b<=tree[a][0]; ++b)	{							if (otu==tree[a][b])	found=2;							}						}					/* if neither species already found */					if (found==0)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					/* if older species already found */					else if (found==1)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						}					/* if younger species already found */					else if (found==2)	{						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					a=nodes+1;					otu2=otu;					}				}	/* end search for previously found node */			/* new nodes found */			if (found==-1)	{				commonanc[nodes]=CAMat[otu][otu2];				tree[nodes][0]=2;				tree[nodes][1]=otu2;				tree[nodes][2]=otu;				++nodes;				if (otu2==0)	found0=1;				otu2=otu;				}	/* new node added */			}		}	}/* make sure that oldest species is included in the tree somewhere **/if (found0==0)	{	otu=0;	d=chucks;	for (otu2=1; otu<SOTU; ++otu2)	if (PDMat[otu][otu2]<d)		d=PDMat[otu][otu2];	for (otu2=1; otu<SOTU; ++otu2)	{		if (PDMat[otu][otu2]==d)	{			tree[nodes][0]=2;			tree[nodes][1]=0;			tree[nodes][2]=otu2;			commonanc[nodes]=CAMat[0][otu2];			++nodes;			}		}	found0=1;	}	MaxDiv=2;for (a=0; a<nodes; ++a)	if (tree[a][0]>MaxDiv)	MaxDiv=tree[a][0];/*****  Sort Clades by Last Common Ancestor	*****/for (testnode=0; testnode<nodes; ++testnode)	{	d=commonanc[c=testnode];	for (clade=testnode+1; clade<nodes; ++clade)		if (commonanc[clade] <= d) d=commonanc[c=clade];	if (c != testnode)	{		commonanc[c]=commonanc[testnode];		commonanc[testnode]=d;		for (sp=0; sp<=MaxDiv; ++sp)	{			d=tree[testnode][sp];			tree[testnode][sp]=tree[c][sp];			tree[c][sp]=d;			}		}	}/**** WRITE OUT TREE ****/for (testnode=nodes-1; testnode>0; --testnode)	{	found=0;	sp=tree[testnode][1];	htu=testnode+SOTU;	for (plesion=testnode-1; found==0 && plesion>=0; --plesion)	{		for (a=1; a<=tree[plesion][0]; ++a)	{			sp2=tree[plesion][a];			/* ancestral node found */			if (sp2==sp)	{				if (sp<SOTU)	{					for (b=a+1; tree[plesion][b]<htu && b<=tree[plesion][0]; ++b)						tree[plesion][b-1]=tree[plesion][b];					tree[plesion][b-1]=htu;					}				/* different routine needed if clade */				else	{					oldfirst=tree[plesion][1];					for (b=a; tree[plesion][b-1]>htu; --b)	{						tree[plesion][b]=tree[plesion][b-1];						}					tree[plesion][b]=htu;					/* if first species was a clade but now is another clade */					/*   then the old must be replaced */					if (b==1 && oldfirst==tree[plesion][2])	{						sp=tree[plesion][2];						htu=tree[plesion][1];						}					}				/* if the first species was found, then it will be in lower clades 						*/				/* this means that the tree needs to be re-written or this node will never find a home  */				/*   So, swap the that species with the first species in tree[plesion] 					*/				/*     if a clade replaces a clade, htu remains unchanged */				if (a==1 || b==1)					htu=tree[plesion][1];				else					found=1;				a=tree[plesion][0];	/* end search */				}	/* end replacement of taxon within clade by node or new representative species */			}	/* end search of species within a lower node */		}	/* end search of nodes */	}		/************************  Determine Branch Lengths  ************************/for (a=0; a<SOTU; ++a)					bl[a] = obsbl[a];for (a=SOTU; a<(SOTU+nodes); ++a)		bl[a] = 0;/***    Replace Branch lengths from sampled Ancestors to Nodes    ***/ for (sp=0; sp<SOTU; ++sp)	{	if (f1[sp]>0)	{		for (b=0; b<nodes; ++b)	{			if (commonanc[b]==observed[sp])	{				bl[b+SOTU] = bl[sp];				bl[sp] = 0;				}			}		}	}/***   Nodes Subsume the Apomorphies of their Unsampled Immediate Ancestors   ***/ for (clade=nodes-1; clade>=0; --clade)	{	while (bl[clade+SOTU]>0 && clade>0)	--clade;	if (clade<0)	break;	found=0;	anc=commonanc[clade];	for (a=0; (found==0 && anc>-1); ++a)	{		++bl[clade+SOTU];		for (b=0; b<SOTU; ++b)	{			/* if ancestor is observed, prepare to stop the loop */			if (observed[b]==anc)	{				found=1;				b=SOTU;				}			/* once species are older than ancestor, abandon search to speed loop */			else if (observed[b]>anc)	b=SOTU;			}		anc=ancestor[anc];		}	}/* add branch lengths to tree  */for (a=0; a<SOTU; ++a)	tree[SOTU-1][a]=bl[a];for (b=0; b<nodes; ++b)	{	a=SOTU+b;	tree[SOTU][b]=bl[a];	}for (a=0; a<SOTU; ++a)	{	tree[SOTU+1][a]=fa[a];	tree[SOTU+2][a]=la[a];	}free_ivector(observed);free_ivector(obsbl);free_ivector(commonanc);free_ivector(fa);free_ivector(la);free_ivector(bl);free_ivector(extant);free_ivector(ancestor);free_ivector(available);free_ivector(f1);free_ivector(DBas);	free_dvector(tor);free_dvector(tex);free_imatrix(PDMat,otu,otu);free_imatrix(CAMat,otu,otu);tree=clademember(tree, SOTU, nodes);return tree;}/* Returns a matrix for SOTU taxa with nchars characters.  Gaps and missing are kept in place *//* Requires:   tree - a matrix containing members of each node, with daughter nodes given a number of OTUs+node#;		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[SOTU-1]) gives it for species;			the second line (tree[SOTU]) gives it for internal nodes;	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	TTLSTP - the number of changes for the matrix;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/long **evolvematrix(long **tree, int notu, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int ttlstp, int UNKNOWN, int INAP){int		a, b, c, d, br, ch, sc, ev, flip, sp, sp2;int		st, u, clse, best;int		avnodes, nodes, used, deltas, mxdel, ttlbr;int		*available, *branches, *steps, *trpd, *mpd, *der, *aptaxa;int		**taxachange;/*, **descnodes;	/* for debugging */long	**invmatrix;/* find the number of nodes and their diversities */nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character *///mxstt=maxiarray(nstates,nchars);			/* maximum number of states for any character */mpd=ivector(nodes+notu);					/* morphologic changes along each branch */trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */steps=ivector(nchars);						/* number of times each character changes */der=ivector(nchars);						/* number of taxa with derived condition for each character *///descnodes=DescendantNodes(tree,notu);//nodestates=lmatrix(nodes,nchars);trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	}	if (ttlbr<mxdel)	mxdel=ttlbr;/* allocate memory for arrays containing branches needing changes */available=ivector(ttlbr);branches=ivector(ttlbr);taxachange=imatrix(nchars, mxdel);	/* gives taxa that change for character */invmatrix=lmatrix(nchars, notu);aptaxa=applicabletaxa(matrix, nchars, notu, INAP);/* BEGIN HERE 5/18/01 describe each clade in terms of all species within it *//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********/	/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */avnodes=b=0;for (a=1; a<nodes; ++a)	{	avnodes=avnodes+trpd[a+notu];	for (c=0; c<trpd[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		available[b]=a;		++b;		}	}/* clear matrix */for (ch=0; ch<nchars; ++ch)	{	for (a=0; a<notu; ++a)	{		if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{			matrix[a][ch]=0;			}		invmatrix[ch][a]=matrix[a][ch];	/* for debugging */		}	}deltas=0;/* Step 1: Make sure each state is derived for each character *///derive_each_char(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, aptaxa, mpd, trpd, notu, nchars, maxstp, mxdel, UNKNOWN, INAP, tree, branches, available, nodes, ttlbr);for (ch=0; (ch<nchars && deltas<ttlstp); ++ch)	{	while (maxch[ch]==0 && ch<nchars)	++ch;	if (ch>=nchars)			break;	steps[ch]=st=0;	clearivector(taxachange[ch],mxdel,-1);	ev=0;			/* make sure that inapplicable characters have at least one taxon that can be changed */	if (aptaxa[ch]<notu)	{		/* count unknowns - these will be put back in later */		u=0;		for (a=0; a<notu; ++a)	if (matrix[a][ch]==UNKNOWN)	++u;		/* now find a node that has similar diversity */		clse=RAND_MAX;				/* start from the bottom if most taxa are scored */		if (aptaxa[ch]>(notu/2))	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==(notu-aptaxa[ch]))	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs((notu-aptaxa[ch])-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}		/* start from the top otherwise */		else	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==aptaxa[ch])	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs(aptaxa[ch]-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}				for (sp=0; sp<notu; ++sp)	{			if (aptaxa[ch]>(notu/2))	matrix[sp][ch]=0;			else						matrix[sp][ch]=INAP;			}		for (a=1; a<tree[best][0]; ++a)	{			sp=tree[best][a];			matrix[sp][a]=0;			}		}	/* end initial creation of inapplicable character */		/* make autapomorphic characters change on one species only */	/* invariants do not change at all */	for (ch=ch; maxch[ch]<=1; ++ch)	{		/* skip invariants and make autapomorphies autapomorphic */		if	(maxch[ch]==1)	{			c=0;			/* we will sample only from otus here - so do not include clades in branches array! */			/* this part rewritten with Cubs winning 7-0 against the Marlins in Game 4 */			for (sp=0; sp<notu; ++sp)				if ((matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP) && trpd[sp]>0)	++c;			if (c>0)	{				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || (trpd[sp]==0 || sp>=notu))					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=1;				taxachange[ch][0]=sp;				}			/* if only cells belong to species with 0 length branches */			if (c==0)	{				/* flip-flop an unknown apomorphic species with a known plesiomorphic one - give plesiomorphic species a ? and the other a 1 */				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || sp2>=notu)					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);								sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while (trpd[sp2]==0 || sp2>=notu)					sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp2][ch];				invmatrix[ch][sp2]=matrix[sp2][ch]=1;				taxachange[ch][0]=sp2;				}	/* end routine if all scored species were unknown */			ev=1;			++deltas;			++steps[ch];			++mpd[ch];			}		}	/* this should leave us with a character that needs to be changed OR out of characters */	if (ch>=nchars)	break;			used=0;	/* this tells how many branches are discarded; used > steps IF there are absents */	/* branch length is taken into account by trpd */	equalivector(branches,available,ttlbr);	/* Binary && unordered multistate is Easy */	/* for normal character, have it change until all X states are realized */	if (nstates[ch]==2 || ctype[ch]==1)	{		/* changed 10/14/2003 so that non-apomorphic characters	diagnose 2+ species */		for (st=0; (st<nstates[ch]-1 || der[ch]<=1); st=st)	{			/* There are ttlbr-used branches that could change */			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			/* have binary characters change on branches - if they are not autapomorphic, then they need to diagnose multiple species THIS WAS REMOVED 10/14/2003			else				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (avnodes-used));*/			sp = branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				ev=1;				if (nstates[ch]==2)	invmatrix[ch][sp]=matrix[sp][ch]=1;				else					invmatrix[ch][sp]=matrix[sp][ch]=st+1;				++der[ch];				/* add one to the number of species showing derived condition(s) */				}			else if (sp>notu)	{				/* use st+1 instead of nstates[ch] here - we want only 0Ést+1 not 0Énstates    */				/*		(remember, st has not yet been incremented, so we need st+1) 		   */				/* This section modified 10/14/2003 to make sure characters are not apomorphic */				/* if multistate, then we need at least two iterations */				if (nstates[ch]>2)	{					/* if we have not yet derived all of the states, do it this way 			*/					/* if deriving first state (i.e., st=0), then it is the same as binary		*/					if (st<nstates[ch] && st==0)						evolvebinaryinclade(tree[sp-notu],matrix,ch);					/* if deriving subsequent states, then used change unmodified species to st+1 		*/					else if (st<(nstates[ch]-1) && st>=1)	{						for (c=1; c<=tree[sp-notu][0]; ++c)	{							sp2=tree[sp-notu][c];							if (matrix[sp2][ch]==0)	matrix[sp2][ch]=st+1;							}						}//						evolveunorderedinclade(tree[sp-notu],matrix,ch,st+2,UNKNOWN,INAP);					/* if we have an essentially apomorphic states, then just do it like any other time */					else						evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],UNKNOWN,INAP);					}				else		evolvebinaryinclade(tree[sp-notu],matrix,ch);				for (c=1; c<=tree[sp-notu][0]; ++c)	{					sp2=tree[sp-notu][c];					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					if (invmatrix[ch][sp2]!=0 && (invmatrix[ch][sp2]!=UNKNOWN && invmatrix[ch][sp2]!=INAP))						++der[ch];					else if (invmatrix[ch][sp2]==0)						--der[ch];					/* this will happen only if there are reversals */					}				/* if there was a change, then tally it */				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1) || der[ch]<=1)				removefromivector(branches,sp,a);							if (used<steps[ch])	{				printf("ERROR LINE 954 - there are more changes than deleted branches for Ch%dÉ\n",ch+1);				}			/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				++st;	/* we increment this only if we have made a change */				}			}	/*end derivation of state */		}	/* end loop for binary / unordered characters */		/* Ordered Multistates are tougher */	else if (nstates[ch]>2 && ctype[ch]==0)	{		used=0;		for (st=0; (st<nstates[ch]-1 && (steps[ch]<mxdel && steps[ch]<maxch[ch])); st=st)	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			sp=branches[br];			/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				/* in this case all taxa must be examined just in case the matrix has been recentered due to a negative number */				for (sp2=0; sp2<notu; ++sp2)	{					if (ev==0 && invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					}				ev=1;				}							else if (sp>notu)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])	flip=1;				else				flip=-1;				evolveorderedinclade(tree[sp-notu],matrix,ch,flip, INAP, UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				/* in this case all taxa must be modified just in case the matrix has been recentered due to a negative number */				for (sp2=0; sp2<notu; ++sp2)	{					if (ev==0 && invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					}				}							/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				/* note - do not increment st here - that is done only if a new state is derived */				}			/* check if all states have been derived */			/* note: this is needed only for ordered multistates */			if (steps[ch]>=nstates[ch]-1)	{				for(a=0; a<notu; ++a)	{					if (matrix[a][ch]>st && (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN))						st=matrix[a][ch];					}				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1))				removefromivector(branches,sp,a);			if (used<steps[ch])				printf("ERROR LINE 2145 - there are more changes than deleted branches for Ch%dÉ\n",ch+1);						/* emergency reboot procedure! - clear everything and start over again */			if (used==ttlbr)	{				for (a=0; a<steps[ch]; ++a)	{					sp=taxachange[ch][a];					--mpd[sp];					taxachange[ch][a]=0;					}				deltas=deltas-steps[ch];				st=steps[ch]=used=0;				for (sp=0; sp<notu; ++sp)					if (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN)						invmatrix[ch][sp]=matrix[sp][ch]=0;				for (sp=0; sp<ttlbr; ++sp)	branches[sp]=available[sp];				}			}		/* if there are many states and few taxa, then you do not want to mess with this anymore.  Any changes will either eliminate extreme states,		or simply shift the state up or down one (resulting in no observable change once standardized.  So, if steps >= half the taxa, then shut it down */				}	/* end loop for ordered multistates */	}	/* end derivation of all character states *//* Step #2: make sure that each apomorphic species has a derivation */for (sp=0; (sp<notu+nodes && deltas<ttlstp); ++sp)	{	if (mpd[sp]==0 && trpd[sp]>0)	{		while (mpd[sp]==0)	{			ev=0;			ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));			while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))				ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));						if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				if (nstates[ch]==2)						invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);				else if (ctype[ch]==1)					invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);				else if (ctype[ch]==0)	{					invmatrix[ch][sp]=matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);					/* make sure no negative numbers are kept! */					multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);					}				ev=1;	/* this means that there was a change */				}						else if (sp>notu)	{				d=0;				/* make sure that there are taxa with scorable conditions for this character 		*/				/* and also that not all the descendants have changed already for this character 	*/				/* (the latter can be omitted as evolution cannot know this - but it makes the 		*/				/* output easier to compare to empirical studies.)									*/						for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;					else	{						for (c=0; c<steps[ch]; ++c)	{							if (taxachange[ch][c]==sp2)	{								++d;								c=steps[ch];								}							}						}		/* if any taxa have not yet changed, then d < clade diversity */					}	/* end search for scored taxa */					/* if d is less than clade diversity, then proceed with change */				if (d<tree[sp-notu][0])	{					/* if character is an unordered multistate, then we need an array	*/					/* that tells how each state changed withing the clade				*/					if (ctype[ch]==1)	{						/* routine for unordered multistates */						if (nstates[ch]>2)	{							evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);							}						/* routine for binaries */						else	{							evolvebinaryinclade(tree[sp-notu],matrix,ch);							}						}	/* end routine for unordered / binary characters */					/* routine for ordered multistate */					else {						/* flip is used only for multistates */						flip = ((int) (100 * rand() / RAND_MAX));						if (flip<bias[ch])	flip=1;						else				flip=-1;						evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					/* now make sure that there was change */					for (c=0; c<notu; ++c)	{						if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;						invmatrix[ch][c]=matrix[c][ch];						}					}	/* end conditional loop */				}	/* end routine for clade */			/* if there was a change, then ev = 1.  Now tally the information */			if (ev==1)	{				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++mpd[sp];				++deltas;				}	/* add changes if there actually was a change */			}	/* routine is repeated until an apomorphy is acquired */					}	/* end derivation of apomorphy for this branch */	}	/* end derivation for each apomorphic branch *//* Step #3: DO ADDITIONAL STEPS NOW */for (deltas=deltas; deltas < ttlstp; deltas=deltas)	{	/* first choose a character */	ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))		ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	/**************************************************************************/	/* do not change the character on a branch where it already has changed */	for (br=0; br<ttlbr; ++br)	branches[br]=available[br];		used=0;	/* used will tally the number of deleted branches */	for (d=0; d<steps[ch]; ++d)	{		for (c=0; c<(ttlbr-used); ++c)	{			/* if branch with change is found, delete it from possible changes */			if (branches[c]==taxachange[ch][d])	{				for (a=c; a<ttlbr-1; ++a)	branches[a]=branches[a+1];				/* some taxa will be in 2+ times - step back to delete them all */				--c;				branches[ttlbr-(used+1)]=-1;				++used;				}			}		}	/* choose a branch from one available */	/* used will be equal to or greater than steps[ch] (due to long branches) */	br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));	sp = branches[br];	/* this shouldn't be necessary, but occassionaly the random number generator */	/* produces a number outside of the proscribed limits */	while (trpd[sp]==0 || br>=(ttlbr-used))	{		br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));		sp = branches[br];		}	ev=0;	if (nstates[ch]==2)	{		/* routine for binary characters */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);			ev=1;			}		/* routine for clade */		else if (sp>=notu)	{			evolvebinaryinclade(tree[sp-notu],matrix,ch);			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;				invmatrix[ch][sp2]=matrix[sp2][ch];				}				}	/* end routine for clade */		}	/* Ordered Multistates */	else if (ctype[ch]==0)	{		flip = ((int) (100 * rand() / RAND_MAX));		if (flip<bias[ch])						flip=1;		else									flip=-1;				/* routine for species */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;			if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;			else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;			ev=1;			}		/* routine for clade */		else if (sp>=notu)	{			/* make sure that not all descendants have already changed! */			d=0;			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;				else	{					for (c=0; c<steps[ch]; ++c)	{						if (taxachange[ch][c]==sp2)	{							++d;							c=steps[ch];							}	/* end test of whether particular change matches species */						}	/* end search through each step */					}	/* end search for unchanged taxa */				}			if (d<tree[sp-notu][0])	{				evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				}			/* now make sure that there was change */			for (c=0; c<notu; ++c)	{				if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;				invmatrix[ch][c]=matrix[c][ch];				}			}	/* end routine for clade */		}	/** END ROUTINE FOR ORDERED MULTISTATES **/	/* Unordered Multistate Characters */	else if (ctype[ch]==1)	{		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);			ev=1;			}					else if (sp>notu)	{			evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);			/* make sure that there is change */			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	{						invmatrix[ch][sp2]=matrix[sp2][ch];						ev=1;						}					}				}			}	/* end unordered change for a clade */			/* if change is made, tally */		}	/* end unordered change */	/* if ev = 1, then there has been a change.  Tally it */	if (ev==1)	{		++deltas;		taxachange[ch][steps[ch]]=sp;		++steps[ch];		++mpd[sp];		}		}	/* end additional steps */free_ivector(der);free_ivector(mpd);free_ivector(trpd);free_ivector(steps);free_ivector(available);free_ivector(branches);free_ivector(aptaxa);free_imatrix(taxachange,nchars,mxdel);free_lmatrix(invmatrix,nchars, notu);return matrix;}/* evolvecompat - evolves matrix and returns compatibility for min to max steps.  Gaps and missing are kept in place *//* Requires:   tree - a matrix containing members of each node, with daughter nodes given a number of OTUs+node#;		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[SOTU-1]) gives it for species;			the second line (tree[SOTU]) gives it for internal nodes;	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	minstep - the maximum number of changes for the matrix;	maxstep - the maximum number of changes for the matrix;	comptype - 0 for normal compatibility, 1 for hierarchical compatibility;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/long *evolvecompat(long **tree, int notu, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int minstp, int maxstp, int comptype, int UNKNOWN, int INAP){int		a, b, c, d, br, ch, sc, ev, flip, sp, sp2;int		st, u, clse, best;int		avnodes, nodes, used, deltas, mxdel, ttlbr;int		*available, *branches, *steps, *trpd, *mpd, *der, *aptaxa;int		**taxachange;/*, **descnodes;	/* for debugging */long	*compatibility;long	**invmatrix;/* find the number of nodes and their diversities */nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character *///mxstt=maxiarray(nstates,nchars);			/* maximum number of states for any character */mpd=ivector(nodes+notu);					/* morphologic changes along each branch */trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */steps=ivector(nchars);						/* number of times each character changes */der=ivector(nchars);						/* number of taxa with derived condition for each character */compatibility=lvector(1+(maxstp-minstp));	/* compatibility[X] is compatibility after X steps *///descnodes=DescendantNodes(tree,notu);//nodestates=lmatrix(nodes,nchars);trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	}	if (ttlbr<mxdel)	mxdel=ttlbr;/* allocate memory for arrays containing branches needing changes */available=ivector(ttlbr);branches=ivector(ttlbr);taxachange=imatrix(nchars, mxdel);	/* gives taxa that change for character */invmatrix=lmatrix(nchars, notu);aptaxa=applicabletaxa(matrix, nchars, notu, INAP);/* BEGIN HERE 5/18/01 describe each clade in terms of all species within it *//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********/	/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */avnodes=b=0;for (a=1; a<nodes; ++a)	{	avnodes=avnodes+trpd[a+notu];	for (c=0; c<trpd[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		available[b]=a;		++b;		}	}/* clear matrix */for (ch=0; ch<nchars; ++ch)	{	for (a=0; a<notu; ++a)	{		if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{			matrix[a][ch]=0;			}		invmatrix[ch][a]=matrix[a][ch];	/* for debugging */		}	}deltas=0;/* Step 1: Make sure each state is derived for each character *///derive_each_char(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, aptaxa, mpd, trpd, notu, nchars, maxstp, mxdel, UNKNOWN, INAP, tree, branches, available, nodes, ttlbr);for (ch=0; (ch<nchars && deltas<maxstp); ++ch)	{	while (maxch[ch]==0 && ch<nchars)	++ch;	if (ch>=nchars)			break;	steps[ch]=st=0;	clearivector(taxachange[ch],mxdel,-1);	ev=0;			/* make sure that inapplicable characters have at least one taxon that can be changed */	if (aptaxa[ch]<notu)	{		/* count unknowns - these will be put back in later */		u=0;		for (a=0; a<notu; ++a)	if (matrix[a][ch]==UNKNOWN)	++u;		/* now find a node that has similar diversity */		clse=RAND_MAX;				/* start from the bottom if most taxa are scored */		if (aptaxa[ch]>(notu/2))	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==(notu-aptaxa[ch]))	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs((notu-aptaxa[ch])-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}		/* start from the top otherwise */		else	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==aptaxa[ch])	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs(aptaxa[ch]-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}				for (sp=0; sp<notu; ++sp)	{			if (aptaxa[ch]>(notu/2))	matrix[sp][ch]=0;			else						matrix[sp][ch]=INAP;			}		for (a=1; a<tree[best][0]; ++a)	{			sp=tree[best][a];			matrix[sp][a]=0;			}		}	/* end initial creation of inapplicable character */		/* make autapomorphic characters change on one species only */	/* invariants do not change at all */	for (ch=ch; maxch[ch]<=1; ++ch)	{		/* skip invariants and make autapomorphies autapomorphic */		if	(maxch[ch]==1)	{			c=0;			/* we will sample only from otus here - so do not include clades in branches array! */			/* this part rewritten with Cubs winning 7-0 against the Marlins in Game 4 */			for (sp=0; sp<notu; ++sp)				if ((matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP) && trpd[sp]>0)	++c;			if (c>0)	{				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || (trpd[sp]==0 || sp>=notu))					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=1;				taxachange[ch][0]=sp;				}			/* if only cells belong to species with 0 length branches */			if (c==0)	{				/* flip-flop an unknown apomorphic species with a known plesiomorphic one - give plesiomorphic species a ? and the other a 1 */				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || sp2>=notu)					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);								sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while (trpd[sp2]==0 || sp2>=notu)					sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp2][ch];				invmatrix[ch][sp2]=matrix[sp2][ch]=1;				taxachange[ch][0]=sp2;				}	/* end routine if all scored species were unknown */			ev=1;			++deltas;			++steps[ch];			++mpd[ch];			}		}	/* this should leave us with a character that needs to be changed OR out of characters */	if (ch>=nchars)	break;			used=0;	/* this tells how many branches are discarded; used > steps IF there are absents */	/* branch length is taken into account by trpd */	equalivector(branches,available,ttlbr);	/* Binary && unordered multistate is Easy */	/* for normal character, have it change until all X states are realized */	if (nstates[ch]==2 || ctype[ch]==1)	{		/* changed 10/14/2003 so that non-apomorphic characters	diagnose 2+ species */		for (st=0; (st<nstates[ch]-1 || der[ch]<=1); st=st)	{			/* There are ttlbr-used branches that could change */			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			/* have binary characters change on branches - if they are not autapomorphic, then they need to diagnose multiple species THIS WAS REMOVED 10/14/2003			else				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (avnodes-used));*/			sp = branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				ev=1;				if (nstates[ch]==2)	invmatrix[ch][sp]=matrix[sp][ch]=1;				else					invmatrix[ch][sp]=matrix[sp][ch]=st+1;				++der[ch];				/* add one to the number of species showing derived condition(s) */				}			else if (sp>notu)	{				/* use st+1 instead of nstates[ch] here - we want only 0Ést+1 not 0Énstates    */				/*		(remember, st has not yet been incremented, so we need st+1) 		   */				/* This section modified 10/14/2003 to make sure characters are not apomorphic */				/* if multistate, then we need at least two iterations */				if (nstates[ch]>2)	{					/* if we have not yet derived all of the states, do it this way 			*/					/* if deriving first state (i.e., st=0), then it is the same as binary		*/					if (st<nstates[ch] && st==0)						evolvebinaryinclade(tree[sp-notu],matrix,ch);					/* if deriving subsequent states, then used change unmodified species to st+1 		*/					else if (st<(nstates[ch]-1) && st>=1)	{						for (c=1; c<=tree[sp-notu][0]; ++c)	{							sp2=tree[sp-notu][c];							if (matrix[sp2][ch]==0)	matrix[sp2][ch]=st+1;							}						}//						evolveunorderedinclade(tree[sp-notu],matrix,ch,st+2,UNKNOWN,INAP);					/* if we have an essentially apomorphic states, then just do it like any other time */					else						evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],UNKNOWN,INAP);					}				else		evolvebinaryinclade(tree[sp-notu],matrix,ch);				for (c=1; c<=tree[sp-notu][0]; ++c)	{					sp2=tree[sp-notu][c];					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					if (invmatrix[ch][sp2]!=0 && (invmatrix[ch][sp2]!=UNKNOWN && invmatrix[ch][sp2]!=INAP))						++der[ch];					else if (invmatrix[ch][sp2]==0)						--der[ch];					/* this will happen only if there are reversals */					}				/* if there was a change, then tally it */				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1) || der[ch]<=1)				removefromivector(branches,sp,a);							if (used<steps[ch])	{				printf("ERROR LINE 954 - there are more changes than deleted branches for Ch%dÉ\n",ch+1);				}			/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				++st;	/* we increment this only if we have made a change */				}			}	/*end derivation of state */		}	/* end loop for binary / unordered characters */		/* Ordered Multistates are tougher */	else if (nstates[ch]>2 && ctype[ch]==0)	{		used=0;		for (st=0; (st<nstates[ch]-1 && (steps[ch]<mxdel && steps[ch]<maxch[ch])); st=st)	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			sp=branches[br];			/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				/* in this case all taxa must be examined just in case the matrix has been recentered due to a negative number */				for (sp2=0; sp2<notu; ++sp2)	{					if (ev==0 && invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					}				ev=1;				}							else if (sp>notu)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])	flip=1;				else				flip=-1;				evolveorderedinclade(tree[sp-notu],matrix,ch,flip, INAP, UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				/* in this case all taxa must be modified just in case the matrix has been recentered due to a negative number */				for (sp2=0; sp2<notu; ++sp2)	{					if (ev==0 && invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					}				}							/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				/* note - do not increment st here - that is done only if a new state is derived */				}			/* check if all states have been derived */			/* note: this is needed only for ordered multistates */			if (steps[ch]>=nstates[ch]-1)	{				for(a=0; a<notu; ++a)	{					if (matrix[a][ch]>st && (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN))						st=matrix[a][ch];					}				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1))				removefromivector(branches,sp,a);			if (used<steps[ch])				printf("ERROR LINE 2145 - there are more changes than deleted branches for Ch%dÉ\n",ch+1);						/* emergency reboot procedure! - clear everything and start over again */			if (used==ttlbr)	{				for (a=0; a<steps[ch]; ++a)	{					sp=taxachange[ch][a];					--mpd[sp];					taxachange[ch][a]=0;					}				deltas=deltas-steps[ch];				st=steps[ch]=used=0;				for (sp=0; sp<notu; ++sp)					if (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN)						invmatrix[ch][sp]=matrix[sp][ch]=0;				for (sp=0; sp<ttlbr; ++sp)	branches[sp]=available[sp];				}			}		/* if there are many states and few taxa, then you do not want to mess with this anymore.  Any changes will either eliminate extreme states,		or simply shift the state up or down one (resulting in no observable change once standardized.  So, if steps >= half the taxa, then shut it down */				}	/* end loop for ordered multistates */	}	/* end derivation of all character states *//* Step #2: make sure that each apomorphic species has a derivation */for (sp=0; (sp<notu+nodes && deltas<maxstp); ++sp)	{	if (mpd[sp]==0 && trpd[sp]>0)	{		while (mpd[sp]==0)	{			ev=0;			ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));			while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))				ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));						if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				if (nstates[ch]==2)						invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);				else if (ctype[ch]==1)					invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);				else if (ctype[ch]==0)	{					invmatrix[ch][sp]=matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);					/* make sure no negative numbers are kept! */					multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);					}				ev=1;	/* this means that there was a change */				}						else if (sp>notu)	{				d=0;				/* make sure that there are taxa with scorable conditions for this character 		*/				/* and also that not all the descendants have changed already for this character 	*/				/* (the latter can be omitted as evolution cannot know this - but it makes the 		*/				/* output easier to compare to empirical studies.)									*/						for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;					else	{						for (c=0; c<steps[ch]; ++c)	{							if (taxachange[ch][c]==sp2)	{								++d;								c=steps[ch];								}							}						}		/* if any taxa have not yet changed, then d < clade diversity */					}	/* end search for scored taxa */					/* if d is less than clade diversity, then proceed with change */				if (d<tree[sp-notu][0])	{					/* if character is an unordered multistate, then we need an array	*/					/* that tells how each state changed withing the clade				*/					if (ctype[ch]==1)	{						/* routine for unordered multistates */						if (nstates[ch]>2)	{							evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);							}						/* routine for binaries */						else	{							evolvebinaryinclade(tree[sp-notu],matrix,ch);							}						}	/* end routine for unordered / binary characters */					/* routine for ordered multistate */					else {						/* flip is used only for multistates */						flip = ((int) (100 * rand() / RAND_MAX));						if (flip<bias[ch])	flip=1;						else				flip=-1;						evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					/* now make sure that there was change */					for (c=0; c<notu; ++c)	{						if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;						invmatrix[ch][c]=matrix[c][ch];						}					}	/* end conditional loop */				}	/* end routine for clade */			/* if there was a change, then ev = 1.  Now tally the information */			if (ev==1)	{				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++mpd[sp];				++deltas;				}	/* add changes if there actually was a change */			}	/* routine is repeated until an apomorphy is acquired */					}	/* end derivation of apomorphy for this branch */	}	/* end derivation for each apomorphic branch *//* Step #3: DO ADDITIONAL STEPS NOW */for (deltas=deltas; deltas < maxstp; deltas=deltas)	{	/* first choose a character */	ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))		ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	/**************************************************************************/	/* do not change the character on a branch where it already has changed */	for (br=0; br<ttlbr; ++br)	branches[br]=available[br];		used=0;	/* used will tally the number of deleted branches */	for (d=0; d<steps[ch]; ++d)	{		for (c=0; c<(ttlbr-used); ++c)	{			/* if branch with change is found, delete it from possible changes */			if (branches[c]==taxachange[ch][d])	{				for (a=c; a<ttlbr-1; ++a)	branches[a]=branches[a+1];				/* some taxa will be in 2+ times - step back to delete them all */				--c;				branches[ttlbr-(used+1)]=-1;				++used;				}			}		}	/* choose a branch from one available */	/* used will be equal to or greater than steps[ch] (due to long branches) */	br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));	sp = branches[br];	/* this shouldn't be necessary, but occassionaly the random number generator */	/* produces a number outside of the proscribed limits */	while (trpd[sp]==0 || br>=(ttlbr-used))	{		br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));		sp = branches[br];		}	ev=0;	if (nstates[ch]==2)	{		/* routine for binary characters */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);			ev=1;			}		/* routine for clade */		else if (sp>=notu)	{			evolvebinaryinclade(tree[sp-notu],matrix,ch);			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;				invmatrix[ch][sp2]=matrix[sp2][ch];				}				}	/* end routine for clade */		}	/* Ordered Multistates */	else if (ctype[ch]==0)	{		flip = ((int) (100 * rand() / RAND_MAX));		if (flip<bias[ch])						flip=1;		else									flip=-1;				/* routine for species */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;			if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;			else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;			ev=1;			}		/* routine for clade */		else if (sp>=notu)	{			/* make sure that not all descendants have already changed! */			d=0;			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;				else	{					for (c=0; c<steps[ch]; ++c)	{						if (taxachange[ch][c]==sp2)	{							++d;							c=steps[ch];							}	/* end test of whether particular change matches species */						}	/* end search through each step */					}	/* end search for unchanged taxa */				}			if (d<tree[sp-notu][0])	{				evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				}			/* now make sure that there was change */			for (c=0; c<notu; ++c)	{				if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;				invmatrix[ch][c]=matrix[c][ch];				}			}	/* end routine for clade */		}	/** END ROUTINE FOR ORDERED MULTISTATES **/	/* Unordered Multistate Characters */	else if (ctype[ch]==1)	{		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);			ev=1;			}					else if (sp>notu)	{			evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);			/* make sure that there is change */			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	{						invmatrix[ch][sp2]=matrix[sp2][ch];						ev=1;						}					}				}			}	/* end unordered change for a clade */			/* if change is made, tally */		}	/* end unordered change */	/* if ev = 1, then there has been a change.  Tally it */	if (ev==1)	{		++deltas;		taxachange[ch][steps[ch]]=sp;		++steps[ch];		++mpd[sp];		if (deltas >= minstp && deltas <= maxstp)	{			compatibility[deltas-minstp]=a=nu_comp(nstates, notu, matrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);			}		}		}	/* end additional steps */free_ivector(der);free_ivector(mpd);free_ivector(trpd);free_ivector(steps);free_ivector(available);free_ivector(branches);free_ivector(aptaxa);free_imatrix(taxachange,nchars,mxdel);free_lmatrix(invmatrix,nchars, notu);return compatibility;}/* Evolves a single character given a rate, a tree and a matrix, leaving the rest of the matrix in tact/* Returns a matrix for notu taxa with nchars characters.  Gaps and missing are kept in place./* Requires:	CH - the character in question.	PI - the per branch rate of character change (a real number).	tree - a matrix containing members of each node (with ALL species belonging to the clade);		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[notu-1]) gives it for species;			the second line (tree[notu]) gives it for internal nodes;	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/long **EvolveCharacterRate(int CH, double PI, long **tree, int notu, long **matrix, int *nstates, int *ctype, int *bias, int UNKNOWN, int INAP){int		a, b, c, d, st, sc, ttlbr;int		flip, sp, sp2, nodes, branches;int		*available, *unord, *undum, *trpd, *change;long	*character;/* find the number of nodes and their diversities */nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}/* allocate memory for branch lengths */trpd=ivector(nodes+notu);/* allocate memory for arrays to be used for unordered multistates */unord=ivector(nstates[CH]);undum=ivector(nstates[CH]);trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	}/* allocate memory for arrays containing branches needing changes */available=ivector(ttlbr);/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */b=0;for (a=1; a<nodes; ++a)	{	for (c=0; c<trpd[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		available[b]=a;		++b;		}	}/* allocate memory for branches that do change */change=ivector(b);branches=0;for (a=0; a<b; ++a)	{	c=(int)((double)rand() / ((double)RAND_MAX + 1) * 10000);	if (c<(PI*10000))	{		change[branches]=available[a];		++branches;		}	}/* allocate character array and clear it */character=lvector(notu);for (a=0; a<notu; ++a)	{	if (matrix[a][CH]!=INAP && matrix[a][CH]!=UNKNOWN)	{		character[a]=0;		}	else	character[a]=matrix[a][CH];	}/* now, make changes */for (d=0; d<branches; ++d)	{	sp=change[d];	/* routine for binary characters */	if (nstates[CH]==2)	{		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			if (character[sp]==0)	character[sp]=1;			else					character[sp]=0;			}	/* end binary change for species */		/* routine for clade */		else	{			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))	{					if (character[sp]==0)	character[sp2]=1;					else					character[sp2]=0;					}				}	/* end binary change for species within clade */			}	/* end binary change for clade */		}	/* end routine for binary characters */			/** routine for unordered multistate **/	else if (ctype[CH]==1)	{		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			for (b=character[sp]; b==character[sp]; b=b)	{				b=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[CH]);				}			character[sp]=b;			}	/* end unordered multistate change for species */		/* routine for clade */		else	{			/* first create an array stating which states change to which 	*/			for (a=0; a<nstates[CH]; ++a)	undum[a]=0;			/* now come up with new transitions for this clade 				*/			for (a=0; a<nstates[CH]; ++a)	{				b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[CH]-a));				unord[a]=undum[b];				/* do not let unord[a]==a */				while (unord[a]==a || a>=nstates[CH])	{					b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[CH]-a));					unord[a]=undum[b];					}				/* unord[0] cannot be a (otherwise we wouldn't have this problem */				/* therefore, flip-flop unord[0] and unord[a] */				if (unord[a]==a && a==(nstates[CH]-1))	{					unord[a]=unord[0];					unord[0]=a;					}									/* remove assigned state from possibilities */				for (c=b; c<nstates[CH]; ++c)					undum[c]=undum[c+1];				/* reboot if the final possible state matches original */				if (a==(nstates[CH]-2) && (a+1)==undum[0])	{					a=-1;	/* will increment to 0*/					for (b=0; b<nstates[CH]; ++b)	undum[b]=b;					}				}	/* end assignment of state changes */						/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))					character[sp2]=unord[character[sp2]];				}	/* end unordered multistate change for species within clade */			}	/* end unordered multistate change within clade */		}	/* end routine for unordered multistate characters */			/** routine for ordered multistate **/	else if (ctype[CH]==0)	{		/* determine whether state increases or decreases */		for (flip=-1; flip<0 || flip>99; flip=flip)	{			flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);			}		if (flip<bias[CH])	flip=1;		else				flip=-1;		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			character[sp]=character[sp]+flip;			}	/* end ordered multistate change for species */		/* routine for clade */		else	{			/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))					character[sp2]=character[sp2]+flip;				}	/* end ordered multistate change for species within clade */			}	/* end ordered multistate change within clade */				/* Now, make sure that the lowest value is 0, not -1 or 1 */		st=nstates[CH];		for (a=0; a<notu; ++a) {			if (character[a]<st)	st=character[a];			}		if (st!=0)	{			for (a=0; a<notu; ++a) {				character[a]=character[a]-st;				}			}		}	/* end routine for ordered multistate characters */	}for (sp=0; sp<notu; ++sp)	matrix[sp][CH]=character[sp];free_ivector(trpd);free_ivector(available);free_ivector(unord);free_ivector(undum);free_ivector(change);free_lvector(character);return matrix;}/* Evolves a single character given a number of stpes, a tree and a matrix, leaving the rest of the matrix in tact/* Returns a matrix for notu taxa with nchars characters.  Gaps and missing are kept in place./* Requires:	CH - the character in question.	PI - the per branch rate of character change (a real number).	tree - a matrix containing members of each node (with ALL species belonging to the clade);		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[notu-1]) gives it for species;			the second line (tree[notu]) gives it for internal nodes;	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/long **EvolveCharacterSteps(int CH, int PI, long **tree, int notu, long **matrix, int *nstates, int *ctype, int *bias, int UNKNOWN, int INAP){int		a, b, c, d, st, sc, ttlbr;int		flip, sp, sp2, nodes, branches;int		*available, *unord, *undum, *trpd, *change;long	*character;/* find the number of nodes and their diversities */nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}/* allocate memory for branch lengths */trpd=ivector(nodes+notu);/* allocate memory for arrays to be used for unordered multistates */unord=ivector(nstates[CH]);undum=ivector(nstates[CH]);trpd[notu]=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors */	}/* allocate memory for arrays containing branches needing changes */ttlbr=branchnumber(tree,notu);available=ivector(ttlbr);/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */b=0;for (a=1; a<nodes; ++a)	{	for (c=0; c<trpd[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		available[b]=a;		++b;		}	}/* allocate memory for branches that do change */change=ivector(PI);branches=0;for (a=0; a<PI; ++a)	{	c=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-a));	change[branches]=available[c];	++branches;	}/* allocate character array and clear it */character=lvector(notu);for (a=0; a<notu; ++a)	{	if (matrix[a][CH]!=INAP && matrix[a][CH]!=UNKNOWN)	{		character[a]=0;		}	else	character[a]=matrix[a][CH];	}/* now, make changes */for (d=0; d<PI; ++d)	{	sp=change[d];	/* routine for binary characters */	if (nstates[CH]==2)	{		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			character[sp]=swap(character[sp]);			}	/* end binary change for species */		/* routine for clade */		else	{			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))	{					character[sp2]=swap(character[sp2]);					}				}	/* end binary change for species within clade */			}	/* end binary change for clade */		}	/* end routine for binary characters */			/** routine for unordered multistate **/	else if (ctype[CH]==1)	{		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			for (b=character[sp]; b==character[sp]; b=b)				b=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[CH]);			character[sp]=b;			}	/* end unordered multistate change for species */		/* routine for clade */		else	{			/* first create an array stating which states change to which 	*/			for (a=0; a<nstates[CH]; ++a)	undum[a]=a;			/* now come up with new transitions for this clade 				*/			for (a=0; a<nstates[CH]; ++a)	{				b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[CH]-a));				unord[a]=undum[b];				/* do not let unord[a]==a */				while (unord[a]==a || a>=nstates[CH])	{					b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[CH]-a));					unord[a]=undum[b];					}				/* unord[0] cannot be a (otherwise we wouldn't have this problem */				/* therefore, flip-flop unord[0] and unord[a] */				if (unord[a]==a && a==(nstates[CH]-1))	{					unord[a]=unord[0];					unord[0]=a;					}									/* remove assigned state from possibilities */				for (c=b; c<nstates[CH]; ++c)					undum[c]=undum[c+1];				/* reboot if the final possible state matches original */				if (a==(nstates[CH]-2) && (a+1)==undum[0])	{					a=-1;	/* will increment to 0*/					for (b=0; b<nstates[CH]; ++b)	undum[b]=b;					}				}	/* end assignment of state changes */						/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))					character[sp2]=unord[character[sp2]];				}	/* end unordered multistate change for species within clade */			}	/* end unordered multistate change within clade */		}	/* end routine for unordered multistate characters */			/** routine for ordered multistate **/	else if (ctype[CH]==0)	{		/* determine whether state increases or decreases */		for (flip=-1; flip<0 || flip>99; flip=flip)	{			flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);			}		if (flip<bias[CH])	flip=1;		else				flip=-1;		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			character[sp]=character[sp]+flip;			}	/* end ordered multistate change for species */		/* routine for clade */		else	{			/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))					character[sp2]=character[sp2]+flip;				}	/* end ordered multistate change for species within clade */			}	/* end ordered multistate change within clade */				/* Now, make sure that the lowest value is 0, not -1 or 1 */		st=nstates[CH];		for (a=0; a<notu; ++a) {			if (character[a]<st)	st=character[a];			}		if (st!=0)	{			for (a=0; a<notu; ++a) {				character[a]=character[a]-st;				}			}		}	/* end routine for ordered multistate characters */	}for (sp=0; sp<notu; ++sp)	matrix[sp][CH]=character[sp];free_ivector(trpd);free_ivector(available);free_ivector(unord);free_ivector(undum);free_ivector(change);free_lvector(character);return matrix;}/* evolveorderedinclade - evolve multistate characters within a clade;/* Requires:	clade: a vector giving clade members (from a Venn tree), with clade[0] giving the number of members	matrix: the character matrix	ch: the character being changed;	delta: the increment/decrement;	INAP: code for inapplicable characters	UNKNOWN: code for unknown characters*******************************************************************************************************************************************/void evolveorderedinclade(long *clade, long **matrix, int ch, int delta, int INAP, int UNKNOWN){int	s, sp;for (s=1; s<=clade[0]; ++s)	{	sp=clade[s];	if (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN)		matrix[sp][ch]=matrix[sp][ch]+delta;	}}/* multistatevett - make sure that all states in a multistate are between 0 and #states/* Requires:	matrix: character matrix	ch: character number	st: number of states for character ch	notu: number of taxa in the matrix	INAP: code for inapplicables	UNKNOWN: code for unknown*******************************************************************************************************************************************/void multistatevett (long **matrix, int ch, int st, int notu, int INAP, int UNKNOWN){int	s, mn=st, mx=0;for (s=0; s<notu; ++s)	{	while ((matrix[s][ch]==INAP || matrix[s][ch]==UNKNOWN) && s<notu)	++s;	if (s>=notu)	break;		if (matrix[s][ch]>mx)	mx=matrix[s][ch];	if (matrix[s][ch]<mn)	mn=matrix[s][ch];		}/* two possibilities - we lost the initial 0, so 1 becomes the new 0 OR we have to scale up a negative */if (mn!=0)	{	for (s=0; s<notu; ++s)	{		while ((matrix[s][ch]==INAP || matrix[s][ch]==UNKNOWN) && s<notu)	++s;		if (s>=notu)	break;		matrix[s][ch]=matrix[s][ch]-mn;		}	}/* make sure that there are no states too high *//* this might happen if everything got shifted up one and the minimum now is too low *//* note: if there are three states, then the maximum state should be 2 */ else if (mx==st && mn>0)	{	for (s=0; s<notu; ++s)	{		while ((matrix[s][ch]==INAP || matrix[s][ch]==UNKNOWN) && s<notu)	++s;		if (s>=notu)	break;		matrix[s][ch]=matrix[s][ch]-(mx-st);		}	}/* this also might happen if everything got shifted up one and the minimum now is too low */else if (mx==st && mn==0)	{	for (s=0; s<notu; ++s)	{		while ((matrix[s][ch]==INAP || matrix[s][ch]==UNKNOWN) && s<notu)	++s;		if (s>=notu)	break;		/* all species with matrix[s][ch]=st must have just gotten that condition - reverse those to 1 less than the maximum */		if (matrix[s][ch]==mx)	matrix[s][ch]=st-2;		}	}}/* evolveunorderedinclade - evolve unordered character (binary or multistate) within a clade;/*		this works by randomly assigning a descendant state to each state yielding an array of descendant/*		changes.  If a we have a 3 state character and changes[0]=1, changes[1]=2 and changes[2]=0, then/*		all species in the clade that had 0 now will have 1; those with 1 will have 2; etc.  /* Requires:	clade: a vector giving clade members (from a Venn tree), with clade[0] giving the number of members	matrix: the character matrix	ch: the character being changed;	states: the number of states;	INAP: code for inapplicable characters	UNKNOWN: code for unknown characters/* returns:	matrix modified for new states*******************************************************************************************************************************************/void evolveunorderedinclade(long *clade, long **matrix, int ch, int states, int INAP, int UNKNOWN){int	a, b, s, sp, old, flush;int *changes;changes=ivector(states);flush=0;while (flush==0)	{	for (s=0; s<states; ++s)	changes[s]=s;	for (s=0; s<states; ++s)	{		if (changes[s]==s)	{			a=s;			/* we need to make sure that all states change to a new state (no silent substitutions!)			  */			/* Also, every once in a while the random number generator goes screwy and overshoots - do not let it */			while (a==s || (a<0 || a>=states))	{				a=(int)((double)rand() / ((double)RAND_MAX + 1) * states);				}			/* shuffle character states */			b=changes[s];			changes[s]=changes[a];			changes[a]=b;			}		}	/* debugging fun - it seems that sometimes improper numbers creep into this */	flush=1;	for (s=0; s<states; ++s)	{		if (changes[s]>=states || changes[s]<0)	{			flush=0;			s=states;			}		}	}for (s=1; s<=clade[0]; ++s)	{	sp=clade[s];	if (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN)	{		old=matrix[sp][ch];		matrix[sp][ch]=changes[old];		}	}free_ivector(changes);}/* evolvebinaryinclade - evolve unordered character (binary or multistate) within a clade;/* Requires:	clade: a vector giving clade members (from a Venn tree), with clade[0] giving the number of members	matrix: the character matrix	ch: the character being changed;	INAP: code for inapplicable characters	UNKNOWN: code for unknown characters*******************************************************************************************************************************************/void evolvebinaryinclade(long *clade, long **matrix, int ch){int	s, sp;for (s=1; s<=clade[0]; ++s)	{	sp=clade[s];	if (matrix[sp][ch]==0)		matrix[sp][ch]=1;	else if (matrix[sp][ch]==1)	matrix[sp][ch]=0;	}}/* Turns 0 to 1 and 1 to 0; leaves anything else (? or -, hopefully) alone./* Requires:/*	c - the number to swap;/* Returns:/*	c - the new number.*******************************************************************************************************************************************/long swap(long c){if (c==0)		c=1;else if (c==1)	c=0;return c;}/* Turns c to any number from 0 to X (unordered character change)/* Requires:	c - the number to swap;	X - the number of states;*******************************************************************************************************************************************/long mswap(long c, int x){int	i;/*i=((int) ((X-1) * rand() / RAND_MAX));	*/i = (int)((double)rand() / ((double)RAND_MAX + 1) * x);//if (i>=c && i<(X-1))	++i;//else if (i==(X-1))		i=0;while (i==c || (i<0 || i>=x))	i = (int)((double)rand() / ((double)RAND_MAX + 1) * x);return i;}/* Turns c to c-1 or c+1 (ordered character change)/* Requires:	c - the number to swap;	bias - bias increase/decrease;	this can return -1, so make sure you either want that OR can correct for it!	this also can return values greater than the highest state - make sure you can deal with that!*******************************************************************************************************************************************/long multi(long c, int bias){int	i;	i=((int) (100 * rand() / RAND_MAX));	if (i<bias)	++c;	else		--c;return c;}/* Create a cladistic phylogeny, with no extinction/* Requires:	notu: number of taxa;	tree; the matrix of phylogenetic information;/* Each tree[x][0] gives the number of species in that node;/* Each tree[x][1]..tree[x][i] gives species 1...i in that node, with numbers >=notu being nodes.		Thus, taxon notu is the basal node./* tree[notu-1][0Énotu] gives the branch length of each observed taxon /* tree[notu][0Énotu] gives the branch length of each ancestral taxon*******************************************************************************************************************************************/long **evolvecladogram(int notu, long **tree){int	a, b, c, sp, nodes;tree[nodes=0][0]=2;tree[nodes][1]=0;tree[nodes][2]=1;for (sp=2; sp<notu; ++sp)	{	a = (int)((double)rand() / ((double)RAND_MAX + 1) * sp);	for (b=0; b<=nodes; ++b)	{		for (c=1; c<=tree[b][0]; ++c)	{			if (a==tree[b][c])	{				++nodes;				tree[b][c]=nodes+notu;				c=tree[nodes][0]=2;				tree[nodes][1]=a;				tree[nodes][2]=sp;				b=nodes;				}			}		}	}for (sp=0; sp<notu; ++sp)	tree[notu-1][sp]=1;for (sp=0; sp<nodes; ++sp)	tree[notu][sp]=1;return tree;}double MinRate(int notu){int	a;double	x, R;x=5*notu;R=1/x;x=1000*R;a=x;x=a;R=x/1000;return R;}double MaxRate(int notu, int MXST){int	a;double	x, y, R;y=3*MXST;x=5*notu;R=y/x;x=1000*R;a=x;x=a;R=x/1000;return R;}/* Routine to count the number of non-zero length branches on a simulated tree/*/*	tree: phylogeny/*	notu: number of species*******************************************************************************************************************************************/int branchnumber(long **tree, int notu){int	sp,nodes,ttlbr;/* find the number of nodes and their diversities */nodes=0;for (sp=0; sp<notu; ++sp)	{	if (tree[sp][0]>1)	++nodes;	else				sp=notu;	}/* find the number of non-zero length branches */ttlbr=0;for (sp=0; sp<notu; ++sp)	{	ttlbr=ttlbr+tree[notu-1][sp];	/* array tree[notu-1] gives branch lengths of species */	}for (sp=1; sp<nodes; ++sp)	{	ttlbr=ttlbr+tree[notu][sp];		/* array tree[notu] gives branch lengths of ancestors */	}return ttlbr;}/* EvolveAdditiveDependent - a routine for evolving a dependent color (e.g., feather color) given an independent/*		character (e.g., feathers present) by first evolving a dependent character with as many "presents"/*		as there are taxa for which the dependent character is applicable/* Requires:/*		CH - the characer number/*		PI - number of changes (NOTE: this can be Zero!/*		tree - matrix[i][j] gives the jth member of the ith node/*		notu - number of observed taxa/*		matrix - character state for taxon i, character j/*		nstates - number of states for character k/*		ctype - type (ordered, unordered) for charcter k/*		bias - biased transition for character k/*		UNKNOWN - matrix code for "?"/*		APS - number of otus for which character CH is applicable/* Returns:/*		matrix - original matrix with new character modified.  /************************************************************************************************************/long **EvolveAdditiveDependent(int CH, int PI, long **tree, int notu, long **matrix, int *nstates, int *ctype, int *bias, int UNKNOWN, int INAP, int APS){int		a, b, c, d, der, st, sc, br, ttlbr, TtlAp, delta=0;int		flip, sp, sp2, nodes, used;int		*available, *branches, *unord, *undum, *trpd, *change, *derivation, **descnodes;long	*character, *independent, *nodestate, *nodedepnd;/* evolve an independent character that will yield the same number of dependents as real data */nodes=number_of_nodes(tree,notu);trpd=ivector(notu+nodes);for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors	*/	}ttlbr=0;for (sp=0; sp<(notu+nodes); ++sp)	ttlbr=ttlbr+trpd[sp];available=ivector(ttlbr);branches=ivector(ttlbr);independent=lvector(notu);nodestate=lvector(nodes);nodedepnd=lvector(nodes);descnodes=DescendantNodes(tree,notu);character=lvector(notu);/* allocate memory for arrays to be used for unordered multistates */unord=ivector(nstates[CH]);undum=ivector(nstates[CH]);/* determine how many branches are available for each taxon and node */a=0;for (sp=0; sp<nodes; ++sp)	{	for (b=0; b<trpd[sp+notu]; ++b)	{		branches[a]=available[a]=sp+notu;		++a;		}	}	for (sp=0; sp<notu; ++sp)	{	for (b=0; b<trpd[sp]; ++b)	{		branches[a]=available[a]=sp;		++a;		}	}derivation=ivector(APS);change=ivector(APS);/* Now, sample from available until APS is reached 						*//* first we will do this with no changes for the dependent character 	*//* a is the number of species changed (reversals, too 					*/delta=used=a=0;for (a=0; a!=APS; a=a)	{	/* if one short, grab a species at random until one can gain in parallel */	if (a==APS-1)	{		b=0;		sp=notu;		/* put something in here to make sure that it does not get stuck */		d=0;		while ((b==0 && sp>=notu) && d<2*notu)	{			sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);			++d;			if (trpd[sp]>0 && independent[sp]==0)	{				b=1;				/* make sure that the species has not already changed */				for (c=0; c<delta; ++c)	{					if (sp==change[c])	{						c=delta;						b=0;						}					}				}			else	sp=notu;			}	/* end search for single species to change */		/* count branches */		for (br=0; sp!=branches[br]; ++br);		}	/* if one too many, grab a species at random until one can be reversed  */	else if (a==APS+1)	{		b=0;		sp=notu;		/* put something in here to make sure that it does not get stuck */		d=0;		while ((b==0 && sp>=notu) && d<2*notu)	{			sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);			++d;			if (trpd[sp]>0 && independent[sp]==1)	{				b=1;				/* make sure that the species has not already changed */				for (c=0; c<delta; ++c)	{					if (sp==change[c])	{						c=delta;						b=0;						}					}				}			else	sp=notu;			}	/* end search for single species to change */		/* count branches */		for (br=0; sp!=branches[br]; ++br);		}		else	{		br=ttlbr+1;		while (br<0 || br>=ttlbr)			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));		sp=branches[br];		/* convert random number to a species */		}		used=used+trpd[sp];		/* change the number of taxa from which to sample */		/* remove species (all entries) from possible changes */	for (b=br; b<ttlbr-used; ++b)	{		branches[b]=branches[b+trpd[sp]];		}	branches[b]=-1;		/* make note */	change[delta]=sp;	++delta;	/* if a node, change species within the node */	if (sp>=notu)	{		/* first, modify the node's state - if it goes from 0->1, its a new derivation */		nodestate[sp-notu]=swap(nodestate[sp-notu]);		/* second, update descendant clades of the node (if any) */		for (b=1; b<=descnodes[sp-notu][0]; ++b)	{			sp2=descnodes[sp-notu][b];			nodestate[sp2]=swap(nodestate[sp2]);			}				/* third, change states of species within node */		for (b=1; b<=tree[sp-notu][0]; ++b)	{			sp2=tree[c=sp-notu][b];			independent[sp2]=swap(independent[sp2]);			}		}	/* if a species, then just change the species */	else		independent[sp]=swap(independent[sp]);	/* now find out how many derivations there are */	der=0;	for (b=0; b<delta; ++b)	{		sp=change[b];		if ((sp>=notu && nodestate[sp-notu]==1) || (sp<notu && independent[sp]==1))	{			derivation[der]=sp;			++der;			}		}			/* calculate the number of species that will have secondary traits */	a=0;	for (b=0; b<notu; ++b)	a=a+independent[b];		/* if incorrect number of derived taxa are produced, then try again 			*/	/* if correct number but too few derivations to get # of states, also try again	*/	if ((a>APS || delta==(APS-1)) || (a==APS && der<(nstates[CH]-PI)))	{		for (b=0; b<ttlbr; ++b)	branches[b]=available[b];		independent=clearlvector(independent,notu,0);		nodestate=clearlvector(nodestate,nodes,0);		derivation=clearivector(derivation,APS,0);		change=clearivector(change,APS,0);		a=used=c=delta=der=0;		clearivector(branches,ttlbr,0);		for (sp=0; sp<ttlbr; ++sp)			branches[sp]=available[sp];		}	}	/* end derivation of independent character */	for (sp=0; sp<notu; ++sp)	character[sp]=INAP;for (sp=0; sp<nodes; ++sp)	nodedepnd[sp]=INAP;/* make each derivation its own state	*/for (st=0; st<der; ++st)	{	sp=derivation[st];	/* simple for species */	if (sp<notu)	{		if (st<nstates[CH])	character[sp]=st;		else				character[sp]=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[CH]);		}	/* go through clade - but some species might have lost independent character */	else	{		if (st<nstates[CH])	nodedepnd[sp-notu]=st;		else				nodedepnd[sp-notu]=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[CH]);		for (sp2=1; sp2<=tree[sp-notu][0]; ++sp2)	{			a=tree[sp-notu][sp2];			if (independent[a]==1)	{				if (st<nstates[CH])					character[sp2]=st;				else					character[sp2]=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[CH]);				}			}		}	}if (PI>0)	{	/* redo the available species */	clearivector(available,ttlbr,0);	clearivector(branches,ttlbr,0);	/* Now separate branches for change */	/* make sure that it is not one of the derivation branches */	TtlAp=0;	for (sp=0; sp<nodes; ++sp)	{		/* include nodes that have independent states */		if (nodestate[sp]==1)	{			c=0;			/* der gives the number of derivations */			/* exclude branches where independent kicks in */			for (sp2=0; sp2<der; ++sp2)	{				if ((sp+notu)==derivation[sp2])	{					c=1;					sp2=der;					}				}			if (c==0)	{				for (b=0; b<trpd[sp+notu]; ++b)	{					branches[TtlAp]=available[TtlAp]=sp+notu;					++TtlAp;					}				}			}	/* End test of node with derived condition */		}		/* Now do this for OTUs */	for (sp=0; sp<notu; ++sp)	{		/* include otus that have independent states */		if (independent[sp]==1)	{			c=0;			/* der gives the number of derivations */			/* exclude branches where independent kicks in */			for (sp2=0; sp2<der; ++sp2)	{				if (sp==derivation[sp2])	{					c=1;					sp2=der;					}				}			/* if c=0 then the character can change on this branch */			if (c==0)	{				for (b=0; b<trpd[sp]; ++b)	{					branches[TtlAp]=available[TtlAp]=sp;					++TtlAp;					}				}			}	/* End test of species with derived condition */		}	free_ivector(change);	change=ivector(PI);	used=0;	for (st=0; st<PI; ++st)	{		br=-1;		for (br=-1; br<0 || br>=TtlAp; br=br)			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (TtlAp-used));		sp=change[st]=branches[br];		used=used+trpd[sp];		for (b=br; b<TtlAp-used; ++b)	branches[b]=branches[b+trpd[sp]];		}/* now make changes */	for (d=0; d<PI; ++d)	{		sp=change[d];		/* routine for binary characters */		if (nstates[CH]==2)	{			/* routine for species */			if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{				if (character[sp]==0)	character[sp]=1;				else					character[sp]=0;				}	/* end binary change for species */			/* routine for clade */			else	{				/* first change node */				if (nodedepnd[sp-notu]==0)	nodedepnd[sp-notu]=1;				else						nodedepnd[sp-notu]=0;				/* now change descendants */				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))	{						if (character[sp]==0)	character[sp2]=1;						else					character[sp2]=0;						}					else if (sp2>=notu)	{						if (nodedepnd[sp-notu]==0)	nodedepnd[sp2-notu]=1;						else						nodedepnd[sp2-notu]=0;						}					}	/* end binary change for species within clade */				}	/* end binary change for clade */			}	/* end routine for binary characters */					/** routine for unordered multistate **/		else if (ctype[CH]==1)	{			/* routine for species */			if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{				for (b=character[sp]; b==character[sp]; b=b)					b=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[CH]);				character[sp]=b;				}	/* end unordered multistate change for species */			/* routine for clade */			else	{				/* first create an array stating which states change to which 	*/				for (a=0; a<nstates[CH]; ++a)	undum[a]=a;				/* now come up with new transitions for this clade 				*/				for (a=0; a<nstates[CH]; ++a)	{					b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[CH]-a));					unord[a]=undum[b];					/* do not let unord[a]==a */					while (unord[a]==a || a>=nstates[CH])	{						b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[CH]-a));						unord[a]=undum[b];						}					/* unord[0] cannot be a (otherwise we wouldn't have this problem */					/* therefore, flip-flop unord[0] and unord[a] */					if (unord[a]==a && a==(nstates[CH]-1))	{						unord[a]=unord[0];						unord[0]=a;						}											/* remove assigned state from possibilities */					for (c=b; c<nstates[CH]; ++c)						undum[c]=undum[c+1];					/* reboot if the final possible state matches original */					if (a==(nstates[CH]-2) && (a+1)==undum[0])	{						a=-1;	/* will increment to 0*/						for (b=0; b<nstates[CH]; ++b)	undum[b]=b;						}					}	/* end assignment of state changes */								/* now make changes */				/* change node first */				nodedepnd[sp-notu]=unord[nodedepnd[sp-notu]];				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))						character[sp2]=unord[character[sp2]];					/* change descendants node */					else if (sp2>=notu)						nodedepnd[sp2-notu]=unord[nodedepnd[sp2-notu]];					}	/* end unordered multistate change for species within clade */				}	/* end unordered multistate change within clade */			}	/* end routine for unordered multistate characters */					/** routine for ordered multistate **/		else if (ctype[CH]==0)	{			/* determine whether state increases or decreases */			for (flip=-1; flip<0 || flip>99; flip=flip)	{				flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);				}			if (flip<bias[CH])	flip=1;			else				flip=-1;			/* routine for species */			if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{				character[sp]=character[sp]+flip;				}	/* end ordered multistate change for species */			/* routine for clade */			else	{				nodedepnd[sp-notu]=nodedepnd[sp-notu]+flip;				/* now make changes */				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))						character[sp2]=character[sp2]+flip;					else if (sp2>=notu)	{						nodedepnd[sp2-notu]=nodedepnd[sp2-notu]+flip;						}					}	/* end ordered multistate change for species within clade */				}	/* end ordered multistate change within clade */						/* Now, make sure that the lowest value is 0, not -1 or 1 */			st=nstates[CH];			for (a=0; a<notu; ++a) {				if (character[a]<st)	st=character[a];				}			if (st!=0)	{				for (a=0; a<notu; ++a) {					character[a]=character[a]-st;					}				}			}	/* end routine for ordered multistate characters */		}	}	for (sp=0; sp<notu; ++sp)	matrix[sp][CH]=character[sp];/*available, *branches, *unord, *undum, *trpd, *change, *derivation, **descnodes;*character, *independent, *nodestate*/free_ivector(available);free_ivector(branches);free_ivector(unord);free_ivector(undum);free_ivector(trpd);free_ivector(change);free_ivector(derivation);free_lvector(character);free_lvector(independent);free_lvector(nodestate);free_imatrix(descnodes,nodes,nodes);return matrix;}/* DescendantNodes/* Routine to calculate the number of nodes descended from a more basal node given a VennTree/* Requires:/*		tree - a matrix in which row i gives the j descended OTUs/*		notu - number of otus/* Returns:/*		descnodes - a matrix in which row i gives the j descended nods/********************************************************************************************************/int	**DescendantNodes (long ** tree, int notu)	{int	a, b, c;int	species, nodes;int	**descnodes;nodes=number_of_nodes(tree,notu);descnodes=imatrix(nodes,nodes);for (a=nodes-1; a>0; --a)	{	species=tree[a][1];	for (b=a-1; b>=0; --b)	{		for (c=1; c<=tree[b][0]; ++c)	{			if (species==tree[b][c])	{				++descnodes[b][0];				descnodes[b][descnodes[b][0]]=a;				c=tree[b][0];				}			}		}	}return descnodes;}/* number_of_nodes/* Routine to calculate the number of nodes descended from a more basal node given a VennTree/* Requires:/*		tree - a matrix in which row i gives the j descended OTUs/*		notu - number of otus/* Returns:/*		nodes - the number of nodes/********************************************************************************************************/int number_of_nodes(long ** tree, int notu){int	a, nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}return nodes;}/* getfossilparams - routine to get speciation, extinction, preservation and variable preservation ratesreturns - mbl[0] - input cladogenesis rate        - mbl[1] - input extinction rate        - mbl[2] - input preservation rate        - mbl[3] - input variable preservation rate******************************************************************************************/double *getfossilparams(){char	r;double	*mbl;mbl=dvector(5);cleardvector(mbl,5,2);printf("When simulating fossil taxa, species will be sampled over time until\n");printf("\tthe simulated sample size equals the observed sample size.\n");printf("\tPreservation, extinction and origination rates affect how many true\n");printf("\tspecies are needed to sample X species.  This actually has little affect\n");printf("\talthough it is easier to get patterns suggesting correlated evolution \n");printf("\twhen some branches are much longer than others.  Nevertheless, we suggest\n");printf("\tusing empirically derived rates as models for these analyses.  For methods\n");printf("\tdoing this, see Foote [1997 Paleobiology 23:278-300].\n\n");while (mbl[0]<=0 || mbl[0]>=1)	{	printf("Enter the cladogenesis rate (greater than 0 and less than 1.0): ");	scanf("%lf",&mbl[0]);	printf("\n");		if (mbl[0]<=0 || mbl[0]>=1)	printf("Enter a number between 0 and 1!\n");	}while (mbl[1]<=0 || mbl[1]>=1)	{	printf("Enter the extinction rate (greater than 0 and less than 1.0): ");	scanf("%lf",&mbl[1]);	printf("\n");		if (mbl[1]<=0 || mbl[1]>=1)	printf("Enter a number between 0 and 1!\n");	}while (mbl[2]<=0 || mbl[2]>=1)	{	printf("Enter the preservation rate (greater than 0 and less than 1.0): ");	scanf("%lf",&mbl[2]);	printf("\n");		if (mbl[2]<=0 || mbl[2]>=1)	printf("Enter a number between 0 and 1!\n");	}printf("\If you would like variable preservation, enter 'y', otherwise enter 'n':  ");scanf("%s",&r);printf("\n");if (r=='y' || r =='Y')	{	printf("Enter the variance in preservation rate (greater than 0 and less than 1.0): ");	scanf("%lf",&mbl[3]);	printf("\n");		if (mbl[3]<=0 || mbl[3]>=1)	printf("Enter a number between 0 and 1!\n");	}else	mbl[3]=0.0;while (mbl[4]!=0 && mbl[4]!=1)	{	printf("Enter 1 for anagenetic/bifurcating speciation or 0 for budding speciation: ");	scanf("%lf",&mbl[4]);	printf("\n");		if (mbl[4]!=0 && mbl[4]!=1)	printf("Enter 0 or 1!\n");	}return	mbl;}	/* end gathering of parameters for sampling fossil taxa */void derive_each_char(long **matrix, long **invmatrix, int **taxachange, int *nstates, int *ctype, int *maxch, int *steps, int *bias, int *aptaxa, int *mpd, int *trpd, int notu, int nchars, int maxstp, int mxdel, int UNKNOWN, int INAP, long **tree, int *branches, int *available, int nodes, int ttlbr){int	a, b, c, u, deltas=0;int	br, ev, ch, st, sp, sp2, best, clse, used, flip;for (ch=0; (ch<nchars && deltas<maxstp); ++ch)	{	while (maxch[ch]==0 && ch<nchars)	++ch;	if (ch>=nchars)			break;	steps[ch]=st=0;	clearivector(taxachange[ch],mxdel,-1);	ev=0;			/* make sure that inapplicable characters have at least one taxon that can be changed */	if (aptaxa[ch]<notu)	{		/* count unknowns - these will be put back in later */		u=0;		for (a=0; a<notu; ++a)	if (matrix[a][ch]==UNKNOWN)	++u;		/* now find a node that has similar diversity */		clse=RAND_MAX;				/* start from the bottom if most taxa are scored */		if (aptaxa[ch]>(notu/2))	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==(notu-aptaxa[ch]))	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs((notu-aptaxa[ch])-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}		/* start from the top otherwise */		else	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==aptaxa[ch])	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs(aptaxa[ch]-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}				for (sp=0; sp<notu; ++sp)	{			if (aptaxa[ch]>(notu/2))	matrix[sp][ch]=0;			else						matrix[sp][ch]=INAP;			}		for (a=1; a<tree[best][0]; ++a)	{			sp=tree[best][a];			matrix[sp][a]=0;			}		}	/* end initial creation of inapplicable character */		/* make autapomorphic characters change on one species only */	/* invariants do not change at all */	for (ch=ch; maxch[ch]<=1; ++ch)	{		/* skip invariants and make autapomorphies autapomorphic */		if	(maxch[ch]==1)	{			c=0;			/* we will sample only from otus here - so do not include clades in branches array! */			/* this part rewritten with Cubs winning 7-0 against the Marlins in Game 4 */			for (sp=0; sp<notu; ++sp)				if ((matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP) && trpd[sp]>0)	++c;			if (c>0)	{				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || (trpd[sp]==0 || sp>=notu))					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=1;				taxachange[ch][0]=sp;				}			/* if only cells belong to species with 0 length branches */			if (c==0)	{				/* flip-flop an unknown apomorphic species with a known plesiomorphic one - give plesiomorphic species a ? and the other a 1 */				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || sp2>=notu)					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);								sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while (trpd[sp2]==0 || sp2>=notu)					sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp2][ch];				invmatrix[ch][sp2]=matrix[sp2][ch]=1;				taxachange[ch][0]=sp2;				}	/* end routine if all scored species were unknown */			ev=1;			++deltas;			++steps[ch];			++mpd[ch];			}		}	/* this should leave us with a character that needs to be changed OR out of characters */	if (ch>=nchars)	break;			used=0;	/* this tells how many branches are discarded; used > steps IF there are absents */	/* branch length is taken into account by trpd */	equalivector(branches,available,ttlbr);	/* Binary && unordered multistate is Easy */	/* for normal character, have it change until all X states are realized */	if (nstates[ch]==2 || ctype[ch]==1)	{		for (st=0; st<nstates[ch]-1; st=st)	{			/* There are ttlbr-used branches that could change */			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			sp = branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				ev=1;				invmatrix[ch][sp]=matrix[sp][ch]=st+1;				}			else if (sp>notu)	{				/* use st+1 instead of nstates[ch] here - we want only 0Ést+1 not 0Énstates */				/*		(remember, st has not yet been incremented, so we need st+1 		*/				if (st>0)	{					for (b=1; b<=tree[sp-notu][1]; ++b)	{						sp2=tree[sp-notu][b];						if (matrix[sp2][ch]==0)	matrix[sp2][ch]=st+1;						}					}				else		evolvebinaryinclade(tree[sp-notu],matrix,ch);				for (c=0; c<notu; ++c)	{					if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;					invmatrix[ch][c]=matrix[c][ch];					}				/* if there was a change, then tally it */				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1))				removefromivector(branches,sp,a);							if (used<steps[ch])	{				printf("ERROR LINE 954 - there are more changes than deleted branches for Ch%dÉ\n",ch+1);				}			/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				++st;	/* we increment this only if we have made a change */				}			}	/*end derivation of state */		}	/* end loop for binary / unordered characters */		/* Ordered Multistates are tougher */	else if (nstates[ch]>2 && ctype[ch]==0)	{		used=0;		for (st=0; (st<nstates[ch]-1 && (steps[ch]<mxdel && steps[ch]<maxch[ch])); st=st)	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			sp=branches[br];			/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				ev=1;				}							else if (sp>notu)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])	flip=1;				else				flip=-1;				evolveorderedinclade(tree[sp-notu],matrix,ch,flip, INAP, UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				}							for (c=0; c<notu; ++c)	{				if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;				invmatrix[ch][c]=matrix[c][ch];				}			/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				/* note - do not increment st here - that is done only if a new state is derived */				}			/* check if all states have been derived */			/* note: this is needed only for ordered multistates */			if (steps[ch]>=nstates[ch]-1)	{				for(a=0; a<notu; ++a)	{					if (matrix[a][ch]>st && (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN))						st=matrix[a][ch];					}				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1))				removefromivector(branches,sp,a);			if (used<steps[ch])				printf("ERROR LINE 2145 - there are more changes than deleted branches for Ch%dÉ\n",ch+1);						/* emergency reboot procedure! - clear everything and start over again */			if (used==ttlbr)	{				for (a=0; a<steps[ch]; ++a)	{					sp=taxachange[ch][a];					--mpd[sp];					taxachange[ch][a]=0;					}				deltas=deltas-steps[ch];				st=steps[ch]=used=0;				for (sp=0; sp<notu; ++sp)					if (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN)						invmatrix[ch][sp]=matrix[sp][ch]=0;				for (sp=0; sp<ttlbr; ++sp)	branches[sp]=available[sp];				}			}		/* if there are many states and few taxa, then you do not want to mess with this anymore.  Any changes will either eliminate extreme states,		or simply shift the state up or down one (resulting in no observable change once standardized.  So, if steps >= half the taxa, then shut it down */				if (steps[ch]>(notu/2))	mxdel=steps[ch];				}	/* end loop for ordered multistates */	}	/* end derivation of all character states */}