/* evolvetreeVenn - Evolves a paleontological tree, with notu taxa sampled over time, output as Venn tree./* Requires:	notu - # of sampled taxa/*				MBL - simulation parameters where	 				MBL[0] (mu) - Speciation rate/*					MBL[1] (lmbd) - Extinction rate/*					MBL[2] (fr) - Preservation rate/*					MBL[3] (vr) - Variance in preservation rate				FOSSILS - (1) fossils sampled, (0) no fossils sampled/*				speciation - (1) bifurcation (0) budding cladogenesis/* Major Rewrite of Sampled Tree Construction 02/2003/* Rewritten to use real numbers from a single array (MBL)				tree[0][0]Étree[clades-1][0] gives TOTAL number of descendants of a node;				tree[0][1Étree[0][0]]Étree[clades-1][1Étree[clades-1][0]] give desendants where					0ÉOTUs-1 are taxon numbers;				tree[OTUs-1][0ÉOTUs-1] give branch lengths of sampled taxa;				tree[OTUS][0Éclades-1] give branch lengths of unsampled taxa;				tree[OTUs+1][0ÉOTUs-1] give first appearances of sampled taxa;				tree[OTUs+2][0ÉOTUs-1] give last appearances of sampled taxa;*******************************************************************************************************/long **evolvetreeVenn(int OTUs, double *MBL, int FOSSILS){long	attempts, base=100000, mu, lmbd,fr, vr, speciation;int		a, b, c, d, ee, charstandard, ch, latest, mxdv=6, chucks, brats;int		clade, otu, otu2, htu, sampled, initdiv, standingdiv, cumulativediv, stage, newby;int		species, anc, speciate, extinct, change, find, testnode, plesion, found0, oldfirst;int		reboot;int		sp, sp2, nodes, found;int		mxtaxa, mxstnd;int		*available, *f1, **forefathers, *ancestor;int		*extants, *observed, *obsbl, *commonanc, *bl;int		*fa, *la, *dbas;double	*tor, *tex;int		**pdmat, **camat;long	**tree;double	v, x, y, mod;mu=base*MBL[0];		/* origination rate			*/lmbd=base*MBL[1];	/* extinction rate			*/fr=base*MBL[2];		/* frequency of sampling	*/vr=base*MBL[3];		/* variance in sampling		*/speciation=MBL[4];	/* budding vs. bifurcation	*/v=expectedpropsampled(MBL[1],MBL[2]);v=1/v;mxtaxa=10*v*OTUs;mxtaxa=10*v*OTUs;/*if (FOSSILS=1)	mxstnd=2*OTUs;	*//*else			mxstnd=3*OTUs;	*/mxstnd=3*OTUs;/* arrays for observed taxa - set to OTUs*/observed=ivector(2*OTUs);	/* shouldn't need this	*/obsbl=ivector(2*OTUs);		/* shouldn't need this	*/commonanc=ivector(2*OTUs);	/* shouldn't need this	*/fa=ivector(2*OTUs);			/* shouldn't need this	*/la=ivector(2*OTUs);			/* shouldn't need this	*/dbas=ivector(2*OTUs);		/* shouldn't need this	*//* array for all elements of the tree */bl=ivector(2*OTUs);/* array for standing taxa - set to mxstnd*/extants = ivector(mxstnd+1);/* arrays for sampled and obsbl taxa - set to mxtaxa */ancestor=ivector(mxtaxa);	/* ancestor of each taxon */available=ivector(mxtaxa);f1=ivector(mxtaxa);		/* number of descendants for each taxon */tor=dvector(mxtaxa);		/* true origination - this is a real number */tex=dvector(mxtaxa);		/* true extinction - this is a real number */reboot=0;a=b=c=d=ee=anc=0;charstandard = 1; /*charbase/100;*/sp = ch = change = find = 0;clearivector(observed,OTUs,-1);clearivector(obsbl,OTUs,-1);clearivector(ancestor,mxtaxa,-1);clearivector(extants,mxstnd+1,-1);latest = -1;attempts = initdiv = standingdiv = cumulativediv = stage = extants[0] = sampled = 0;while (sampled < OTUs)	{	initdiv = standingdiv+1;	for (sp=0; (sp<=standingdiv && cumulativediv<mxtaxa); ++sp)	{	/********************************************/	/*			Does Lineage Speciate?			*/	/********************************************/		if (sp<0 || sp>mxstnd)	{			printf("ERROR 108: %d is the wrong number of species!\n", sp);			exit(0);			}		species = extants[sp];		tex[species]=stage+1;				if (f1[species]<mxdv)	speciate = (((unsigned int) rand())%base);		else					speciate = base;		mod=mu;		if (sp>=initdiv)			mod=((stage+1)-tor[species])*mod;				if (speciation==1)	ee=2;		else				ee=1;		if (speciate <= mod && (standingdiv<(mxstnd-ee)))		{			brats=1;			if (speciation==1)	brats=2;			else	{				y=lmbd;				y=y/base;				if (tor[species]>stage)	v=(stage+1)-tor[species];				else					v=1;				x=Poisson(y, v, 2);				if (speciate<x*base)	brats=2;				}			/* go through each descendant */			for (a=0; a<brats; ++a)	{				++standingdiv;				++cumulativediv;				extants[standingdiv] = cumulativediv;				if (cumulativediv > mxtaxa)	{					printf("ERROR Evolve 786 - In replication XXX");					printf(", more than %3d species were generated.  \n",mxtaxa);					sampled=OTUs;					exit(0);						}				if (standingdiv<0 || standingdiv>mxstnd)	{					printf("ERROR 792:  Standing diversity too high at %2d\n",standingdiv);					sampled=OTUs;					exit(0);						}							if (cumulativediv<0 || cumulativediv>=mxtaxa || species<0 || species>=mxtaxa)	{					printf("ERROR 797 - ancestor index out of range at %d and %d\n",species,cumulativediv);					sampled=OTUs;					exit(0);						}				ancestor[cumulativediv] = species;				anc = species;				++f1[anc];						/*******************************************************************************/		/* Ancestors become pseudo-extinct at bifurcation if that is what is happening */		/*******************************************************************************/				if (speciation==1 && a==1)	{					tex[anc]=tor[cumulativediv]=tor[cumulativediv-1];					}				else	{					/* to must be after ancestor's to */					if (tor[anc]>stage)	v=((stage+1)-tor[anc])*base;					else				v=base;					b=v;					y = (((unsigned int) rand())%b);					if (tor[anc]<=stage)	tor[cumulativediv]=stage+(y/base);					else				tor[cumulativediv]=tor[anc]+(y/base);					}				}			}		if (FOSSILS==0 && standingdiv>=OTUs-1)	sp = initdiv;	/* quit if enough taxa are alive */		}	/****  End Speciation Round ****/ 				if (FOSSILS==1)	{		/********************************************/		/*				 Do Sampling				*/		/*  Separated from Speciation Loop 1/3/97   */		/********************************************/		if (sampled < OTUs)	{			for (sp=0; sp<=standingdiv; ++sp)	{				species = extants[sp];								/* Raw Species Number */				find = (((unsigned int) rand())%base)+1;/*				if (f1[species]>=3 || cumulativediv>=(3*mxstnd))	find = 0;	*/				y=fr;				x=stage;				if (tor[species]>x)			mod=(tex[species]-tor[species])*y;				else if (tor[species]<x)		mod=(tex[species]-x)*y;								if (find <= mod)	{					newby = 0;					/** First sampled species goes straight into the array **/					if (sampled==0)	{						observed[sampled]=species;						fa[sampled]=la[sampled]=stage;						++sampled;						}					/** Test whether a sampled species had gone unsampled **/					else	{						for (otu = 0; otu < sampled;  ++otu)	{							if (observed[otu] == species)	{								newby = 1;								la[otu]=stage;								otu = sampled;								}							}						if (newby == 0 && sampled < OTUs)	{							/* sort species as you go */							a=sampled-1;							while (observed[a]>species && a>=0)	{								observed[a+1]=observed[a];								fa[a+1]=fa[a];								la[a+1]=la[a];								--a;								}							observed[a+1] = species;							fa[a+1]=la[a+1]=stage;							++sampled;							if (sampled<0 || sampled>OTUs)	{								printf("ERROR 871: You somehow sampled %d\n",sampled);								exit(0);								}							if (sampled==OTUs)		sp = standingdiv;							}						}					latest = observed[sampled-1];					}	/* End Tallying of Sampled Horizon	*/				}	/*  End Sampling for Each Horizon	*/			}		}			else {		sampled = standingdiv;		/* if there are no fossils, "present" is when									   OTUs taxa evolve */		if (sampled==OTUs-1)	for (sp=0; sp<OTUs; ++sp)	observed[sp]=extants[sp];		}	if (sampled>=OTUs)	break;	/* don't bother with the rest if done */				/********************************************/		/*				Do Extinction				*/		/********************************************/	for (a=standingdiv; a>=0; --a)	{		/* sp = extants but not nec. sampled species */		extinct = (((unsigned int) rand())%base);				sp=extants[a];		y=lmbd;		x=stage;		/* take into account species that were there only part of the time */		if (tor[sp]>x)			mod=(tex[sp]-tor[sp])*y;		else if (tor[sp]<x)		mod=(tex[sp]-x)*y;		if (tex[sp]<(stage+1))	{			extinct=0;			mod=base;			}/*		if (f1[extants[sp]]>=3)	extinct = 0;	*/		if (extinct < mod)	{			/*  REMOVE SPECIES FROM extants LIST */			for (b = a; b <= standingdiv; ++b)	extants[b] = extants[b+1];			extants[standingdiv] = -1;			--standingdiv;			if (sp<-1)	{				printf("ERROR 916 - you have more extinctions than species\n");				exit(0);				}			}		}	/*  End Extinction Simulation */	initdiv=standingdiv;				/****** REBOOT ROUTINE ******/	if (standingdiv < 0 || (cumulativediv>=mxtaxa && sampled < OTUs))	{		latest = -1;		for (sp=0; sp<OTUs; ++sp)	{			extants[sp]=observed[sp]=ancestor[sp]=-1;			tor[sp]=fa[sp]=la[sp]=f1[sp]=0;			}		standingdiv = initdiv = cumulativediv = extants[0] = sampled = 0;		stage = 0;		++attempts;/*		if ((attempts%5)==0)	printf ("%2d tries and counting.\n",attempts); */		}				/** Reboot simulation **/	else	{		if (sampled < OTUs)	++stage;		/*  All OTUs species found	*/		else if (FOSSILS==0 && cumulativediv==((2*OTUs)-2))	{			for (sp=0; sp<=standingdiv; ++sp)		observed[sp] = extants[sp];			sampled = OTUs;			reboot=1;			}		/* if species index is out of range, then reboot the whole thing */		}	}mxdv=1+maxiarray(f1,cumulativediv);/* tree matrix - rows 0...(OTUs-1) rows are for possible nodes	*//*		row OTUs-1 is for species branch lengths				*//*		row OTUs   is for nodal branch lengths					*//*		row OTUs+1 is for species FAs							*//*		row OTUs+2 is for species LAs							*//*		row OTUs+3 is number of clades							*//*		the first cell of rows 0É(OTUs-1) give # branches		*//*			(i.e., 2 for bifurcation w. no sampled ancestor)	*/tree=lmatrix(OTUs+4,OTUs);clearlmatrix(tree,OTUs+4,OTUs,-1);for (a=cumulativediv+1; a<mxtaxa; ++a)	f1[a]=ancestor[a]=0;if (observed[0]==-1)	{	printf("Taxa lost by line 964\a\n");	exit(0);	}/*********************************************************************************//*								Store True Phylogeny							 *//*********************************************************************************//**** LIST ANCESTORS OF EACH OBSERVED SPECIES ****/chucks=0;ancestor[0]=-1;/* find the distance from the base for each species */for (otu=0; otu<OTUs; ++otu)	{	sp=observed[otu];	anc=ancestor[sp];	if (anc>=0)		dbas[otu]=1;	for (a=1; anc>=0; ++a)	{		anc=ancestor[anc];		++dbas[otu];		}	}/* count the maximum number of ancestors */chucks=maxiarray(dbas,otu);/* list all of the ancestors for each species */forefathers=imatrix(OTUs,chucks+1);clearimatrix(forefathers,OTUs,chucks+1,-1);ancestor[0]=-1;for (otu=0; otu<OTUs; ++otu)	{	forefathers[otu][0]=sp=observed[otu];	anc=ancestor[sp];	for (a=1; anc>=0; ++a)	{		forefathers[otu][a]=anc;		anc=ancestor[anc];		}	}/* list the unsampled ancestors of each species *//* also, tally species with sampled descendants */free_ivector(f1);f1=ivector(OTUs);	/* 0: no sampled descendants; 1: 1+ sampled descendants */for (otu=0; otu<OTUs; ++otu)	{	obsbl[otu]=1;	found=0;	for (a=1; a<dbas[otu]; ++a)	{		anc=forefathers[otu][a];		for (b=otu-1; b>=0; --b)	{			if (observed[b]==anc)	{				found=1;				f1[b]=1;				/* end loops */				b=0;				a=dbas[otu];				}			}		if (found==0)	++obsbl[otu];		}	}/* create a matrix of branch distances between taxa *//* this gives distance to common ancestor, so the matrix is asymmetrical */pdmat=imatrix(otu,otu);camat=imatrix(otu,otu);for (otu=OTUs-1; otu>0; --otu)	{	for (otu2=otu-1; otu2>=0; --otu2)	{		for (a=0; a<=dbas[otu]; ++a)	{			sp=forefathers[otu][a];			for (b=0; b<=dbas[otu2]; ++b)	{				sp2=forefathers[otu2][b];				if (sp==sp2)	{					pdmat[otu][otu2]=a+1;					pdmat[otu2][otu]=b+1;					camat[otu][otu2]=camat[otu2][otu]=sp;					/* end loop */					b=dbas[otu2];					a=dbas[otu];					}				/* end loop if forefather[otu][a] cannot match forefather[otu2][any] */				else if (sp>sp2)	b=dbas[otu2];				}			}		}	}/* create a tree *//* keep track of common ancestors of each clade */nodes=found0=0;for (otu=OTUs-1; otu>0; --otu)	{	d=chucks;	for (otu2=otu-1; otu2>=0; --otu2)	{		if (pdmat[otu][otu2]<d)	{			d=pdmat[otu][otu2];			}		}	for (otu2=0; otu2<otu; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			anc=camat[otu][otu2];			found=-1;			for (a=0; a<nodes; ++a)	{				/* existing nodes found */				if (commonanc[a]==camat[otu][otu2])	{					found=0;					/* check to see if the species already is in the nodes */					for (b=1; b<=tree[a][0]; ++b)	{						if (otu2==tree[a][b])		found=1;						}					if (found==0)	{						for (b=1; b<=tree[a][0]; ++b)	{							if (otu==tree[a][b])	found=2;							}						}					/* if neither species already found */					if (found==0)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					/* if older species already found */					else if (found==1)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						}					/* if younger species already found */					else if (found==2)	{						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					a=nodes+1;					otu2=otu;					}				}	/* end search for previously found node */			/* new nodes found */			if (found==-1)	{				commonanc[nodes]=camat[otu][otu2];				tree[nodes][0]=2;				tree[nodes][1]=otu2;				tree[nodes][2]=otu;				++nodes;				if (otu2==0)	found0=1;				otu2=otu;				}	/* new node added */			}		}	}/* make sure that oldest species is included in the tree somewhere **/if (found0==0)	{	otu=0;	d=chucks;	for (otu2=1; otu<OTUs; ++otu2)	if (pdmat[otu][otu2]<d)		d=pdmat[otu][otu2];	for (otu2=1; otu<OTUs; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			tree[nodes][0]=2;			tree[nodes][1]=0;			tree[nodes][2]=otu2;			commonanc[nodes]=camat[0][otu2];			++nodes;			}		}	found0=1;	}	mxdv=2;for (a=0; a<nodes; ++a)	if (tree[a][0]>mxdv)	mxdv=tree[a][0];/*****  Sort Clades by Last Common Ancestor	*****/for (testnode=0; testnode<nodes; ++testnode)	{	d=commonanc[c=testnode];	for (clade=testnode+1; clade<nodes; ++clade)		if (commonanc[clade] <= d) d=commonanc[c=clade];	if (c != testnode)	{		commonanc[c]=commonanc[testnode];		commonanc[testnode]=d;		for (sp=0; sp<=mxdv; ++sp)	{			d=tree[testnode][sp];			tree[testnode][sp]=tree[c][sp];			tree[c][sp]=d;			}		}	}/**** WRITE OUT TREE ****/for (testnode=nodes-1; testnode>0; --testnode)	{	found=0;	sp=tree[testnode][1];	htu=testnode+OTUs;	for (plesion=testnode-1; found==0 && plesion>=0; --plesion)	{		for (a=1; a<=tree[plesion][0]; ++a)	{			sp2=tree[plesion][a];			/* ancestral node found */			if (sp2==sp)	{				if (sp<OTUs)	{					for (b=a+1; tree[plesion][b]<htu && b<=tree[plesion][0]; ++b)						tree[plesion][b-1]=tree[plesion][b];					tree[plesion][b-1]=htu;					}				/* different routine needed if clade */				else	{					oldfirst=tree[plesion][1];					for (b=a; tree[plesion][b-1]>htu; --b)	{						tree[plesion][b]=tree[plesion][b-1];						}					tree[plesion][b]=htu;					/* if first species was a clade but now is another clade */					/*   then the old must be replaced */					if (b==1 && oldfirst==tree[plesion][2])	{						sp=tree[plesion][2];						htu=tree[plesion][1];						}					}				/* if the first species was found, then it will be in lower clades 						*/				/* this means that the tree needs to be re-written or this node will never find a home  */				/*   So, swap the that species with the first species in tree[plesion] 					*/				/*     if a clade replaces a clade, htu remains unchanged */				if (a==1 || b==1)					htu=tree[plesion][1];				else					found=1;				a=tree[plesion][0];	/* end search */				}	/* end replacement of taxon within clade by node or new representative species */			}	/* end search of species within a lower node */		}	/* end search of nodes */	}		/************************  Determine Branch Lengths  ************************/for (a=0; a<OTUs; ++a)					bl[a] = obsbl[a];for (a=OTUs; a<(OTUs+nodes); ++a)		bl[a] = 0;/***    Replace Branch lengths from sampled Ancestors to Nodes    ***/ for (sp=0; sp<OTUs; ++sp)	{	if (f1[sp]>0)	{		for (b=0; b<nodes; ++b)	{			if (commonanc[b]==observed[sp])	{				bl[b+OTUs] = bl[sp];				bl[sp] = 0;				}			}		}	}/***   Nodes Subsume the Apomorphies of their Unsampled Immediate Ancestors   ***/ for (clade=nodes-1; clade>=0; --clade)	{	while (bl[clade+OTUs]>0 && clade>0)	--clade;	if (clade<0)	break;	found=0;	anc=commonanc[clade];	for (a=0; (found==0 && anc>-1); ++a)	{		++bl[clade+OTUs];		for (b=0; b<OTUs; ++b)	{			/* if ancestor is observed, prepare to stop the loop */			if (observed[b]==anc)	{				found=1;				b=OTUs;				}			/* once species are older than ancestor, abandon search to speed loop */			else if (observed[b]>anc)	b=OTUs;			}		anc=ancestor[anc];		}	}/* add branch lengths to tree  */for (a=0; a<OTUs; ++a)	tree[OTUs-1][a]=bl[a];for (b=0; b<nodes; ++b)	{	a=OTUs+b;	tree[OTUs][b]=bl[a];	}/* add branch lengths to tree  */for (a=0; a<OTUs; ++a)	{	tree[OTUs+1][a]=fa[a];	tree[OTUs+2][a]=la[a];	}tree[OTUs+3][0]=nodes;free_ivector(observed);free_ivector(obsbl);free_ivector(commonanc);free_ivector(fa);free_ivector(la);free_ivector(bl);free_ivector(extants);free_ivector(ancestor);free_imatrix(forefathers,OTUs,chucks+1);free_ivector(available);free_ivector(f1);free_ivector(dbas);	free_dvector(tor);free_dvector(tex);free_imatrix(pdmat,otu,otu);free_imatrix(camat,otu,otu);tree=clademember(tree, OTUs, nodes);return tree;}