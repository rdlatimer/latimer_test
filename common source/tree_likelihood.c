#define Tree_Likelihood#include "tree_likelihood.h"#include "probability.h"#include "memory.h"#include "sort.h"#include <stdlib.h>#include <stdio.h>#include <time.h>#include <math.h>#include <string.h>#define	e	2.718281828#define	pi	3.141592654double ***initialize_conditional_likelihoods(long **chmatrix, int *nstates, int notu, int nodes, int nchars, int maxst, int UNKNOWN, int INAP){int	a, c, f;int	ch, sp ,st;double ***statelikes;statelikes=dcube(nodes+notu,nchars,maxst);	/* likelihoods of each state at each node	*/for (sp=0; sp<notu; ++sp)	{	for (ch=0; ch<nchars; ++ch)	{		if (chmatrix[sp][ch]>=0 && (chmatrix[sp][ch]!=UNKNOWN && chmatrix[sp][ch]!=INAP))	statelikes[sp][ch][chmatrix[sp][ch]]=1.0f;		/* if unknown, then all states are equally likely	*/		else if (chmatrix[sp][ch]==UNKNOWN || chmatrix[sp][ch]==INAP)			for (st=0; st<nstates[ch]; ++st)	statelikes[sp][ch][st]=1.0f;		/* for polymorphisms:			use negative numbers so -31 = 3 & 1 or -10 = 1 & 0	*/		else if (chmatrix[sp][ch]<0)	{			a=abs(chmatrix[sp][ch]);			f=0;			while (a>0)	{				statelikes[sp][ch][st=a%10]=1.0f;				a/=10;				++f;				}			for (st=0; st<nstates[ch]; ++st)	statelikes[sp][ch][st]/=((double) f);			}		}	}for (c=notu; c<notu+nodes; ++c)	{	for (ch=0; ch<nchars; ++ch)	{		for (st=0; st<maxst; ++st)	{			if (st<nstates[ch])	statelikes[c][ch][st]=1.0f;			else				statelikes[c][ch][st]=0.0f;			}	/* set appropriate states to 1.0, others to 0.0; these will be multiplied later	*/		}	/* end search of characters	*/	}	/* end setting nodal conditions to possible states	*/return statelikes;}/* Mk model simplified:	st: observed state 	states: number of states	rate: instantaneous rate of change	time: amount of time for change	marginals: likelihoods of ancestral conditions given above	UNKNOWN: missing data score	INAP: inapplicable data score*************************************************************************************************/	void MkSimplest(int st, int states, double rate, double time, double *marginals, int UNKNOWN, int INAP){int	s;double chn, sts;//sts=(1/((double) states)) + ((((double) (states-1))/((double) states)) * pow(e,(-1*states*rate*time)));//chn=(1/((double) states)) - (pow(e,(-1*states*rate*time))/((double) states));sts=(1/((double) states)) + ((((double) (states-1))/((double) states)) * exp(-1*states*rate*time));chn=(1/((double) states)) - exp(-1*states*rate*time)/((double) states);/* if state invisible, then all ancestral states have a likelihood of 1.0	*/if (st==UNKNOWN || st==INAP)	{	for (s=0; s<states; ++s)	marginals[s]=1.0f;	}else	{	for (s=0; s<states; ++s)	{		if (s==st)	marginals[s]=sts;		else		marginals[s]=chn;		}	}//return(0);}/* Mk model simplified:	st: observed state 	states: number of states	rate: instantaneous rate of change	time: amount of time for change	marginals: likelihoods of ancestral conditions given above	UNKNOWN: missing data score	INAP: inapplicable data score*************************************************************************************************/	void MkSimple(double **statelikes, int otu, int anc, int charst, double rate, double time)	{int	ast, dst;double chn, sts;double marg[100];//sts=(1/((double) charst)) + ((((double) (charst-1))/((double) charst)) * pow(e,(-1*charst*rate*time)));sts=(1/((double) charst)) + ((((double) (charst-1))/((double) charst)) * exp(-1*charst*rate*time));//chn=(1/((double) charst)) - (pow(e,(-1*charst*rate*time))/((double) charst));chn=1-sts;/* if state invisible, then all ancestral states have a likelihood of 1.0	*///if (st==UNKNOWN || st==INAP)	{//	for (s=0; s<charst; ++s)	marg[s]=1.0f;//	}//else	{for (ast=0; ast<charst; ++ast)	{	marg[ast]=0.0f;	for (dst=0; dst<charst; ++dst)	{		if (dst==ast)	marg[ast]+=(sts*statelikes[otu][dst]);		else			marg[ast]+=(chn*statelikes[otu][dst]);		}	/* go through descendant states	*/	statelikes[anc][ast]*=marg[ast];	}//	}//return(0);}/* Mk model simplified:	st: observed state 	states: number of states	rate: instantaneous rate of change	time: amount of time for change	marginals: likelihoods of ancestral conditions given above	UNKNOWN: missing data score	INAP: inapplicable data score*************************************************************************************************/	void MkSimpleGeog(double **geoglikes, double *pg, int otu, int anc, int charst, double rate, double origin, double FA)	{int	ast, dst;double time;double chn, sts, x=0.0f;time=origin-FA;				/* length of time over which geography might have shifted	*/if (time<0)	time*=-1;		/* just in case negative numbers were used for ages			*/sts=(1/((double) charst)) + ((((double) (charst-1))/((double) charst)) * exp(-1*charst*rate*time));chn=1-sts;//sts=(1/((double) charst)) + ((((double) (charst-1))/((double) charst)) * pow(e,(-1*charst*rate*time)));//chn=(1/((double) charst)) - (pow(e,(-1*charst*rate*time))/((double) charst));/* if state invisible, then all ancestral states have a likelihood of 1.0	*///if (st==UNKNOWN || st==INAP)	{//	for (s=0; s<charst; ++s)	marg[s]=1.0f;//	}//else	{for (ast=0; ast<charst; ++ast)	{	pg[ast]=0.0f;	for (dst=0; dst<charst; ++dst)	{		if (dst==ast)	pg[ast]+=(sts*geoglikes[otu][dst]);		else			pg[ast]+=(chn*geoglikes[otu][dst]);		}	/* go through descendant states	*/	geoglikes[anc][ast]*=pg[ast];	x+=pg[ast];	}for (ast=0; ast<charst; ++ast)	pg[ast]/=x;//	}//return(0);}/* Mk model simplified:	stls: vector giving likelihoods of different states 	states: number of states	rate: instantaneous rate of change	time: amount of time for change	marginals: likelihoods of ancestral conditions given above	missing: state number for unknown condition	INAP: state number for inapplicable condition*************************************************************************************************/	void MkModel(double *stls, int states, double rate, double time, double *marginals, int missing, int notap){int	s, sa, sd;double chn, sts;sts=(1/((double) states)) + ((((double) (states-1))/((double) states)) * exp(-1*states*rate*time));chn=(1/((double) states)) - (exp(-1*states*rate*time)/((double) states));//sts=(1/((double) states)) + ((((double) (states-1))/((double) states)) * pow(e,(-1*states*rate*time)));//chn=(1/((double) states)) - (pow(e,(-1*states*rate*time))/((double) states));/* if state invisible, then all ancestral states have a likelihood of 1.0	*/if (stls[missing]==1 || stls[notap]==1)	{	for (s=0; s<states; ++s)	marginals[s]=1.0f;	}else	{	for (sa=0; sa<states; ++sa)	{		marginals[sa]=0.0f;		for (sd=0; sd<states; ++sd)	{			/* stasis	*/			if (sa==sd)	marginals[sa]+=stls[sd]*sts;			/* change	*/			else		marginals[sa]+=stls[sd]*chn;			}		}	}//return (0);}/*	lgsp: likelihood of being in geographic unit; for observed taxa this is 1 if observed & 0 if not;	node: taxa belonging to this node;	fa: first appearances (already inferred for daughter clades)	htu: taxon number of the relevant node	f1: number of descendants (2 in a completely bifurcating tree with no sampled ancestors; given by tree[cl][0] for clade cl)	geog: number of geographic units.  This is the state number	im: immigration rate, which acts like a character transitoin rate	t: hypothesized divergence time*************************************************************************************************/	void MkGeogNode(double **lgsp, int *node, double *fa, int htu, int f1, double geog, double im, double t){int ga, gd, sc, sp;/* find likelihood of being in a region	*//* use likelihoods of all regions to get probabilities (P[region A] = L[region A]/·P[Region X]	*//* do this by going through each tip in the usual way with an Mk model							*//* ga is the ancestral condition; gd is the daughter condition	*/for (ga=0; ga<geog; ++ga)	{	lgsp[htu][ga]=0.0f;		/* likelihood of ancestral lineage being in area ga	*/	for (gd=0; gd<geog; ++gd)	{		/* go through all descendants	*/		for (sc=0; sc<f1; ++sc)	{			sp=node[sc];			/* lgsp[sp][gd] gives likelihood of taxon being in area gd; for observed taxa, this is 1 if observed, 0 otherwise	*/			/* no net change	*/			if (gd==ga)				lgsp[htu][ga]+=lgsp[sp][gd]*((1/((double) geog)) + ((geog-1)/((double) geog))*exp(-1*geog*im*abs(fa[sp]-t)));//				lgsp[htu][ga]+=lgsp[sp][gd]*((1/((double) geog)) + ((geog-1)/((double) geog))*pow(e,-1*geog*im*abs(fa[sp]-t)));			/* net change	*/			else				lgsp[htu][ga]+=lgsp[sp][gd]*(1/((double) geog) - (1/((double) geog))*exp(-1*geog*im*abs(fa[sp]-t)));			}		}	/* end descendant area	*/	}	/* end possible ancestral area	*///return (0);}/*	We go through and find the number of times each state is seen for each 2, 3, 4, etc., state characterWe then calculate the likelihood of the ancestral condition for each of those states	margDesc: likelihoods of states; on observed taxa, these are set to 1 if present or 0 if absent		QUESTION?  TO WHAT SHOULD ? and - be set?  1.0, I thinkSend in two new vectors:	one giving the number of characters with X states;	the other an array giving the characters with X states*/void MkBranch(int sp, int anc, double ***statelikes, double ***nodelnmarg, long **statechars, long *charswstates, int maxst, double rate, double time, int UNKNOWN, int INAP){int	c, ch, ast, dst, stcl;double	sts, chn, lgsts, lgchn;double marg[100];/* go through ancestral states and get their conditional likelihoods based on descendants	*/for (stcl=2; stcl<maxst; ++stcl)	{	sts=(1/((double) stcl)) + ((((double) (stcl-1))/((double) stcl)) * pow(e,(-1*stcl*rate*time)));	chn=(1/((double) stcl)) - (pow(e,(-1*stcl*rate*time))/((double) stcl));	lgsts=log(sts);	lgchn=log(chn);	for (c=0; c<charswstates[stcl]; ++c)	{		ch=statechars[stcl][c];			/* character number	*/		while ((statelikes[sp][ch][stcl]==UNKNOWN || statelikes[sp][ch][stcl]==INAP) && c<charswstates[stcl])	{			++c;			ch=statechars[stcl][c];			/* character number	*/			}		if (c>=charswstates[stcl])	break;/*		if (statelikes[sp][ch][stcl]==UNKNOWN && statelikes[sp][ch][stcl]==INAP)	{			for (st=0; st<stcl; ++st)	margNode[sp][ch][st]=1.0f;			}		else	{	*/		/* ast is ancestral state; dst is descendant state	*/		for (ast=0; ast<stcl; ++ast)	{			marg[ast]=0.0f;			for (dst=0; dst<stcl; ++dst)	{//				if (dst==ast)	margNode[anc][ch][dst]*=statelikes[sp][ch][dst]*sts;//				else			margNode[anc][ch][dst]*=statelikes[sp][ch][dst]*chn;//				if (dst==ast)	logchange[ch][dst]+=log(statelikes[sp][ch][dst])+lgsts;//				else			logchange[ch][dst]+=log(statelikes[sp][ch][dst])+logchn;				if (dst==ast)	marg[ast]+=statelikes[sp][ch][dst]*sts;				else			marg[ast]+=statelikes[sp][ch][dst]*chn;				/* note: if missing or inapplicable, then every state has a likelihood of 1.0	*/				}	/* go through all descendant states	*/			/* conditional likelihood of ancestral state modified by this branch	*/			/* note: this will be zero for the first branch							*/			nodelnmarg[anc][ch][ast]+=log(marg[ast]);			}		/* go through all ancestral states	*/		}	/* end characters with stcl states	*/	}	/* end search of characters	*///return ();}	/*	*/void MkCharacters(int sp, int ancl, int htu, double ***statelikes, double ***nodelnmarg, long **statechars, long *charswstates, int maxst, double rate, double time, int UNKNOWN, int INAP){int	c, ch, ast, dst, stcl;double	sts, chn;/*double	lgsts, lgchn;	*/double marg[100];/* go through ancestral states and get their conditional likelihoods based on descendants	*/for (stcl=2; stcl<maxst; ++stcl)	{	sts=(1/((double) stcl)) + ((((double) (stcl-1))/((double) stcl)) * pow(e,(-1*stcl*rate*time)));//	chn[r]=(1/((double) stcl)) - (pow(e,(-1*stcl*alphas[r]*time))/((double) stcl));	chn=(1-sts)/((double) (stcl-1));//	lgsts=log(sts);//	lgchn=log(chn);	for (c=0; c<charswstates[stcl]; ++c)	{		ch=statechars[stcl][c];			/* character number	*/		while ((statelikes[sp][ch][stcl]==UNKNOWN || statelikes[sp][ch][stcl]==INAP) && c<charswstates[stcl])	{			++c;			ch=statechars[stcl][c];			/* character number	*/			}		if (c>=charswstates[stcl])	break;/*		if (statelikes[sp][ch][stcl]==UNKNOWN && statelikes[sp][ch][stcl]==INAP)	{			for (st=0; st<stcl; ++st)	margNode[sp][ch][st]=1.0f;			}		else	{	*/		/* ast is ancestral state; dst is descendant state	*/		statelikes[htu][ch][stcl]=0.0f;								/* note that the node is "coded"	*/		for (ast=0; ast<stcl; ++ast)	{			marg[ast]=0.0f;			for (dst=0; dst<stcl; ++dst)	{//				if (dst==ast)	margNode[ancl][ch][dst]*=statelikes[sp][ch][dst]*sts;//				else			margNode[ancl][ch][dst]*=statelikes[sp][ch][dst]*chn;//				if (dst==ast)	logchange[ch][dst]+=log(statelikes[sp][ch][dst])+lgsts;//				else			logchange[ch][dst]+=log(statelikes[sp][ch][dst])+logchn;				if (dst==ast)	marg[ast]+=statelikes[sp][ch][dst]*sts;				else			marg[ast]+=statelikes[sp][ch][dst]*chn;				/* note: if missing or inapplicable, then every state has a likelihood of 1.0	*/				}	/* go through all descendant states	*/			/* conditional likelihood of ancestral state modified by this branch	*/			/* note: this will be zero for the first branch							*/			nodelnmarg[ancl][ch][ast]+=log(marg[ast]);			statelikes[htu][ch][ast]=pow(e,nodelnmarg[ancl][ch][ast]);			}		/* go through all ancestral states	*/		}	/* end characters with stcl states	*/	}	/* end search of characters	*///return ();}	/*	*/void MkCharactersVar(int sp, int ancl, int htu, double ***statelikes, double ***nodelnmarg, double ***branchlnlikes, long **statechars, long *charswstates, int maxst, double *alphas, int rates, double time, int UNKNOWN, int INAP){int	c, ch, ast, dst, stcl, r;double	*sts, *chn;double marg[100];sts=dvector(rates);chn=dvector(rates);/* go through ancestral states and get their conditional likelihoods based on descendants	*/for (stcl=2; stcl<maxst; ++stcl)	{	for (r=0; r<rates; ++r)	{		sts[r]=(1/((double) stcl)) + ((((double) (stcl-1))/((double) stcl)) * pow(e,(-1*stcl*alphas[r]*time)));//		chn[r]=(1/((double) stcl)) - (pow(e,(-1*stcl*alphas[r]*time))/((double) stcl));		chn[r]=(1-sts[r])/((double) (stcl-1));		}	for (c=0; c<charswstates[stcl]; ++c)	{		ch=statechars[stcl][c];			/* character number	*/		while ((statelikes[sp][ch][stcl]==UNKNOWN || statelikes[sp][ch][stcl]==INAP) && c<charswstates[stcl])	{			++c;			ch=statechars[stcl][c];			/* character number	*/			}		if (c>=charswstates[stcl])	break;		/* ast is ancestral state; dst is descendant state	*/		statelikes[htu][ch][stcl]=0.0f;								/* note that the node is "coded"	*/		for (ast=0; ast<stcl; ++ast)	{			marg[ast]=0.0f;			for (dst=0; dst<stcl; ++dst)	{				if (dst==ast)	for (r=0; r<rates; ++r)	marg[ast]+=(statelikes[sp][ch][dst]*sts[r]/((double) rates));				else			for (r=0; r<rates; ++r)	marg[ast]+=(statelikes[sp][ch][dst]*chn[r]/((double) rates));				/* note: if missing or inapplicable, then every state has a likelihood of 1.0	*/				}	/* go through all descendant states	*/			/* conditional likelihood of ancestral state modified by this branch	*/			/* note: this will be zero for the first branch							*/			branchlnlikes[sp][ch][ast]=log(marg[ast]);			nodelnmarg[ancl][ch][ast]+=log(marg[ast]);			statelikes[htu][ch][ast]=pow(e,nodelnmarg[ancl][ch][ast]);			}		/* go through all ancestral states	*/		}	/* end characters with stcl states	*/	}	/* end search of characters	*/free_dvector(sts);free_dvector(chn);}	/*	*/void MkCharactersVarBranch(int sp, int ancl, double ***statelikes, double ***branchlikes, long **statechars, long *charswstates, int maxst, double *alphas, int rates, double time, int UNKNOWN, int INAP){int	c, ch, ast, dst, stcl, r;double	*sts, *chn;double marg[100];sts=dvector(rates);chn=dvector(rates);/* go through ancestral states and get their conditional likelihoods based on descendants	*/for (stcl=2; stcl<maxst; ++stcl)	{	for (r=0; r<rates; ++r)	{		sts[r]=(1/((double) stcl)) + ((((double) (stcl-1))/((double) stcl)) * pow(e,(-1*stcl*alphas[r]*time)));//		chn[r]=(1/((double) stcl)) - (pow(e,(-1*stcl*alphas[r]*time))/((double) stcl));		chn[r]=(1-sts[r])/((double) (stcl-1));		}	for (c=0; c<charswstates[stcl]; ++c)	{		ch=statechars[stcl][c];			/* character number	*/		while ((statelikes[sp][ch][stcl]==UNKNOWN || statelikes[sp][ch][stcl]==INAP) && c<charswstates[stcl])	{			++c;			ch=statechars[stcl][c];			/* character number	*/			}		if (c>=charswstates[stcl])	break;		/* ast is ancestral state; dst is descendant state	*//*		statelikes[htu][ch][stcl]=0.0f;								/* note that the node is "coded"	*/		for (ast=0; ast<stcl; ++ast)	{			marg[ast]=0.0f;			for (dst=0; dst<stcl; ++dst)	{				if (dst==ast)	for (r=0; r<rates; ++r)	marg[ast]+=(statelikes[sp][ch][dst]*sts[r]/((double) rates));				else			for (r=0; r<rates; ++r)	marg[ast]+=(statelikes[sp][ch][dst]*chn[r]/((double) rates));				/* note: if missing or inapplicable, then every state has a likelihood of 1.0	*/				}	/* go through all descendant states	*/			/* conditional likelihood of ancestral state modified by this branch	*/			/* note: this will be zero for the first branch							*/			branchlikes[ancl][ch][ast]=log(marg[ast]);//			statelikes[htu][ch][ast]=pow(e,nodelnmarg[ancl][ch][ast]);			}		/* go through all ancestral states	*/		}	/* end characters with stcl states	*/	}	/* end search of characters	*/free_dvector(sts);free_dvector(chn);}	/*	*//* first do tree ignoring stratigraphic ranges	*//* Requires:/* 		ape: tree with first row giving ancestor/* 		divergences: divergence time along each branch/*		notu: number of observed taxa/*		nodes: nodes in tree (notu-1 if fully bifurcating)		statechars: characters with 2Émaxst states/*		charswstates: number of characters having X states/*		novels: number of observed character vectors matching this one		maxst: maximum number of states		alphas: vector of different rates		rates: number of rates in alpha vector/* 		statelikes: likelihood of each state on each node (this contains matrix information, too).		nodelnlikes: loglikelihood of each node		lambda: speciation rate (for pulsed change)		minbr: minimum branch length for taxon; this is 1 unless a species might be an anagenetic descendant of another species (then 0)******************************************************************************************************************************///void MkSimpleWholeTreeStarter(long *ape, int notu, int nodes, double **divergences, double **ranges, long **statechars, long *charswstates, int maxst, double *alphas, double *betas, int rates, double ***statelikes, double lambda, int mode)void MkSimpleWholeTree(long *ape, int notu, int nodes, double **divergences, long **statechars, long *charswstates, int maxst, double *alphas, double *betas, int rates, double ***statelikes, double lambda, unsigned long *ancestral, unsigned long *minbr){int	c, r, s;int	cl, sp, ch, anc, nd, stcl, ast, dst;double	time, pulses, x;double	sts[50], chn[50], marg[100];for (sp=0; sp<notu; ++sp)	{	if (ancestral[sp]>0)	{		anc=ape[sp];		for (stcl=2; stcl<maxst; ++stcl)	{			for (c=0; c<charswstates[stcl]; ++c)	{				ch=statechars[stcl][c];				for (s=0; s<stcl; ++s)		statelikes[anc][c][s]=statelikes[sp][c][s];				}			}		}	}for (sp=(notu-1); sp>=0; --sp)	{	time=fabs(divergences[sp][1]-divergences[sp][0]);	pulses=minbr[sp]+lambda*fabs(divergences[sp][1]-divergences[sp][0]);	/* we need to add turnover pulse to this still	*/	anc=ape[sp];	nd=anc-notu;	for (stcl=2; stcl<maxst; ++stcl)	{		for (r=0; r<rates; ++r)	{//			sts[r]=(1/((double) stcl)) + ((((double) (stcl-1))/((double) stcl)) * pow(e,(-1*stcl*((alphas[r]*time)+(betas[r]*pulses)))));			sts[r]=(1/((double) stcl)) + ((((double) (stcl-1))/((double) stcl)) * exp(-1*stcl*((alphas[r]*time)+(betas[r]*pulses))));			chn[r]=(1-sts[r])/((double) (stcl-1));			}		for (c=0; c<charswstates[stcl]; ++c)	{			ch=statechars[stcl][c];			/* character number	*/		/* ast is ancestral state; dst is descendant state	*/			for (ast=0; ast<stcl; ++ast)	{				marg[ast]=0.0f;				for (dst=0; dst<stcl; ++dst)	{					/* add both anagenetic and pulsed change!	*/					if (dst==ast)	for (r=0; r<rates; ++r)	marg[ast]+=(statelikes[sp][ch][dst]*sts[r]/((double) rates));					else			for (r=0; r<rates; ++r)	marg[ast]+=(statelikes[sp][ch][dst]*chn[r]/((double) rates));					/* note: if missing or inapplicable, then every state has a likelihood of 1.0	*/					}	/* go through all descendant states	*/				x=log(marg[ast])+log(statelikes[anc][ch][ast]);				statelikes[anc][ch][ast]=exp(x);				}	/* go through all ancestral states	*/			}	/* go through each character in stateclass	*/		}	/* go through each stateclass	*/		}	/* end species	*//* NOTE: later trees will have nodes messed up; they will need to be "ordered" */for (cl=(notu+nodes)-1; cl>notu; --cl)	{	time=fabs(divergences[cl][1]-divergences[cl][0]);	pulses=1+lambda*fabs(divergences[cl][1]-divergences[cl][0]);//	if (mode==PUL)	time=1+lambda*turns;	anc=ape[cl];	nd=anc-notu;	for (stcl=2; stcl<maxst; ++stcl)	{		for (r=0; r<rates; ++r)	{//			sts[r]=(1/((double) stcl)) + ((((double) (stcl-1))/((double) stcl)) * pow(e,(-1*stcl*((alphas[r]*time)+(betas[r]*pulses)))));			sts[r]=(1/((double) stcl)) + ((((double) (stcl-1))/((double) stcl)) * exp(-1*stcl*((alphas[r]*time)+(betas[r]*pulses))));			chn[r]=(1-sts[r])/((double) (stcl-1));			}		for (c=0; c<charswstates[stcl]; ++c)	{			ch=statechars[stcl][c];			/* character number	*/		/* ast is ancestral state; dst is descendant state	*/			for (ast=0; ast<stcl; ++ast)	{				marg[ast]=0.0f;				for (dst=0; dst<stcl; ++dst)	{					if (dst==ast)	for (r=0; r<rates; ++r)	marg[ast]+=(statelikes[cl][ch][dst]*sts[r]/((double) rates));					else			for (r=0; r<rates; ++r)	marg[ast]+=(statelikes[cl][ch][dst]*chn[r]/((double) rates));					/* note: if missing or inapplicable, then every state has a likelihood of 1.0	*/					}	/* go through all descendant states	*/				x=log(marg[ast])+log(statelikes[anc][ch][ast]);				statelikes[anc][ch][ast]=exp(x);				}	/* go through all ancestral states	*/			}	/* go through each character in stateclass	*/		}	/* go through each stateclass	*/		}	/* go through nodes	*/}void MkSimplePulley(int HTU, long *ape, int notu, int nodes, double **divergences, long **statechars, long *charswstates, int maxst, double *alphas, double *betas, int rates, double ***statelikes, double lambda, unsigned long *ancestral, unsigned long *minbr){int	b, c, d, r;int	sp, ch, nd, stcl, ast, dst, foote=-1;double	time, pulses, x;double	sts[50], chn[50], marg[100];int f1=0, desc[10];/* find descendants: their likelihoods should be set already	*/for (d=0; d<(nodes+notu); ++d)		{	if (ape[d]==HTU)	{		desc[f1]=d;		++f1;		if (d<notu && ancestral[d]>0)	foote=d;	/* sampled ancestor!!!!	*/		}	}	/* now, recalculate node likelihood	*/for (b=0; b<f1; ++b)	{	sp=desc[b];	time=fabs(divergences[sp][1]-divergences[sp][0]);	pulses=minbr[sp]+lambda*fabs(divergences[sp][1]-divergences[sp][0]);	/* we need to add turnover pulse to this still	*/	//	if (mode==PUL)	time=1+lambda*turns;	nd=HTU-notu;	for (stcl=2; stcl<maxst; ++stcl)	{		for (r=0; r<rates; ++r)	{			sts[r]=(1/((double) stcl)) + ((((double) (stcl-1))/((double) stcl)) * exp(-1*stcl*((alphas[r]*time)+(betas[r]*pulses))));			chn[r]=(1-sts[r])/((double) (stcl-1));//			sts[r]=(1/((double) stcl)) + ((((double) (stcl-1))/((double) stcl)) * pow(e,(-1*stcl*alphas[r]*time)));			//		chn[r]=(1/((double) stcl)) - (pow(e,(-1*stcl*alphas[r]*time))/((double) stcl));			}		for (c=0; c<charswstates[stcl]; ++c)	{			ch=statechars[stcl][c];			/* character number	*/			/* ast is ancestral state; dst is descendant state	*/			for (ast=0; ast<stcl; ++ast)	{				if (b==0)	{					if (foote<0)	statelikes[HTU][ch][ast]=1.0f;							/* reset this to 1.0 for the first daughter examined	*/					else			statelikes[HTU][ch][ast]=statelikes[foote][ch][ast];	/* reset this to 1.0 for the first daughter examined	*/					}				marg[ast]=0.0f;				for (dst=0; dst<stcl; ++dst)	{					if (dst==ast)	for (r=0; r<rates; ++r)	marg[ast]+=(statelikes[sp][ch][dst]*sts[r]/((double) rates));					else			for (r=0; r<rates; ++r)	marg[ast]+=(statelikes[sp][ch][dst]*chn[r]/((double) rates));					/* note: if missing or inapplicable, then every state has a likelihood of 1.0	*/					}	/* go through all descendant states	*/				x=log(marg[ast])+log(statelikes[HTU][ch][ast]);				statelikes[HTU][ch][ast]=exp(x);				}	/* go through all ancestral states	*/			}	/* go through each character in stateclass	*/		}	/* go through each stateclass	*/	}	/* to through each descendant	*//* recursion is our friend!	*/if (ape[HTU]>TREE_END)	MkSimplePulley(ape[HTU], ape, notu, nodes, divergences, statechars, charswstates, maxst, alphas, betas, rates, statelikes, lambda, ancestral, minbr);}/* Read basal node to get tree likelihood (given morphology only);********************************************************************************************************/double get_tree_likelihood(double **statelikes, int *novels, int *nstates, int nchars){int ch, st;double x, lnL_tree=0.0f;for (ch=0; ch<nchars; ++ch)	{	x=0.0f;	for (st=0; st<nstates[ch]; ++st)	x+=statelikes[ch][st];	lnL_tree+=novels[ch]*log(x);	}return lnL_tree;}/* Routine to determine probability of characters remaining static within an observed lineage using only first and last appearances********************************************************************************************************/void stasis_likelihood_simple(int notu, long **chmatrix, double **ranges, double *lnl_line_stasis, long **statechars, long *charswstates, int *novels, int maxst, double *alphas, int rates, int UNKNOWN, int INAP){int	c, r, ch, sp, rchars, stcl;double	time, marg;double	pstasis[100];for (sp=0; sp<notu; ++sp)	{	lnl_line_stasis[sp]=0.0f;	time=fabs(ranges[sp][1]-ranges[sp][0]);	for (stcl=2; stcl<maxst; ++stcl)	{		rchars=0;	/* find number of characters in this class for which species is coded	*/		for (c=0; c<charswstates[stcl]; ++c)	{			ch=statechars[stcl][c];			if (chmatrix[sp][ch]!=UNKNOWN && chmatrix[sp][ch]!=INAP)	rchars+=novels[ch];			}		if (rchars<1)	break;		/* to maximize likelihood of anagenesis, simply calculate P[stasis] from beginning to end; breaking it up only lowers the likelihood (and trivially)	*/		for (r=0; r<rates; ++r)	{			pstasis[r]=(1/((double) stcl)) + ((((double) (stcl-1))/((double) stcl)) * exp(-1*stcl*alphas[r]*time));			}		marg=0.0f;		for (r=0; r<rates; ++r)	marg+=pstasis[r]/((double) rates);		lnl_line_stasis[sp]+=rchars*log(marg);		}	/* go through each stateclass	*/		}	/* end species	*/}/* Routine to determine probability of characters remaining static within an observed lineage using multiple appearances********************************************************************************************************/void stasis_likelihood_sighting(int notu, long **chmatrix, double **sightings, int *sights, double *lnl_line_stasis, long **statechars, long *charswstates, int *novels, int maxst, double *alphas, int rates, int UNKNOWN, int INAP){int	c, r, ch, s, sp, rchars, stcl;double	time, marg;double	pstasis[100];for (sp=0; sp<notu; ++sp)	{	lnl_line_stasis[sp]=0.0f;	for (s=1; s<sights[sp]; ++s)	{		time=fabs(sightings[s]-sightings[s-1]);		for (stcl=2; stcl<maxst; ++stcl)	{			rchars=0;	/* find number of characters in this class for which species is coded	*/			for (c=0; c<charswstates[stcl]; ++c)	{				ch=statechars[stcl][c];				if (chmatrix[sp][ch]!=UNKNOWN && chmatrix[sp][ch]!=INAP)	rchars+=novels[ch];				}			if (rchars<1)	break;			/* to maximize likelihood of anagenesis, simply calculate P[stasis] from beginning to end; breaking it up only lowers the likelihood (and trivially)	*/			for (r=0; r<rates; ++r)	{				pstasis[r]=(1/((double) stcl)) + ((((double) (stcl-1))/((double) stcl)) * exp(-1*stcl*alphas[r]*time));				}			marg=0.0f;			for (r=0; r<rates; ++r)	marg+=pstasis[r]/((double) rates);			lnl_line_stasis[sp]+=rchars*log(marg);			}	/* go through each stateclass	*/		}	/* end sightings	*/	}	/* end species	*/}//void datecladerealape_one_node(int HTU, int desc[], double **divergences, int f1, int notu, unsigned long *ancestral)void MkSimpleNode(int HTU, int notu, int desc[], int f1, int foote, double **divergences, long **statechars, long *charswstates, int maxst, double *alphas, double *betas, int rates, double ***statelikes, double lambda, unsigned long *minbr){int	b, c, r;int	sp, ch, nd, stcl, ast, dst;double	time, pulses, x;double	sts[50], chn[50], marg[100];for (b=0; b<f1; ++b)	{	sp=desc[b];	time=fabs(divergences[sp][1]-divergences[sp][0]);	pulses=minbr[sp]+lambda*fabs(divergences[sp][1]-divergences[sp][0]);	/* we need to add turnover pulse to this still	*/	nd=HTU-notu;	for (stcl=2; stcl<maxst; ++stcl)	{		for (r=0; r<rates; ++r)	{			sts[r]=(1/((double) stcl)) + ((((double) (stcl-1))/((double) stcl)) * exp(-1*stcl*((alphas[r]*time)+(betas[r]*pulses))));			chn[r]=(1-sts[r])/((double) (stcl-1));				//			sts[r]=(1/((double) stcl)) + ((((double) (stcl-1))/((double) stcl)) * pow(e,(-1*stcl*alphas[r]*time)));				//		chn[r]=(1/((double) stcl)) - (pow(e,(-1*stcl*alphas[r]*time))/((double) stcl));			}		for (c=0; c<charswstates[stcl]; ++c)	{			ch=statechars[stcl][c];			/* character number	*/			/* ast is ancestral state; dst is descendant state	*/			for (ast=0; ast<stcl; ++ast)	{				if (b==0)	{					if (foote<0)	statelikes[HTU][ch][ast]=1.0f;							/* reset this to 1.0 for the first daughter examined	*/					else			statelikes[HTU][ch][ast]=statelikes[foote][ch][ast];	/* reset this to 1.0 for the first daughter examined	*/					}				marg[ast]=0.0f;				for (dst=0; dst<stcl; ++dst)	{					if (dst==ast)	for (r=0; r<rates; ++r)	marg[ast]+=(statelikes[sp][ch][dst]*sts[r]/((double) rates));					else			for (r=0; r<rates; ++r)	marg[ast]+=(statelikes[sp][ch][dst]*chn[r]/((double) rates));					/* note: if missing or inapplicable, then every state has a likelihood of 1.0	*/					}	/* go through all descendant states	*/				x=log(marg[ast])+log(statelikes[HTU][ch][ast]);				statelikes[HTU][ch][ast]=exp(x);				}	/* go through all ancestral states	*/			}	/* go through each character in stateclass	*/		}	/* go through each stateclass	*/	}	/* to through each descendant	*/}