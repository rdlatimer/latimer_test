/* evolvetreeVenn - Evolves a paleontological tree, with notu taxa sampled over time, output as Venn tree./* Requires:	notu - # of sampled taxa/*				MBL - simulation parameters where	 				MBL[0] (mu) - Speciation rate/*					MBL[1] (lmbd) - Extinction rate/*					MBL[2] (fr) - Preservation rate/*					MBL[3] (vr) - Variance in preservation rate				FOSSILS - (1) fossils sampled, (0) no fossils sampled/*				speciation - (1) bifurcation (0) budding cladogenesis/* Major Rewrite of Sampled Tree Construction 02/2003/* Rewritten to use real numbers from a single array (MBL)				tree[0][0]Étree[clades-1][0] gives TOTAL number of descendants of a node;				tree[0][1Étree[0][0]]Étree[clades-1][1Étree[clades-1][0]] give desendants where					0ÉOTUs-1 are taxon numbers;				tree[OTUs-1][0ÉOTUs-1] give branch lengths of sampled taxa;				tree[OTUS][0Éclades-1] give branch lengths of unsampled taxa;				tree[OTUs+1][0ÉOTUs-1] give first appearances of sampled taxa;				tree[OTUs+2][0ÉOTUs-1] give last appearances of sampled taxa;*******************************************************************************************************/long **evolvetreeVenn(int OTUs, double *MBL, int FOSSILS){long	attempts, base=100000, speciation;int		a, b, c, d, ee, charstandard, ch, latest, mxdv=6, chucks, brats;int		clade, otu, otu2, htu, sampled, initdiv, standingdiv, cumulativediv, stage, newby;int		species, anc, change, testnode, plesion, found0, oldfirst;int		reboot;int		sp, sp2, nodes, found;int		mxtaxa, mxstnd;int		*f1, **forefathers, *ancestor;int		*extants, *observed, *commonanc, *bl;int		*fa, *la, *dbas;int		**pdmat, **camat;//int		*deleteme, cut, *obsbl;long	**tree;double	mu, lmbd, fr, vr, vfr, frp;double	speciate, extinct, find;double	*tor, *tex;double	v, x, y, mod;mu=MBL[0];lmbd=MBL[1];fr=MBL[2];vr=MBL[3];if (vr<1)	vr=MBL[3]=1.0f;speciation=MBL[4];v=expectedpropsampled(MBL[1],MBL[2]);v=1/v;mxtaxa=10*v*OTUs;if (mxtaxa>30000)	mxtaxa=30000;/*if (FOSSILS=1)	mxstnd=2*OTUs;	*//*else			mxstnd=3*OTUs;		*/mxstnd=3*OTUs;/* arrays for observed taxa - set to OTUs*/observed=ivector(OTUs);		/* observed (sampled) taxa 					*/fa=ivector(OTUs);			/* first appearance of a taxon				*/la=ivector(OTUs);			/* last appearance of a taxon				*//*obsbl=ivector(OTUs);		/* branch lengths of sampled taxa			*/commonanc=ivector(2*OTUs);	/* ancestors of a taxon						*/dbas=ivector(OTUs);			/* patristic distance from base to taxon	*/bl=ivector(2*OTUs);			/* array for all elements of the tree 		*/extants = ivector(mxstnd+1);	/* array for standing taxa - set to mxstnd*/	/* arrays for sampled and unsampled taxa - set to mxtaxa */ancestor=ivector(mxtaxa);	/* ancestor of each taxon 					*/f1=ivector(mxtaxa);			/* number of descendants for each taxon 	*/tor=dvector(mxtaxa);		/* true origination - this is a real number */tex=dvector(mxtaxa);		/* true extinction - this is a real number 	*/reboot=0;a=b=c=d=ee=anc=0;charstandard = 1; /*charbase/100;*/sp = ch = change = find = 0;clearivector(observed,OTUs,-1);//clearivector(obsbl,OTUs,-1);clearivector(ancestor,mxtaxa,-1);clearivector(extants,mxstnd+1,-1);latest = -1;attempts = initdiv = standingdiv = cumulativediv = stage = extants[0] = sampled = 0;/* use this to calculate how long the species will live */extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);while (extinct<=0)	extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);tex[0]=(log(1-extinct)/log(1-lmbd));tor[0]=0.0f;		/*added 2014-01-13	*/while (sampled < OTUs)	{	initdiv = standingdiv+1;	for (sp=0; (sp<=standingdiv && cumulativediv<mxtaxa); ++sp)	{	/********************************************/	/*			Does Lineage Speciate?			*/	/********************************************/		if (sp<0 || sp>mxstnd)	{			printf("ERROR 108: %d is the wrong number of species!\n", sp);			exit(0);			}		species = extants[sp];/*		mod=1.0f;	*//*		if (tor[species]>stage)	*//*			mod=(stage+1)-tor[species];	/* mod reflects shortened time for extinction and speciation *//*		/*		v=1-pow((1-lmbd),mod);	/* this will equal lmbd if it survives the whole interval *//*		/* if v is still less than extinction rate, then the species dies this interval *//*		if (extinct<v)	{*//*			/* now randomly generate a number to show when it dies *//*			x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);*//*			/* if it existed at the beginning		*//*			if (tor[species]<=stage)	tex[species]+=x;*//*			/* if it originated durign this stage	*/ /*			else						tex[species]+=x*(((double) (stage+1))-tor[species]);*//*			}*//*		/* if it survies, then bump the extinction to the next interval	*//*		else							tex[species]=stage+1;	*/				if (f1[species]<mxdv)	speciate = (((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		else					speciate = 1.0f;				/* do this to shake up random number generator */		if (sp%2==0)			speciate=1-speciate;		v=mu;		if (tex[species]<(stage+1) || tor[species]>stage)	{			if (tex[species]<(stage+1) && tor[species]>stage)											mod=tex[species]-tor[species];			else if (tor[species]<stage)	mod=tex[species]-stage;			else if (tex[species]>stage+1)	mod=((double) (stage+1))-tor[species];			v=1-pow((1-mu),mod);	/* this will equal mu if it survives the whole interval */									/* (1-mu) is prob. of not speciating; 										(1-mu)^mod = prob of not speciating over mod										1-([1-mu]^mod) = prob. of speciating over mod	*/			}	/* end case for taxa present during only part of "stage"	*/		if (speciation==1)	ee=2;		else				ee=1;		if (speciate <= v && (standingdiv<(mxstnd-ee)))		{			brats=1;			/* if bifurcation, then two descendants when ancestor disappears		*/			if (speciation==1)	brats=2;			/* if budding, then allow for multiple descendants at different times 	*/			else	{				if (tor[species]>stage)	v=(stage+1)-tor[species];				else					v=1;				x=Poisson(mu, v, 2);				if (v<x)				brats=2;				}			/* go through each descendant */			for (a=0; a<brats; ++a)	{				++standingdiv;				++cumulativediv;				extants[standingdiv] = cumulativediv;				if (cumulativediv > mxtaxa)	{					printf("ERROR Evolve 187 - In replication XXX");					printf(", more than %3d species were generated.  \n",mxtaxa);					sampled=OTUs;					exit(0);						}				if (standingdiv<0 || standingdiv>mxstnd)	{					printf("ERROR 193:  Standing diversity too high at %2d\n",standingdiv);					sampled=OTUs;					exit(0);						}							if (cumulativediv<0 || cumulativediv>=mxtaxa || species<0 || species>=mxtaxa)	{					printf("ERROR 198 - ancestor index out of range at %d and %d\n",species,cumulativediv);					sampled=OTUs;					exit(0);						}				ancestor[cumulativediv] = species;				anc = species;				++f1[anc];						/*******************************************************************************/		/* Ancestors become pseudo-extinct at bifurcation if that is what is happening */		/*******************************************************************************/				if (speciation==0 || (speciation==1 && a==0))	{					y=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					/* if ancestor originated during stage and extends into the next	*/					if (tex[anc]>stage+1 && tor[anc]>stage)						tor[cumulativediv]=tor[anc]+(y*((stage+1)-tor[anc]));					/* if ancestor goes extinct during stage and originated before it	*/					else if (tex[anc]<(stage+1) && tor[anc]<stage)						tor[cumulativediv]=stage+(y*(tex[anc]-stage));					/* if ancestor both originates and goes extinct during stage		*/					else if (tex[anc]<(stage+1) && tor[anc]>stage)						tor[cumulativediv]=tor[anc]+(y*(tex[anc]-tor[anc]));					else						tor[cumulativediv]=y+ ((double) stage);										/* if we are dealing with the first species of a bifurcation, give it ancestral extinction time.	*/					/* 		Ancestor disappears when descendants arise													*/ 					if (speciation==1)	{						tex[cumulativediv]=tex[anc];						tex[anc]=tor[cumulativediv];						}					}				/* second species of a bifurcation */				else if (a==1)	tor[cumulativediv]=tex[anc];								/* establish extinction if the species becomes extinct */				if (speciation==0 || (speciation ==1 && a==1))	{					/* if we are dealing with the second species, then give it its own extinction time but the same origination time */					extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					tex[cumulativediv]=tor[cumulativediv]+(log(1-extinct)/log(1-lmbd));					}				}			}		if (FOSSILS==0 && standingdiv>=OTUs-1)	sp = initdiv;	/* quit if enough taxa are alive */		}	/****  End Speciation Round ****/ 				if (FOSSILS==1)	{		/********************************************/		/*				 Do Sampling				*/		/*  Separated from Speciation Loop 1/3/97   */		/********************************************/		if (sampled < OTUs)	{			for (sp=0; sp<=standingdiv; ++sp)	{				species = extants[sp];								/* Raw Species Number *//*				find = (((unsigned int) rand())%base)+1;	*//*				if (f1[species]>=3 || cumulativediv>=(3*mxstnd))	find = 0;	*/				find=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				/* do this to shake up the random number generator */				if (sp%2==0)	find=1-find;								/* insert lognormal part here	*/				x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				y=normsinv(x);				vfr=pow(vr,y);				v=fr*vfr;				frp=log(1-(fr*vfr));				/* 2012-01-10: Poisson expectation so that P[0 | 1 stage, fr] = 1=fr	*/											/* keep this here so that we can handle variable sampling				*/				if (tex[species]<(stage+1) || tor[species]>stage)	{					/* if species originates and disappears in this interval 			*/					if (tex[species]<(stage+1) && tor[species]>stage)														mod=tex[species]-tor[species];					/* if species originated earlier but goes extinct in this interval	*/					else if (tex[species]<(stage+1))	mod=tex[species]-stage;					/* if species goes extinct later but originates in this interval	*/					else if (tex[species]>(stage+1))	mod=((double) (stage+1))-tor[species];					v=1-pow(1-(fr*vfr),mod);	/* this will equal fr*vfr if it survives the whole interval */												/*	(1-[fr*vfr]) = prob. of missing over whole interval													(1-[fr*vfr])^mod = prob. of missing over mod.  	*/					}						if (find <= v)	{					newby = 0;					/** First sampled species goes straight into the array **/					if (sampled==0)	{						observed[sampled]=species;						fa[sampled]=la[sampled]=stage;						++sampled;						}					/** Test whether a sampled species had gone unsampled **/					else	{						for (otu = 0; otu < sampled;  ++otu)	{							if (observed[otu] == species)	{								newby = 1;		/* species is not new */								la[otu]=stage;								otu = sampled;								}							}						if (newby == 0 && sampled < OTUs)	{							/* sort species as you go */							a=sampled-1;							while (observed[a]>species && a>=0)	{								observed[a+1]=observed[a];								fa[a+1]=fa[a];								la[a+1]=la[a];								--a;								}							observed[a+1] = species;							fa[a+1]=la[a+1]=stage;							++sampled;							if (sampled<0 || sampled>OTUs)	{								printf("ERROR 189: You somehow sampled %d\n",sampled);								exit(0);								}							if (sampled==OTUs)		sp = standingdiv;							}						}					latest = observed[sampled-1];					}	/* End Tallying of Sampled Horizon	*/				}	/*  End Sampling for Each Horizon	*/			}	/* only do test while we need to sampled taxa */		}	/* only sample if we are including fossils	*/			else {		sampled = standingdiv;		/* if there are no fossils, "present" is when									   OTUs taxa evolve */		if (sampled==OTUs-1)	for (sp=0; sp<OTUs; ++sp)	observed[sp]=extants[sp];		}	if (sampled>=OTUs)	break;	/* don't bother with the rest if done */			/* cull species that went extinct */	for (a=0; a<=standingdiv; ++a)	{		sp=extants[a];		if (tex[sp]<(stage+1))	{			for (b=a+1; b<=standingdiv; ++b)	extants[b-1]=extants[b];			extants[standingdiv]=-1;			--standingdiv;			--a;			}		}		initdiv=standingdiv;				/****** REBOOT ROUTINE ******/	if (standingdiv < 0 || (cumulativediv>=mxtaxa && sampled < OTUs))	{		latest = -1;		/* clear vectors set to maxtaxa */		for (sp=0; sp<cumulativediv; ++sp)	{			ancestor[sp]=tex[sp]=tor[sp]=-1;			f1[sp]=0;		/* altered 2014-01-13	*/			}		/* clear vectors set to OTUs */		for (sp=0; sp<sampled; ++sp)			fa[sp]=la[sp]=observed[sp]=-1;				standingdiv = initdiv = cumulativediv = extants[0] = sampled = 0;		stage = 0;		++attempts;		/* use this to calculate how long the species will live */		extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		tex[0]=(log(1-extinct)/log(1-lmbd));		tor[0]=0.0f;		/*added 2014-01-13	*//*		if ((attempts%5)==0)	printf ("%2d tries and counting.\n",attempts); */		}				/** Reboot simulation **/	else	{		if (sampled < OTUs)	++stage;		/*  All OTUs species found	*/		else if (FOSSILS==0 && cumulativediv==((2*OTUs)-2))	{			for (sp=0; sp<=standingdiv; ++sp)		observed[sp] = extants[sp];			sampled = OTUs;			reboot=1;			}		/* if species index is out of range, then reboot the whole thing */		}	}mxdv=1+maxiarray(f1,cumulativediv);/* redone 2014-01-13	a=observed[OTUs-1];tree=lmatrix(nodes=(1+ancestor[a]),mxdv+1);for (sp=1; sp<observed[OTUs-1]; ++sp)	tree[ancestor[sp]][0]=1;for (sp=1; sp<observed[OTUs-1]; ++sp)	{	++tree[ancestor[sp]][0];	tree[ancestor[sp]][1]=ancestor[sp];	a=tree[ancestor[sp]][0];	tree[ancestor[sp]][a]=sp;	}	deleteme=ivector(cut=(observed[OTUs-1]-OTUs));ee=c=0;for (a=0; a<observed[OTUs-1]; ++a)	{	for (b=ee; b<(OTUs-1); ++b)	{		if (a==observed[b])	b=OTUs;		else if (a>observed[b] && a<observed[b+1])	{			deleteme[c]=a;			++c;			ee=b;			b=OTUs;			}	/* this species was not sampled			}	/* end search of observed taxa to find match		}for (c=0; c<cut; ++c)	{	for (a=0; a<nodes; ++a)	{		for (b=1; b<=tree[a][0]; ++b)	{			if (deleteme[c]==tree[a][b])	{				tree[a][b]=-1;				--tree[a][0];				b=tree[a][0]+1;				a=nodes;				}	/* delete taxon and decrement diversity				}		}	}/* tree matrix - rows 0...(OTUs-1) rows are for possible nodes	*//*		row OTUs-1 is for species branch lengths				*//*		row OTUs   is for nodal branch lengths					*//*		row OTUs+1 is for species FAs							*//*		row OTUs+2 is for species LAs							*//*		the first cell of rows 0É(OTUs-1) give # branches		*//*			(i.e., 2 for bifurcation w. no sampled ancestor)	*/tree=lmatrix(OTUs+3,OTUs);clearlmatrix(tree,OTUs+3,OTUs,-1);for (a=cumulativediv+1; a<mxtaxa; ++a)	f1[a]=ancestor[a]=0;if (observed[0]==-1)	{	printf("Taxa lost by line 377\a\n");	exit(0);	}/*********************************************************************************//*								Store True Phylogeny							 *//*********************************************************************************//**** LIST ANCESTORS OF EACH OBSERVED SPECIES ****/chucks=0;ancestor[0]=-1;/* find the distance from the base for each species */for (otu=0; otu<OTUs; ++otu)	{	sp=observed[otu];	anc=ancestor[sp];	if (anc>=0)		dbas[otu]=1;	for (a=1; anc>=0; ++a)	{		anc=ancestor[anc];		++dbas[otu];		}	}/* count the maximum number of ancestors */chucks=maxiarray(dbas,otu);/* list all of the ancestors for each species */forefathers=imatrix(OTUs,chucks+1);clearimatrix(forefathers,OTUs,chucks+1,-1);ancestor[0]=-1;for (otu=0; otu<OTUs; ++otu)	{	forefathers[otu][0]=sp=observed[otu];	anc=ancestor[sp];	for (a=1; anc>=0; ++a)	{		forefathers[otu][a]=anc;		anc=ancestor[anc];		}	}/* list the unsampled ancestors of each species *//* also, tally species with sampled descendants */free_ivector(f1);f1=ivector(OTUs);	/* 0: no sampled descendants; 1: 1+ sampled descendants *//* written out 2014-01-13	*/for (otu=0; otu<OTUs; ++otu)	{	/* rewrite this to count down until a common forefather		/* also, check to make sure that taxon is not ancestral; if it is, then make obsbl=0	*/	/* have it work down until it finds a number shared with another taxon;			keep the shortest one		*///	obsbl[otu]=1;	found=0;	for (a=1; a<dbas[otu]; ++a)	{		anc=forefathers[otu][a];		for (b=otu-1; b>=0; --b)	{			if (observed[b]==anc)	{				found=1;				f1[b]=1;				/* end loops 	*/				b=0;				a=dbas[otu];				}			}//		if (found==0)	++obsbl[otu];	/* this gives length to observed ancestor or base of tree	*/		}	}	/* create a matrix of branch distances between taxa *//* this gives distance to common ancestor, so the matrix is asymmetrical */pdmat=imatrix(otu,otu);camat=imatrix(otu,otu);for (otu=OTUs-1; otu>0; --otu)	{	for (otu2=otu-1; otu2>=0; --otu2)	{		for (a=0; a<=dbas[otu]; ++a)	{			sp=forefathers[otu][a];			for (b=0; b<=dbas[otu2]; ++b)	{				sp2=forefathers[otu2][b];				if (sp==sp2)	{					pdmat[otu][otu2]=a+1;					pdmat[otu2][otu]=b+1;					camat[otu][otu2]=camat[otu2][otu]=sp;					/* end loop */					b=dbas[otu2];					a=dbas[otu];					}				/* end loop if forefather[otu][a] cannot match forefather[otu2][any] */				else if (sp>sp2)	b=dbas[otu2];				}			}		}	}/* create a tree *//* keep track of common ancestors of each clade */nodes=found0=0;for (otu=OTUs-1; otu>0; --otu)	{	d=chucks;	for (otu2=otu-1; otu2>=0; --otu2)	{		if (pdmat[otu][otu2]<d)	{			d=pdmat[otu][otu2];			}		}	for (otu2=0; otu2<otu; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			anc=camat[otu][otu2];			found=-1;			for (a=0; a<nodes; ++a)	{				/* existing nodes found */				if (commonanc[a]==camat[otu][otu2])	{					found=0;					/* check to see if the species already is in the nodes */					for (b=1; b<=tree[a][0]; ++b)	{						if (otu2==tree[a][b])		found=1;						}					if (found==0)	{						for (b=1; b<=tree[a][0]; ++b)	{							if (otu==tree[a][b])	found=2;							}						}					/* if neither species already found */					if (found==0)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					/* if older species already found */					else if (found==1)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						}					/* if younger species already found */					else if (found==2)	{						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					a=nodes+1;					otu2=otu;					}				}	/* end search for previously found node */			/* new nodes found */			if (found==-1)	{				commonanc[nodes]=camat[otu][otu2];				tree[nodes][0]=2;				tree[nodes][1]=otu2;				tree[nodes][2]=otu;				++nodes;				if (otu2==0)	found0=1;				otu2=otu;				}	/* new node added */			}		}	}/* make sure that oldest species is included in the tree somewhere **/if (found0==0)	{	otu=0;	d=chucks;	for (otu2=1; otu<OTUs; ++otu2)	if (pdmat[otu][otu2]<d)		d=pdmat[otu][otu2];	for (otu2=1; otu<OTUs; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			tree[nodes][0]=2;			tree[nodes][1]=0;			tree[nodes][2]=otu2;			commonanc[nodes]=camat[0][otu2];			++nodes;			}		}	found0=1;	}	mxdv=2;for (a=0; a<nodes; ++a)	if (tree[a][0]>mxdv)	mxdv=tree[a][0];/*****  Sort Clades by Last Common Ancestor	*****/for (testnode=0; testnode<nodes; ++testnode)	{	d=commonanc[c=testnode];	for (clade=testnode+1; clade<nodes; ++clade)		if (commonanc[clade] <= d) d=commonanc[c=clade];	if (c != testnode)	{		commonanc[c]=commonanc[testnode];		commonanc[testnode]=d;		for (sp=0; sp<=mxdv; ++sp)	{			d=tree[testnode][sp];			tree[testnode][sp]=tree[c][sp];			tree[c][sp]=d;			}		}	}/**** WRITE OUT TREE ****/for (testnode=nodes-1; testnode>0; --testnode)	{	found=0;	sp=tree[testnode][1];	htu=testnode+OTUs;	for (plesion=testnode-1; found==0 && plesion>=0; --plesion)	{		for (a=1; a<=tree[plesion][0]; ++a)	{			sp2=tree[plesion][a];			/* ancestral node found */			if (sp2==sp)	{				if (sp<OTUs)	{					for (b=a+1; tree[plesion][b]<htu && b<=tree[plesion][0]; ++b)						tree[plesion][b-1]=tree[plesion][b];					tree[plesion][b-1]=htu;					}				/* different routine needed if clade */				else	{					oldfirst=tree[plesion][1];					for (b=a; tree[plesion][b-1]>htu; --b)	{						tree[plesion][b]=tree[plesion][b-1];						}					tree[plesion][b]=htu;					/* if first species was a clade but now is another clade */					/*   then the old must be replaced */					if (b==1 && oldfirst==tree[plesion][2])	{						sp=tree[plesion][2];						htu=tree[plesion][1];						}					}				/* if the first species was found, then it will be in lower clades 						*/				/* this means that the tree needs to be re-written or this node will never find a home  */				/*   So, swap the that species with the first species in tree[plesion] 					*/				/*     if a clade replaces a clade, htu remains unchanged */				if (a==1 || b==1)					htu=tree[plesion][1];				else					found=1;				a=tree[plesion][0];	/* end search */				}	/* end replacement of taxon within clade by node or new representative species */			}	/* end search of species within a lower node */		}	/* end search of nodes */	}		/************************  Determine Branch Lengths  ************************/for (sp=0; sp<OTUs; ++sp)	{	for (b=0; b<chucks; ++b)	{		for (c=(nodes-1); c>=0; --c)	{			if (forefathers[sp][b]==commonanc[c])	{				bl[sp]=b;				c=0;				b=chucks;				}			}		}	}//for (a=0; a<OTUs; ++a)					bl[a] = obsbl[a];for (a=OTUs; a<(OTUs+nodes); ++a)		bl[a] = 0;/***    Replace Branch lengths from sampled Ancestors to Nodes    ***/ for (sp=0; sp<OTUs; ++sp)	{	if (f1[sp]>0)	{		for (b=0; b<nodes; ++b)	{			if (commonanc[b]==observed[sp])	{				bl[b+OTUs] = bl[sp];				bl[sp] = 0;				}			}		}	}/* read back troufor (clade=(nodes-1); clade>=0; --clade)	{	a=clade;	d=0;	bl[OTUs+clade]=1;	while (d==0)	{		anc=ancestor[a];		for (c=(clade-1); c>=0; --c)	{			if (commonanc[c]==anc)	{				}			}		}		for (c=(clade-1)	}/***   Nodes Subsume the Apomorphies of their Unsampled Immediate Ancestors   ***/ for (clade=nodes-1; clade>=0; --clade)	{//	while (bl[clade+OTUs]>0 && clade>0)	--clade;//	if (clade<0)	break;	htu=commonanc[clade];			/* fixed 2014-01-14	*/	anc=ancestor[htu];				/* fixed 2014-01-14	*/	if (anc>=0)		found=0;		/* fixed 2014-01-14	*/	while (found==0)	{		++bl[clade+OTUs];			/* fixed 2014-01-14	*/		for (c=(clade-1); c>=0 && found==0; --c)	{			if (anc==commonanc[c])	{				found=1;			/* fixed 2014-01-14	*/				c=0;				/* fixed 2014-01-14	*/				}	/* examine common ancestors for ancestor of node	*/			if (commonanc[c]<anc)	c=0;	/* no more hope!  escape	*/			}		anc=ancestor[anc];			/* fixed 2014-01-14	*/		if (anc<0)	found=-1;		/* fixed 2014-01-14	*/		}	/* search through common ancestors to see if tis ancestor is found	*//*	for (a=0; (found==0 && anc>-1); ++a)	{		++bl[clade+OTUs];		for (b=0; b<OTUs; ++b)	{			/* if ancestor is observed, prepare to stop the loop *//*			if (observed[b]==anc)	{				found=1;				b=OTUs;				}			/* once species are older than ancestor, abandon search to speed loop *//*			else if (observed[b]>anc)	b=OTUs;			}		anc=ancestor[anc];		}	*/	}	/* count down all clades	*//* add branch lengths to tree  */for (a=0; a<OTUs; ++a)	tree[OTUs-1][a]=bl[a];for (b=0; b<nodes; ++b)	{	a=OTUs+b;	tree[OTUs][b]=bl[a];	}/* add first and last appearances to tree  */for (a=0; a<OTUs; ++a)	{	tree[OTUs+1][a]=fa[a];	tree[OTUs+2][a]=la[a];	}/* convert tree to Venn tree	*/for (cl=nodes-1; cl>=0; --cl)	{	for (f1=1; f1<=tree[cl][0]; ++f1)	{		sp=tree[cl][f1];		/* tally total diversity and cumulative membership */		if (sp>=maxsp)	{			dcl=sp-maxsp;			b=vtree[dcl][0]-1;			for (a=tree[cl][0]; a>f1; --a)		tree[cl][a+b]=vtree[cl][a];			for (a=f1; a<f1+tree[dcl][0]; ++a)	tree[cl][a]=vtree[dcl][1+a-f1];			tree[cl][0]=tree[cl][0]+tree[dcl][0]-1;			f1=f1+tree[dcl][0]-1;			}		}	for (f1=tree[cl][0]+1; f1<=notu; ++f1)	tree[cl][f1]=-1;	}free_ivector(observed);free_ivector(commonanc);//free_ivector(obsbl);free_ivector(fa);free_ivector(la);free_ivector(bl);free_ivector(extants);free_ivector(ancestor);free_imatrix(forefathers,OTUs,chucks+1);free_ivector(f1);free_ivector(dbas);	free_dvector(tor);free_dvector(tex);free_imatrix(pdmat,otu,otu);free_imatrix(camat,otu,otu);return tree;}