/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//*/*	M. Kosnik's basic utility functions as of 1998.11.24/*	mkosnik@uchicago.edu/*/*	This file is copyright (C) 1998 Matthew Kosnik/*/*	This program is free software; you can redistribute it and/or modify it /*	under the terms of version 2 the GNU General Public License as published /*	by the Free Software Foundation./*/*	This program is distributed in the hope that it will be useful, but WITHOUT/*	ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or /*	FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for /*	more details./*/*	To view a copy of the license go to:/*	http://www.fsf.org/copyleft/gpl.html/*	To receive a copy of the GNU General Public License write the Free Software/* 	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA./*/*	Copies of this source code are available without cost from:/*	http://geosci.uchicago.edu/paleo/csource//*	/*	These work for me using Codewarrior 4 on a mac 7600/233/*/*	Print functions:/*		p_int_matrix prints an int rectangular matrix to the screen/*		p_float_matrix prints a float rectangular matrix to the screen /*		p_double_matrix prints a double rectangular matrix to the screen /*			to call any of these (nothing is returned):/*				p_double_matrix(matrix, columns, rows);	/*		/*		fp_int_matrix prints an int rectangular matrix to a file/*		fp_float_matrix prints a float rectangular matrix to a file  /*		fp_double_matrix prints a double rectangular matrix to a file /*			to call any of these (nothing is returned):/*				fp_double_matrix(matrix, columns, rows, filename);	/*	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */#define print_matrix #include "print.h"/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* print an integer rectangular matrix to screen							 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void p_int_matrix(int **matrix, int rows, int columns){	int j, k;	for (j=0 ; j<rows ; j++) {		printf("\n%d\t", j);		for (k=0 ; k<columns ; k++) {			printf("%d\t", matrix[j][k]);		}	}	printf("\n");return;}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* print an unsigned long rectangular matrix to screen							 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void p_ulong_matrix(unsigned long **matrix, int rows, int columns){	int j, k;	for (j=0 ; j<rows ; j++) {		printf("\n%d\t", j);		for (k=0 ; k<columns ; k++) {			printf("%u\t", matrix[j][k]);		}	}	printf("\n");return;}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* print a float rectangular matrix to screen								 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void p_float_matrix(float **matrix, int rows, int columns){	int j, k;	for (j=0 ; j<rows ; j++) {		printf("\n%d\t", j);		for (k=0 ; k<columns ; k++) {			printf("%8.4f", matrix[j][k]);		}	}	printf("\n");return;}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* print a double rectangular matrix to screen								 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void p_double_matrix(double **matrix, int rows, int columns){	int j, k;	for (j=0 ; j<rows ; j++) {		printf("\n%d\t", j);		for (k=0 ; k<columns ; k++) {			printf("%8.4f", matrix[j][k]);		}	}	printf("\n");return;}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* print a rectangular int matrix to file									 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void fp_int_matrix(int **matrix, int rows, int columns, struct _FILE *file){	int j, k;	for (j=0 ; j<rows; j++) {		fprintf(file, "\n%d\t", j);		for (k=0 ; k<columns ; k++) {			fprintf(file, "%d\t", matrix[j][k]);		}	}	fprintf(file, "\n");return;}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* print a rectangular unsigned long matrix to file									 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void fp_ulong_matrix(unsigned long **matrix, int rows, int columns, struct _FILE *file){	int j, k;	for (j=0 ; j<rows; j++) {	/*	fprintf(file, "\n%d\t", j);	*/	fprintf(file, "\n");		for (k=0 ; k<columns ; k++) {			fprintf(file, "%d\t", matrix[j][k]);		}	}	fprintf(file, "\n");return;}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* print a square float matrix to file										 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void fp_float_matrix(float **matrix, int rows, int columns, struct _FILE *file){	int j, k;	for (j=0 ; j<rows; j++) {		fprintf(file, "\n%d\t", j);		for (k=0 ; k<columns ; k++) {			fprintf(file, "%8.4f", matrix[j][k]);		}	}	fprintf(file, "\n");return;}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* print a square double matrix to file										 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void fp_double_matrix(double **matrix, int rows, int columns, struct _FILE *file){	int j, k;	for (j=0 ; j<rows; j++) {		fprintf(file, "\n%d\t", j);		for (k=0 ; k<columns ; k++) {			fprintf(file, "%8.4f", matrix[j][k]);		}	}	fprintf(file, "\n");return;}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* print a site x species matrix to file/* sites as rows, taxa as columns						/* rosen format:/*	line 1  number of columns, number of rows/*	line 2+ matrix with no row or column lables/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void fp_ul_matrix1(unsigned long **matrix, int rows, int columns, char *file){	int j, k;								/* loop variables */	FILE *Output;							/* output file */	printf("\nCreating a rosen matrix\n");	Output = fopen(file, "w");	fprintf(Output,"%d\t%d", columns, rows);		for (j=0 ; j<rows; j++) {		fprintf(Output, "\n");		for (k=0 ; k<columns ; k++) {			fprintf(Output, "%d\t", matrix[j][k]);		}	}	fclose(Output);return;}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* print a site x species matrix to file	/* sites as columns, taxa as rows						/* contains creature comforts like:/* row and column labels, including site bins and taxonomic groups/* contains an split into multiple files if size too big./* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void fp_ul_matrix2(unsigned long **matrix, unsigned long *sites, unsigned long *bins, unsigned long *taxa, unsigned long *grps, int nsite, int ntaxa, char *file){	int j, k;								/* loop variables */	FILE *Output;							/* output file */	int numfiles=0;							/* the number of output files to create */	int col2 = nsite;						/* the number of columns remaining to output */	int maxcolumns = 4092-2;					/* maximium number of columns allowed per file */	char str[30], strn[2];	printf("\nCreating a lockwood matrix\n");	if (nsite > maxcolumns)		nsite = maxcolumns;	for ( ; col2 > 0 ; col2 -= maxcolumns) {		if (col2 > maxcolumns) {			nsite = maxcolumns;		}		else nsite = col2;				strcpy(str, file); 		sprintf(strn,"%d",numfiles);		strcat(str,strn);		Output = fopen(str, "w");		fprintf(Output, "\t\t");						/* blank spaces so site names line up*/		for (k=(numfiles*maxcolumns) ; k < (nsite + (numfiles*maxcolumns)) ; k++)			fprintf(Output, "%d\t",bins[k]);			/* print site names at top of matrix */		fprintf(Output, "\n\t\t");						/* blank spaces so site names line up*/		for (k=(numfiles*maxcolumns) ; k < (nsite + (numfiles*maxcolumns)) ; k++)			fprintf(Output, "%d\t",sites[k]);			/* print site names at top of matrix */		for (j=0 ; j < ntaxa; j++) {			fprintf(Output, "\n%d\t", grps[j]);	/* print taxon group */			fprintf(Output, "%d\t", taxa[j]);	/* print taxon name */			for (k=(numfiles*maxcolumns) ; k< (nsite + (numfiles*maxcolumns)) ; k++) {				fprintf(Output, "%d\t", matrix[k][j]);	/* print abundance of taxon at site */			}		}		fclose(Output);		numfiles++;	}return;}/* written by m. kosnik 2000.02.18/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void f_significance_report (float *mean, float **hilo, int ngrps, int nbins, unsigned long *binnums, char *file){	int i, j, k;	int inc=0;	FILE *Output;							/* output file */	Output = fopen(file, "w");	for (j=0 ; j <ngrps ; j ++)		fprintf(Output,"\t%d", j);		for (k=inc ; k<nbins ; k++) {		for (i=inc+1 ; i<nbins ; i++) {			fprintf(Output,"\n%d-%d\t", binnums[k], binnums[i]);			for (j=0 ; j <ngrps ; j ++){				if (hilo[k+j][0] > hilo[i*ngrps+j][1])					fprintf(Output,">>\t");				else if (hilo[k+j][1] < hilo[i*ngrps+j][0])					fprintf(Output,"<<\t");				else if ((mean[k+j] > hilo[i*ngrps+j][0]) && (mean[k+j] > hilo[i*ngrps+j][1]))					fprintf(Output,">\t");				else if ((mean[k+j] < hilo[i*ngrps+j][0]) && (mean[k+j] < hilo[i*ngrps+j][1]))					fprintf(Output,"<\t");				else 					fprintf(Output,"ns\t");			}		}		inc++;	}	fclose(Output);	return;}/* written by m. kosnik 2000.02.18/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void sf_significance_report (float *mean, float **hilo, int ngrps, int nbins, unsigned long *binnums){	int i, j, k;	int inc=0;	for (j=0 ; j <ngrps ; j ++)		printf("\t%d", j);		for (k=inc ; k<nbins ; k++) {		for (i=inc+1 ; i<nbins ; i++) {			printf("\n%d-%d\t", binnums[k], binnums[i]);			for (j=0 ; j <ngrps ; j ++){				if (hilo[k+j][0] > hilo[i*ngrps+j][1])					printf(">>\t");				else if (hilo[k+j][1] < hilo[i*ngrps+j][0])					printf("<<\t");				else if ((mean[k+j] > hilo[i*ngrps+j][0]) && (mean[k+j] > hilo[i*ngrps+j][1]))					printf(">\t");				else if ((mean[k+j] < hilo[i*ngrps+j][0]) && (mean[k+j] < hilo[i*ngrps+j][1]))					printf("<\t");				else 					printf("ns\t");			}		}		inc++;	}	return;}