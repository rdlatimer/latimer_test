						else if (prfl[swing][0]==prfl[end1][0] && prfl[swing][0]<=prfl[end2][0])	{							/* if end1 or swing disappears before end2 appears OR if end1 or swing disappears first when both disappear before end1, then assume it is not ancestral	*//*							if ((prfl[end1][1]+1)<prfl[end2][0] && (prfl[swing][1]+1)>=prfl[end2][0])	*/							/* swing outlasts end1, so assume that it is ancestral to end2	*/							if ((prfl[end1][1]+1)<prfl[end2][0] && prfl[swing][1]>prfl[end1][1])								stratcomp[8]+=1.0f;							/* end1 outlasts swing, so assume that it is ancestral to end2	*/							else if ((prfl[end1][1]+1)<prfl[end2][0] && prfl[swing][1]<prfl[end1][1])								stratcomp[8]+=0.0f;							/* otherwise, assume that this could be either hierarchical or divergent									*/							else								stratcomp[8]+=0.5f;							/* now worry about budding and anagenesis.  First, it's 50% that it's divergent, so all values are chopped in half			*/							/*		2nd, the first two pairs can only fit budding as they are contemporaneous											*/							stratcomp[10]+=0.25f;					/* end1 & swing consistent with budding IF the pair is hierarchical		    		*/							/* ask whether possible hierarchical compatibility is consistent with anagenesis or budding									*/							if (prfl[end2][0]>=prfl[swing][1])								stratcomp[9]+=0.25f;				/* consistent with anagenesis: but only half because it might not be hierarchical	*/							else								stratcomp[10]+=0.25f;				/* one pair definitely consistent with budding, other might be		    			*/														/* we know that end1 and swing overlap; the quesiton is whether swing overlaps with end2	*/							if ((prfl[swing][1]+1)>=prfl[end2][0])	{								stratcomp[6]+=1.0f;					/* no gap between morphotypes								*/								/* super-strict requires no gaps at all!														*/								f=sumlvector(gap,3);								if (f==0)		stratcomp[7]+=1.0f;	/* no gaps within or between morphotypes					*/ 								}							}	/* end routine for clearly hierarchical															*/