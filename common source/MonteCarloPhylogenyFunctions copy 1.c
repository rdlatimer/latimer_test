#define MonteCarloPhylogenyFunctions#include "MonteCarloPhylogenyFunctions.h"#include "compatibility_functions.h"#include "historicaldiversity.h"#include "matrixanalysis.h"#include "matrixchange.h"#include "matrixreading.h"#include "memory.h"#include "minmax.h"#include "probability.h"#include "tree_read.h"#include <stdlib.h>#include <stdio.h>#include <time.h>#include <math.h>#include <string.h>#define	e	2.718281828/**** 2011-03-28: GENERAL ISSUE: MAKE SURE THAT VENN TREES LOOK TO THE CORRECT ROWS FOR BRANCH LENGTHS!!!	****/// /* evolvetree - Evolves a paleontological tree, with notu taxa sampled over time/* Requires:	notu - # of sampled taxa/*				MBL - simulation parameters where	 				MBL[0] (lmbd) - Speciation rate/*					MBL[1] (mu) - Extinction rate/*					MBL[2] (fr) - Preservation rate/*					MBL[3] (vr) - Variance in preservation rate/*					MBL[4] (speciation) - (1) bifurcation (0) budding cladogenesis				FOSSILS - (1) fossils sampled, (0) no fossils sampled/* Major Rewrite of Sampled Tree Construction 02/2003/* Rewritten to use real numbers from a single array (MBL)/* Returns: tree where				tree[0][0]…tree[clades-1][0] gives number of descendants of a node;				tree[0][1…tree[0][0]]…tree[clades-1][1…tree[clades-1][0]] give desendants where					0…OTUs-1 are taxon numbers;					OTUs…OTUs+clades are HTU numbers (daughter clades);				tree[OTUs-1][0…OTUs-1] give branch lengths of sampled taxa;				tree[OTUS][0…clades-1] give branch lengths of unsampled taxa;				tree[OTUs+1][0…OTUs-1] give first appearances of sampled taxa;				tree[OTUs+2][0…OTUs-1] give last appearances of sampled taxa;******************************************************************************************************/long **evolvetree(int OTUs, double *MBL, int FOSSILS){long	attempts, base=100000, speciation;int		a, b, c, d, ee, charstandard, ch, latest, mxdv=6, chucks, brats;int		clade, otu, otu2, htu, sampled, initdiv, standingdiv, cumulativediv, stage, newby;int		species, anc, change, testnode, plesion, found0, oldfirst;int		reboot;int		sp, sp2, nodes, found;int		mxtaxa, mxstnd;int		*f1, **forefathers, *ancestor;int		*extants, *observed, *commonanc, *bl;int		*fa, *la, *dbas;int		**pdmat, **camat;//int		*deleteme, cut, *obsbl;long	**tree;double	lmbd, mu, fr, vr, vfr, frp;double	speciate, extinct, find;double	*tor, *tex;double	v, x, y, mod;lmbd=MBL[0];mu=MBL[1];fr=MBL[2];vr=MBL[3];if (vr<1)	vr=MBL[3]=1.0f;speciation=MBL[4];v=expectedpropsampled(MBL[1],MBL[2]);v=1/v;mxtaxa=10*v*OTUs;if (mxtaxa>30000)	mxtaxa=30000;/*if (FOSSILS=1)	mxstnd=2*OTUs;	*//*else			mxstnd=3*OTUs;		*/mxstnd=3*OTUs;/* arrays for observed taxa - set to OTUs*/observed=ivector(OTUs);		/* observed (sampled) taxa 					*/fa=ivector(OTUs);			/* first appearance of a taxon				*/la=ivector(OTUs);			/* last appearance of a taxon				*//*obsbl=ivector(OTUs);		/* branch lengths of sampled taxa			*/commonanc=ivector(2*OTUs);	/* ancestors of a taxon						*/dbas=ivector(OTUs);			/* patristic distance from base to taxon	*/bl=ivector(2*OTUs);			/* array for all elements of the tree 		*/extants = ivector(mxstnd+1);	/* array for standing taxa - set to mxstnd*/	/* arrays for sampled and unsampled taxa - set to mxtaxa */ancestor=ivector(mxtaxa);	/* ancestor of each taxon 					*/f1=ivector(mxtaxa);			/* number of descendants for each taxon 	*/tor=dvector(mxtaxa);		/* true origination - this is a real number */tex=dvector(mxtaxa);		/* true extinction - this is a real number 	*/reboot=0;a=b=c=d=ee=anc=0;charstandard = 1; /*charbase/100;*/sp = ch = change = find = 0;clearivector(observed,OTUs,-1);//clearivector(obsbl,OTUs,-1);clearivector(ancestor,mxtaxa,-1);clearivector(extants,mxstnd+1,-1);latest = -1;attempts = initdiv = standingdiv = cumulativediv = stage = extants[0] = sampled = 0;/* use this to calculate how long the species will live */extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);while (extinct<=0)	extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);tex[0]=(log(1-extinct)/log(1-mu));tor[0]=0.0f;		/*added 2014-01-13	*/while (sampled < OTUs)	{	initdiv = standingdiv+1;	for (sp=0; (sp<=standingdiv && cumulativediv<mxtaxa); ++sp)	{	/********************************************/	/*			Does Lineage Speciate?			*/	/********************************************/		if (sp<0 || sp>mxstnd)	{			printf("ERROR 108: %d is the wrong number of species!\n", sp);			exit(0);			}		species = extants[sp];/*		mod=1.0f;	*//*		if (tor[species]>stage)	*//*			mod=(stage+1)-tor[species];	/* mod reflects shortened time for extinction and speciation *//*		/*		v=1-pow((1-mu),mod);	/* this will equal mu if it survives the whole interval *//*		/* if v is still less than extinction rate, then the species dies this interval *//*		if (extinct<v)	{*//*			/* now randomly generate a number to show when it dies *//*			x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);*//*			/* if it existed at the beginning		*//*			if (tor[species]<=stage)	tex[species]+=x;*//*			/* if it originated durign this stage	*/ /*			else						tex[species]+=x*(((double) (stage+1))-tor[species]);*//*			}*//*		/* if it survies, then bump the extinction to the next interval	*//*		else							tex[species]=stage+1;	*/				if (f1[species]<mxdv)	speciate = (((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		else					speciate = 1.0f;				/* do this to shake up random number generator */		if (sp%2==0)			speciate=1-speciate;		v=lmbd;		if (tex[species]<(stage+1) || tor[species]>stage)	{			if (tex[species]<(stage+1) && tor[species]>stage)											mod=tex[species]-tor[species];			else if (tor[species]<stage)	mod=tex[species]-stage;			else if (tex[species]>stage+1)	mod=((double) (stage+1))-tor[species];			v=1-pow((1-lmbd),mod);	/* this will equal lmbd if it survives the whole interval */									/* (1-lmbd) is prob. of not speciating; 										(1-lmbd)^mod = prob of not speciating over mod										1-([1-lmbd]^mod) = prob. of speciating over mod	*/			}	/* end case for taxa present during only part of "stage"	*/		if (speciation==1)	ee=2;		else				ee=1;		if (speciate <= v && (standingdiv<(mxstnd-ee)))		{			brats=1;			/* if bifurcation, then two descendants when ancestor disappears		*/			if (speciation==1)	brats=2;			/* if budding, then allow for multiple descendants at different times 	*/			else	{				if (tor[species]>stage)	v=(stage+1)-tor[species];				else					v=1;				x=Poisson(lmbd, v, 2);				if (v<x)				brats=2;				}			/* go through each descendant */			for (a=0; a<brats; ++a)	{				++standingdiv;				++cumulativediv;				extants[standingdiv] = cumulativediv;				if (cumulativediv > mxtaxa)	{					printf("ERROR Evolve 187 - In replication XXX");					printf(", more than %3d species were generated.  \n",mxtaxa);					sampled=OTUs;					exit(0);						}				if (standingdiv<0 || standingdiv>mxstnd)	{					printf("ERROR 193:  Standing diversity too high at %2d\n",standingdiv);					sampled=OTUs;					exit(0);						}							if (cumulativediv<0 || cumulativediv>=mxtaxa || species<0 || species>=mxtaxa)	{					printf("ERROR 199 - ancestor index out of range at %d and %d\n",species,cumulativediv);					sampled=OTUs;					exit(0);						}				ancestor[cumulativediv] = species;				anc = species;				++f1[anc];						/*******************************************************************************/		/* Ancestors become pseudo-extinct at bifurcation if that is what is happening */		/*******************************************************************************/				if (speciation==0 || (speciation==1 && a==0))	{					y=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					/* if ancestor originated during stage and extends into the next	*/					if (tex[anc]>stage+1 && tor[anc]>stage)						tor[cumulativediv]=tor[anc]+(y*((stage+1)-tor[anc]));					/* if ancestor goes extinct during stage and originated before it	*/					else if (tex[anc]<(stage+1) && tor[anc]<stage)						tor[cumulativediv]=stage+(y*(tex[anc]-stage));					/* if ancestor both originates and goes extinct during stage		*/					else if (tex[anc]<(stage+1) && tor[anc]>stage)						tor[cumulativediv]=tor[anc]+(y*(tex[anc]-tor[anc]));					else						tor[cumulativediv]=y+ ((double) stage);										/* if we are dealing with the first species of a bifurcation, give it ancestral extinction time.	*/					/* 		Ancestor disappears when descendants arise													*/ 					if (speciation==1)	{						tex[cumulativediv]=tex[anc];						tex[anc]=tor[cumulativediv];						}					}				/* second species of a bifurcation */				else if (a==1)	tor[cumulativediv]=tex[anc];								/* establish extinction if the species becomes extinct */				if (speciation==0 || (speciation ==1 && a==1))	{					/* if we are dealing with the second species, then give it its own extinction time but the same origination time */					extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					tex[cumulativediv]=tor[cumulativediv]+(log(1-extinct)/log(1-mu));					}				}			}		if (FOSSILS==0 && standingdiv>=OTUs-1)	sp = initdiv;	/* quit if enough taxa are alive */		}	/****  End Speciation Round ****/ 				if (FOSSILS==1)	{		/********************************************/		/*				 Do Sampling				*/		/*  Separated from Speciation Loop 1/3/97   */		/********************************************/		if (sampled < OTUs)	{			for (sp=0; sp<=standingdiv; ++sp)	{				species = extants[sp];								/* Raw Species Number *//*				find = (((unsigned int) rand())%base)+1;	*//*				if (f1[species]>=3 || cumulativediv>=(3*mxstnd))	find = 0;	*/				find=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				/* do this to shake up the random number generator */				if (sp%2==0)	find=1-find;								/* insert lognormal part here	*/				x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				y=normsinv(x);				vfr=pow(vr,y);				v=fr*vfr;				frp=log(1-(fr*vfr));				/* 2012-01-10: Poisson expectation so that P[0 | 1 stage, fr] = 1=fr	*/											/* keep this here so that we can handle variable sampling				*/				if (tex[species]<(stage+1) || tor[species]>stage)	{					/* if species originates and disappears in this interval 			*/					if (tex[species]<(stage+1) && tor[species]>stage)														mod=tex[species]-tor[species];					/* if species originated earlier but goes extinct in this interval	*/					else if (tex[species]<(stage+1))	mod=tex[species]-stage;					/* if species goes extinct later but originates in this interval	*/					else if (tex[species]>(stage+1))	mod=((double) (stage+1))-tor[species];					v=1-pow(1-(fr*vfr),mod);	/* this will equal fr*vfr if it survives the whole interval */												/*	(1-[fr*vfr]) = prob. of missing over whole interval													(1-[fr*vfr])^mod = prob. of missing over mod.  	*/					}						if (find <= v)	{					newby = 0;					/** First sampled species goes straight into the array **/					if (sampled==0)	{						observed[sampled]=species;						fa[sampled]=la[sampled]=stage;						++sampled;						}					/** Test whether a sampled species had gone unsampled **/					else	{						for (otu = 0; otu < sampled;  ++otu)	{							if (observed[otu] == species)	{								newby = 1;		/* species is not new */								la[otu]=stage;								otu = sampled;								}							}						if (newby == 0 && sampled < OTUs)	{							/* sort species as you go */							a=sampled-1;							while (observed[a]>species && a>=0)	{								observed[a+1]=observed[a];								fa[a+1]=fa[a];								la[a+1]=la[a];								--a;								}							observed[a+1] = species;							fa[a+1]=la[a+1]=stage;							++sampled;							if (sampled<0 || sampled>OTUs)	{								printf("ERROR 189: You somehow sampled %d\n",sampled);								exit(0);								}							if (sampled==OTUs)		sp = standingdiv;							}						}					latest = observed[sampled-1];					}	/* End Tallying of Sampled Horizon	*/				}	/*  End Sampling for Each Horizon	*/			}	/* only do test while we need to sampled taxa */		}	/* only sample if we are including fossils	*/			else {		sampled = standingdiv;		/* if there are no fossils, "present" is when									   OTUs taxa evolve */		if (sampled==OTUs-1)	for (sp=0; sp<OTUs; ++sp)	observed[sp]=extants[sp];		}	if (sampled>=OTUs)	break;	/* don't bother with the rest if done */			/* cull species that went extinct */	for (a=0; a<=standingdiv; ++a)	{		sp=extants[a];		if (tex[sp]<(stage+1))	{			for (b=a+1; b<=standingdiv; ++b)	extants[b-1]=extants[b];			extants[standingdiv]=-1;			--standingdiv;			--a;			}		}		initdiv=standingdiv;				/****** REBOOT ROUTINE ******/	if (standingdiv < 0 || (cumulativediv>=mxtaxa && sampled < OTUs))	{		latest = -1;		/* clear vectors set to maxtaxa */		for (sp=0; sp<cumulativediv; ++sp)	{			ancestor[sp]=tex[sp]=tor[sp]=-1;			f1[sp]=0;		/* altered 2014-01-13	*/			}		/* clear vectors set to OTUs */		for (sp=0; sp<sampled; ++sp)			fa[sp]=la[sp]=observed[sp]=-1;				standingdiv = initdiv = cumulativediv = extants[0] = sampled = 0;		stage = 0;		++attempts;		/* use this to calculate how long the species will live */		extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		tex[0]=(log(1-extinct)/log(1-mu));		tor[0]=0.0f;		/*added 2014-01-13	*//*		if ((attempts%5)==0)	printf ("%2d tries and counting.\n",attempts); */		}				/** Reboot simulation **/	else	{		if (sampled < OTUs)	++stage;		/*  All OTUs species found	*/		else if (FOSSILS==0 && cumulativediv==((2*OTUs)-2))	{			for (sp=0; sp<=standingdiv; ++sp)		observed[sp] = extants[sp];			sampled = OTUs;			reboot=1;			}		/* if species index is out of range, then reboot the whole thing */		}	}mxdv=1+maxiarray(f1,cumulativediv);/* redone 2014-01-13	a=observed[OTUs-1];tree=lmatrix(nodes=(1+ancestor[a]),mxdv+1);for (sp=1; sp<observed[OTUs-1]; ++sp)	tree[ancestor[sp]][0]=1;for (sp=1; sp<observed[OTUs-1]; ++sp)	{	++tree[ancestor[sp]][0];	tree[ancestor[sp]][1]=ancestor[sp];	a=tree[ancestor[sp]][0];	tree[ancestor[sp]][a]=sp;	}	deleteme=ivector(cut=(observed[OTUs-1]-OTUs));ee=c=0;for (a=0; a<observed[OTUs-1]; ++a)	{	for (b=ee; b<(OTUs-1); ++b)	{		if (a==observed[b])	b=OTUs;		else if (a>observed[b] && a<observed[b+1])	{			deleteme[c]=a;			++c;			ee=b;			b=OTUs;			}	/* this species was not sampled			}	/* end search of observed taxa to find match		}for (c=0; c<cut; ++c)	{	for (a=0; a<nodes; ++a)	{		for (b=1; b<=tree[a][0]; ++b)	{			if (deleteme[c]==tree[a][b])	{				tree[a][b]=-1;				--tree[a][0];				b=tree[a][0]+1;				a=nodes;				}	/* delete taxon and decrement diversity				}		}	}/* tree matrix - rows 0...(OTUs-1) rows are for possible nodes	*//*		row OTUs-1 is for species branch lengths				*//*		row OTUs   is for nodal branch lengths					*//*		row OTUs+1 is for species FAs							*//*		row OTUs+2 is for species LAs							*//*		the first cell of rows 0…(OTUs-1) give # branches		*//*			(i.e., 2 for bifurcation w. no sampled ancestor)	*/tree=lmatrix(OTUs+3,OTUs);clearlmatrix(tree,OTUs+3,OTUs,-1);for (a=cumulativediv+1; a<mxtaxa; ++a)	f1[a]=ancestor[a]=0;if (observed[0]==-1)	{	printf("Taxa lost by line 377\a\n");	exit(0);	}/*********************************************************************************//*								Store True Phylogeny							 *//*********************************************************************************//**** LIST ANCESTORS OF EACH OBSERVED SPECIES ****/chucks=0;ancestor[0]=-1;/* find the distance from the base for each species */for (otu=0; otu<OTUs; ++otu)	{	sp=observed[otu];	anc=ancestor[sp];	if (anc>=0)		dbas[otu]=1;	for (a=1; anc>=0; ++a)	{		anc=ancestor[anc];		++dbas[otu];		}	}/* count the maximum number of ancestors */chucks=maxiarray(dbas,otu);/* list all of the ancestors for each species */forefathers=imatrix(OTUs,chucks+1);clearimatrix(forefathers,OTUs,chucks+1,-1);ancestor[0]=-1;for (otu=0; otu<OTUs; ++otu)	{	forefathers[otu][0]=sp=observed[otu];	anc=ancestor[sp];	for (a=1; anc>=0; ++a)	{		forefathers[otu][a]=anc;		anc=ancestor[anc];		}	}/* list the unsampled ancestors of each species *//* also, tally species with sampled descendants */free_ivector(f1);f1=ivector(OTUs);	/* 0: no sampled descendants; 1: 1+ sampled descendants *//* written out 2014-01-13	*/for (otu=0; otu<OTUs; ++otu)	{	/* rewrite this to count down until a common forefather		/* also, check to make sure that taxon is not ancestral; if it is, then make obsbl=0	*/	/* have it work down until it finds a number shared with another taxon;			keep the shortest one		*///	obsbl[otu]=1;	found=0;	for (a=1; a<dbas[otu]; ++a)	{		anc=forefathers[otu][a];		for (b=otu-1; b>=0; --b)	{			if (observed[b]==anc)	{				found=1;				f1[b]=1;				/* end loops 	*/				b=0;				a=dbas[otu];				}			}//		if (found==0)	++obsbl[otu];	/* this gives length to observed ancestor or base of tree	*/		}	}	/* create a matrix of branch distances between taxa *//* this gives distance to common ancestor, so the matrix is asymmetrical */pdmat=imatrix(otu,otu);camat=imatrix(otu,otu);for (otu=OTUs-1; otu>0; --otu)	{	for (otu2=otu-1; otu2>=0; --otu2)	{		for (a=0; a<=dbas[otu]; ++a)	{			sp=forefathers[otu][a];			for (b=0; b<=dbas[otu2]; ++b)	{				sp2=forefathers[otu2][b];				if (sp==sp2)	{					pdmat[otu][otu2]=a+1;					pdmat[otu2][otu]=b+1;					camat[otu][otu2]=camat[otu2][otu]=sp;					/* end loop */					b=dbas[otu2];					a=dbas[otu];					}				/* end loop if forefather[otu][a] cannot match forefather[otu2][any] */				else if (sp>sp2)	b=dbas[otu2];				}			}		}	}/* create a tree *//* keep track of common ancestors of each clade */nodes=found0=0;for (otu=OTUs-1; otu>0; --otu)	{	d=chucks;	for (otu2=otu-1; otu2>=0; --otu2)	{		if (pdmat[otu][otu2]<d)	{			d=pdmat[otu][otu2];			}		}	for (otu2=0; otu2<otu; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			anc=camat[otu][otu2];			found=-1;			for (a=0; a<nodes; ++a)	{				/* existing nodes found */				if (commonanc[a]==camat[otu][otu2])	{					found=0;					/* check to see if the species already is in the nodes */					for (b=1; b<=tree[a][0]; ++b)	{						if (otu2==tree[a][b])		found=1;						}					if (found==0)	{						for (b=1; b<=tree[a][0]; ++b)	{							if (otu==tree[a][b])	found=2;							}						}					/* if neither species already found */					if (found==0)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					/* if older species already found */					else if (found==1)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						}					/* if younger species already found */					else if (found==2)	{						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					a=nodes+1;					otu2=otu;					}				}	/* end search for previously found node */			/* new nodes found */			if (found==-1)	{				commonanc[nodes]=camat[otu][otu2];				tree[nodes][0]=2;				tree[nodes][1]=otu2;				tree[nodes][2]=otu;				++nodes;				if (otu2==0)	found0=1;				otu2=otu;				}	/* new node added */			}		}	}/* make sure that oldest species is included in the tree somewhere **/if (found0==0)	{	otu=0;	d=chucks;	for (otu2=1; otu<OTUs; ++otu2)	if (pdmat[otu][otu2]<d)		d=pdmat[otu][otu2];	for (otu2=1; otu<OTUs; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			tree[nodes][0]=2;			tree[nodes][1]=0;			tree[nodes][2]=otu2;			commonanc[nodes]=camat[0][otu2];			++nodes;			}		}	found0=1;	}	mxdv=2;for (a=0; a<nodes; ++a)	if (tree[a][0]>mxdv)	mxdv=tree[a][0];/*****  Sort Clades by Last Common Ancestor	*****/for (testnode=0; testnode<nodes; ++testnode)	{	d=commonanc[c=testnode];	for (clade=testnode+1; clade<nodes; ++clade)		if (commonanc[clade] <= d) d=commonanc[c=clade];	if (c != testnode)	{		commonanc[c]=commonanc[testnode];		commonanc[testnode]=d;		for (sp=0; sp<=mxdv; ++sp)	{			d=tree[testnode][sp];			tree[testnode][sp]=tree[c][sp];			tree[c][sp]=d;			}		}	}/**** WRITE OUT TREE ****/for (testnode=nodes-1; testnode>0; --testnode)	{	found=0;	sp=tree[testnode][1];	htu=testnode+OTUs;	for (plesion=testnode-1; found==0 && plesion>=0; --plesion)	{		for (a=1; a<=tree[plesion][0]; ++a)	{			sp2=tree[plesion][a];			/* ancestral node found */			if (sp2==sp)	{				if (sp<OTUs)	{					for (b=a+1; tree[plesion][b]<htu && b<=tree[plesion][0]; ++b)						tree[plesion][b-1]=tree[plesion][b];					tree[plesion][b-1]=htu;					}				/* different routine needed if clade */				else	{					oldfirst=tree[plesion][1];					for (b=a; tree[plesion][b-1]>htu; --b)	{						tree[plesion][b]=tree[plesion][b-1];						}					tree[plesion][b]=htu;					/* if first species was a clade but now is another clade */					/*   then the old must be replaced */					if (b==1 && oldfirst==tree[plesion][2])	{						sp=tree[plesion][2];						htu=tree[plesion][1];						}					}				/* if the first species was found, then it will be in lower clades 						*/				/* this means that the tree needs to be re-written or this node will never find a home  */				/*   So, swap the that species with the first species in tree[plesion] 					*/				/*     if a clade replaces a clade, htu remains unchanged */				if (a==1 || b==1)					htu=tree[plesion][1];				else					found=1;				a=tree[plesion][0];	/* end search */				}	/* end replacement of taxon within clade by node or new representative species */			}	/* end search of species within a lower node */		}	/* end search of nodes */	}		/************************  Determine Branch Lengths  ************************/for (sp=0; sp<OTUs; ++sp)	{	for (b=0; b<chucks; ++b)	{		for (c=(nodes-1); c>=0; --c)	{			if (forefathers[sp][b]==commonanc[c])	{				bl[sp]=b;				c=0;				b=chucks;				}			}		}	}//for (a=0; a<OTUs; ++a)					bl[a] = obsbl[a];for (a=OTUs; a<(OTUs+nodes); ++a)		bl[a] = 0;/***    Replace Branch lengths from sampled Ancestors to Nodes    ***/ for (sp=0; sp<OTUs; ++sp)	{	if (f1[sp]>0)	{		for (b=0; b<nodes; ++b)	{			if (commonanc[b]==observed[sp])	{				bl[b+OTUs] = bl[sp];				bl[sp] = 0;				}			}		}	}/* read back troufor (clade=(nodes-1); clade>=0; --clade)	{	a=clade;	d=0;	bl[OTUs+clade]=1;	while (d==0)	{		anc=ancestor[a];		for (c=(clade-1); c>=0; --c)	{			if (commonanc[c]==anc)	{				}			}		}		for (c=(clade-1)	}/***   Nodes Subsume the Apomorphies of their Unsampled Immediate Ancestors   ***/ for (clade=nodes-1; clade>=0; --clade)	{//	while (bl[clade+OTUs]>0 && clade>0)	--clade;//	if (clade<0)	break;	htu=commonanc[clade];			/* fixed 2014-01-14	*/	anc=ancestor[htu];				/* fixed 2014-01-14	*/	if (anc>=0)		found=0;		/* fixed 2014-01-14	*/	while (found==0)	{		++bl[clade+OTUs];			/* fixed 2014-01-14	*/		for (c=(clade-1); c>=0 && found==0; --c)	{			if (anc==commonanc[c])	{				found=1;			/* fixed 2014-01-14	*/				c=0;				/* fixed 2014-01-14	*/				}	/* examine common ancestors for ancestor of node	*/			if (commonanc[c]<anc)	c=0;	/* no more hope!  escape	*/			}		anc=ancestor[anc];			/* fixed 2014-01-14	*/		if (anc<0)	found=-1;		/* fixed 2014-01-14	*/		}	/* search through common ancestors to see if tis ancestor is found	*//*	for (a=0; (found==0 && anc>-1); ++a)	{		++bl[clade+OTUs];		for (b=0; b<OTUs; ++b)	{			/* if ancestor is observed, prepare to stop the loop *//*			if (observed[b]==anc)	{				found=1;				b=OTUs;				}			/* once species are older than ancestor, abandon search to speed loop *//*			else if (observed[b]>anc)	b=OTUs;			}		anc=ancestor[anc];		}	*/	}	/* count down all clades	*//* add branch lengths to tree  */for (a=0; a<OTUs; ++a)	tree[OTUs-1][a]=bl[a];for (b=0; b<nodes; ++b)	{	a=OTUs+b;	tree[OTUs][b]=bl[a];	}/* add first and last appearances to tree  */for (a=0; a<OTUs; ++a)	{	tree[OTUs+1][a]=fa[a];	tree[OTUs+2][a]=la[a];	}free_ivector(observed);free_ivector(commonanc);//free_ivector(obsbl);free_ivector(fa);free_ivector(la);free_ivector(bl);free_ivector(extants);free_ivector(ancestor);free_imatrix(forefathers,OTUs,chucks+1);free_ivector(f1);free_ivector(dbas);	free_dvector(tor);free_dvector(tex);free_imatrix(pdmat,otu,otu);free_imatrix(camat,otu,otu);return tree;}/* evolvetreeVenn - Evolves a paleontological tree, with notu taxa sampled over time, output as Venn tree./* Requires:	notu - # of sampled taxa/*				MBL - simulation parameters where	 				MBL[0] (lmbd) - Speciation rate/*					MBL[1] (mu) - Extinction rate/*					MBL[2] (fr) - Preservation rate/*					MBL[3] (vr) - Variance in preservation rate				FOSSILS - (1) fossils sampled, (0) no fossils sampled/*				speciation - (1) bifurcation (0) budding cladogenesis/* Major Rewrite of Sampled Tree Construction 02/2003/* Rewritten to use real numbers from a single array (MBL)				tree[0][0]…tree[clades-1][0] gives TOTAL number of descendants of a node;				tree[0][1…tree[0][0]]…tree[clades-1][1…tree[clades-1][0]] give desendants where					0…OTUs-1 are taxon numbers;				tree[OTUs-1][0…OTUs-1] give branch lengths of sampled taxa;				tree[OTUS][0…clades-1] give branch lengths of unsampled taxa;				tree[OTUs+1][0…OTUs-1] give first appearances of sampled taxa;				tree[OTUs+2][0…OTUs-1] give last appearances of sampled taxa;*******************************************************************************************************/long **evolvetreeVenn(int OTUs, double *MBL, int FOSSILS){long	attempts, base=100000, speciation;int		a, b, c, d, ee, charstandard, ch, latest, mxdv=6, chucks, brats;int		clade, otu, otu2, htu, sampled, initdiv, standingdiv, cumulativediv, stage, newby;int		cl, ef1, dcl;			/* added for Venn routine	*/int		species, anc, change, testnode, plesion, found0, oldfirst;int		reboot;int		sp, sp2, nodes, found;int		mxtaxa, mxstnd;int		*f1, **forefathers, *ancestor;int		*extants, *observed, *commonanc, *bl;int		*fa, *la, *dbas;int		**pdmat, **camat;long	**tree;double	lmbd, mu, fr, vr, vfr, frp;double	speciate, extinct, find;double	*tor, *tex;double	v, x, y, mod;lmbd=MBL[0];mu=MBL[1];fr=MBL[2];vr=MBL[3];if (vr<1)	vr=MBL[3]=1.0f;speciation=MBL[4];v=expectedpropsampled(MBL[1],MBL[2]);v=1/v;mxtaxa=10*v*OTUs;if (mxtaxa>30000)	mxtaxa=30000;/*if (FOSSILS=1)	mxstnd=2*OTUs;	*//*else			mxstnd=3*OTUs;		*/mxstnd=3*OTUs;/* arrays for observed taxa - set to OTUs*/observed=ivector(OTUs);		/* observed (sampled) taxa 					*/fa=ivector(OTUs);			/* first appearance of a taxon				*/la=ivector(OTUs);			/* last appearance of a taxon				*//*obsbl=ivector(OTUs);		/* branch lengths of sampled taxa			*/commonanc=ivector(2*OTUs);	/* ancestors of a taxon						*/dbas=ivector(OTUs);			/* patristic distance from base to taxon	*/bl=ivector(2*OTUs);			/* array for all elements of the tree 		*/extants = ivector(mxstnd+1);	/* array for standing taxa - set to mxstnd*/	/* arrays for sampled and unsampled taxa - set to mxtaxa */ancestor=ivector(mxtaxa);	/* ancestor of each taxon 					*/f1=ivector(mxtaxa);			/* number of descendants for each taxon 	*/tor=dvector(mxtaxa);		/* true origination - this is a real number */tex=dvector(mxtaxa);		/* true extinction - this is a real number 	*/reboot=0;a=b=c=d=ee=anc=0;charstandard = 1; /*charbase/100;*/sp = ch = change = find = 0;clearivector(observed,OTUs,-1);//clearivector(obsbl,OTUs,-1);clearivector(ancestor,mxtaxa,-1);clearivector(extants,mxstnd+1,-1);latest = -1;attempts = initdiv = standingdiv = cumulativediv = stage = extants[0] = sampled = 0;/* use this to calculate how long the species will live */extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);while (extinct<=0)	extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);tex[0]=(log(1-extinct)/log(1-mu));tor[0]=0.0f;		/*added 2014-01-13	*/while (sampled < OTUs)	{	initdiv = standingdiv+1;	for (sp=0; (sp<=standingdiv && cumulativediv<mxtaxa); ++sp)	{	/********************************************/	/*			Does Lineage Speciate?			*/	/********************************************/		if (sp<0 || sp>mxstnd)	{			printf("ERROR 108: %d is the wrong number of species!\n", sp);			exit(0);			}		species = extants[sp];/*		mod=1.0f;	*//*		if (tor[species]>stage)	*//*			mod=(stage+1)-tor[species];	/* mod reflects shortened time for extinction and speciation *//*		/*		v=1-pow((1-mu),mod);	/* this will equal mu if it survives the whole interval *//*		/* if v is still less than extinction rate, then the species dies this interval *//*		if (extinct<v)	{*//*			/* now randomly generate a number to show when it dies *//*			x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);*//*			/* if it existed at the beginning		*//*			if (tor[species]<=stage)	tex[species]+=x;*//*			/* if it originated durign this stage	*/ /*			else						tex[species]+=x*(((double) (stage+1))-tor[species]);*//*			}*//*		/* if it survies, then bump the extinction to the next interval	*//*		else							tex[species]=stage+1;	*/				if (f1[species]<mxdv)	speciate = (((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		else					speciate = 1.0f;				/* do this to shake up random number generator */		if (sp%2==0)			speciate=1-speciate;		v=lmbd;		if (tex[species]<(stage+1) || tor[species]>stage)	{			if (tex[species]<(stage+1) && tor[species]>stage)											mod=tex[species]-tor[species];			else if (tor[species]<stage)	mod=tex[species]-stage;			else if (tex[species]>stage+1)	mod=((double) (stage+1))-tor[species];			v=1-pow((1-lmbd),mod);	/* this will equal lmbd if it survives the whole interval */									/* (1-lmbd) is prob. of not speciating; 										(1-lmbd)^mod = prob of not speciating over mod										1-([1-lmbd]^mod) = prob. of speciating over mod	*/			}	/* end case for taxa present during only part of "stage"	*/		if (speciation==1)	ee=2;		else				ee=1;		if (speciate <= v && (standingdiv<(mxstnd-ee)))		{			brats=1;			/* if bifurcation, then two descendants when ancestor disappears		*/			if (speciation==1)	brats=2;			/* if budding, then allow for multiple descendants at different times 	*/			else	{				if (tor[species]>stage)	v=(stage+1)-tor[species];				else					v=1;				x=Poisson(lmbd, v, 2);				if (v<x)				brats=2;				}			/* go through each descendant */			for (a=0; a<brats; ++a)	{				++standingdiv;				++cumulativediv;				extants[standingdiv] = cumulativediv;				if (cumulativediv > mxtaxa)	{					printf("ERROR Evolve 187 - In replication XXX");					printf(", more than %3d species were generated.  \n",mxtaxa);					sampled=OTUs;					exit(0);						}				if (standingdiv<0 || standingdiv>mxstnd)	{					printf("ERROR 193:  Standing diversity too high at %2d\n",standingdiv);					sampled=OTUs;					exit(0);						}							if (cumulativediv<0 || cumulativediv>=mxtaxa || species<0 || species>=mxtaxa)	{					printf("ERROR 198 - ancestor index out of range at %d and %d\n",species,cumulativediv);					sampled=OTUs;					exit(0);						}				ancestor[cumulativediv] = species;				anc = species;				++f1[anc];						/*******************************************************************************/		/* Ancestors become pseudo-extinct at bifurcation if that is what is happening */		/*******************************************************************************/				if (speciation==0 || (speciation==1 && a==0))	{					y=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					/* if ancestor originated during stage and extends into the next	*/					if (tex[anc]>stage+1 && tor[anc]>stage)						tor[cumulativediv]=tor[anc]+(y*((stage+1)-tor[anc]));					/* if ancestor goes extinct during stage and originated before it	*/					else if (tex[anc]<(stage+1) && tor[anc]<stage)						tor[cumulativediv]=stage+(y*(tex[anc]-stage));					/* if ancestor both originates and goes extinct during stage		*/					else if (tex[anc]<(stage+1) && tor[anc]>stage)						tor[cumulativediv]=tor[anc]+(y*(tex[anc]-tor[anc]));					else						tor[cumulativediv]=y+ ((double) stage);										/* if we are dealing with the first species of a bifurcation, give it ancestral extinction time.	*/					/* 		Ancestor disappears when descendants arise													*/ 					if (speciation==1)	{						tex[cumulativediv]=tex[anc];						tex[anc]=tor[cumulativediv];						}					}				/* second species of a bifurcation */				else if (a==1)	tor[cumulativediv]=tex[anc];								/* establish extinction if the species becomes extinct */				if (speciation==0 || (speciation ==1 && a==1))	{					/* if we are dealing with the second species, then give it its own extinction time but the same origination time */					extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					tex[cumulativediv]=tor[cumulativediv]+(log(1-extinct)/log(1-mu));					}				}			}		if (FOSSILS==0 && standingdiv>=OTUs-1)	sp = initdiv;	/* quit if enough taxa are alive */		}	/****  End Speciation Round ****/ 				if (FOSSILS==1)	{		/********************************************/		/*				 Do Sampling				*/		/*  Separated from Speciation Loop 1/3/97   */		/********************************************/		if (sampled < OTUs)	{			for (sp=0; sp<=standingdiv; ++sp)	{				species = extants[sp];								/* Raw Species Number *//*				find = (((unsigned int) rand())%base)+1;	*//*				if (f1[species]>=3 || cumulativediv>=(3*mxstnd))	find = 0;	*/				find=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				/* do this to shake up the random number generator */				if (sp%2==0)	find=1-find;								/* insert lognormal part here	*/				x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				y=normsinv(x);				vfr=pow(vr,y);				v=fr*vfr;				frp=log(1-(fr*vfr));				/* 2012-01-10: Poisson expectation so that P[0 | 1 stage, fr] = 1=fr	*/											/* keep this here so that we can handle variable sampling				*/				if (tex[species]<(stage+1) || tor[species]>stage)	{					/* if species originates and disappears in this interval 			*/					if (tex[species]<(stage+1) && tor[species]>stage)														mod=tex[species]-tor[species];					/* if species originated earlier but goes extinct in this interval	*/					else if (tex[species]<(stage+1))	mod=tex[species]-stage;					/* if species goes extinct later but originates in this interval	*/					else if (tex[species]>(stage+1))	mod=((double) (stage+1))-tor[species];					v=1-pow(1-(fr*vfr),mod);	/* this will equal fr*vfr if it survives the whole interval */												/*	(1-[fr*vfr]) = prob. of missing over whole interval													(1-[fr*vfr])^mod = prob. of missing over mod.  	*/					}						if (find <= v)	{					newby = 0;					/** First sampled species goes straight into the array **/					if (sampled==0)	{						observed[sampled]=species;						fa[sampled]=la[sampled]=stage;						++sampled;						}					/** Test whether a sampled species had gone unsampled **/					else	{						for (otu = 0; otu < sampled;  ++otu)	{							if (observed[otu] == species)	{								newby = 1;		/* species is not new */								la[otu]=stage;								otu = sampled;								}							}						if (newby == 0 && sampled < OTUs)	{							/* sort species as you go */							a=sampled-1;							while (observed[a]>species && a>=0)	{								observed[a+1]=observed[a];								fa[a+1]=fa[a];								la[a+1]=la[a];								--a;								}							observed[a+1] = species;							fa[a+1]=la[a+1]=stage;							++sampled;							if (sampled<0 || sampled>OTUs)	{								printf("ERROR 189: You somehow sampled %d\n",sampled);								exit(0);								}							if (sampled==OTUs)		sp = standingdiv;							}						}					latest = observed[sampled-1];					}	/* End Tallying of Sampled Horizon	*/				}	/*  End Sampling for Each Horizon	*/			}	/* only do test while we need to sampled taxa */		}	/* only sample if we are including fossils	*/			else {		sampled = standingdiv;		/* if there are no fossils, "present" is when									   OTUs taxa evolve */		if (sampled==OTUs-1)	for (sp=0; sp<OTUs; ++sp)	observed[sp]=extants[sp];		}	if (sampled>=OTUs)	break;	/* don't bother with the rest if done */			/* cull species that went extinct */	for (a=0; a<=standingdiv; ++a)	{		sp=extants[a];		if (tex[sp]<(stage+1))	{			for (b=a+1; b<=standingdiv; ++b)	extants[b-1]=extants[b];			extants[standingdiv]=-1;			--standingdiv;			--a;			}		}		initdiv=standingdiv;				/****** REBOOT ROUTINE ******/	if (standingdiv < 0 || (cumulativediv>=mxtaxa && sampled < OTUs))	{		latest = -1;		/* clear vectors set to maxtaxa */		for (sp=0; sp<cumulativediv; ++sp)	{			ancestor[sp]=tex[sp]=tor[sp]=-1;			f1[sp]=0;		/* altered 2014-01-13	*/			}		/* clear vectors set to OTUs */		for (sp=0; sp<sampled; ++sp)			fa[sp]=la[sp]=observed[sp]=-1;				standingdiv = initdiv = cumulativediv = extants[0] = sampled = 0;		stage = 0;		++attempts;		/* use this to calculate how long the species will live */		extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		tex[0]=(log(1-extinct)/log(1-mu));		tor[0]=0.0f;		/*added 2014-01-13	*//*		if ((attempts%5)==0)	printf ("%2d tries and counting.\n",attempts); */		}				/** Reboot simulation **/	else	{		if (sampled < OTUs)	++stage;		/*  All OTUs species found	*/		else if (FOSSILS==0 && cumulativediv==((2*OTUs)-2))	{			for (sp=0; sp<=standingdiv; ++sp)		observed[sp] = extants[sp];			sampled = OTUs;			reboot=1;			}		/* if species index is out of range, then reboot the whole thing */		}	}mxdv=1+maxiarray(f1,cumulativediv);/* redone 2014-01-13	a=observed[OTUs-1];tree=lmatrix(nodes=(1+ancestor[a]),mxdv+1);for (sp=1; sp<observed[OTUs-1]; ++sp)	tree[ancestor[sp]][0]=1;for (sp=1; sp<observed[OTUs-1]; ++sp)	{	++tree[ancestor[sp]][0];	tree[ancestor[sp]][1]=ancestor[sp];	a=tree[ancestor[sp]][0];	tree[ancestor[sp]][a]=sp;	}	deleteme=ivector(cut=(observed[OTUs-1]-OTUs));ee=c=0;for (a=0; a<observed[OTUs-1]; ++a)	{	for (b=ee; b<(OTUs-1); ++b)	{		if (a==observed[b])	b=OTUs;		else if (a>observed[b] && a<observed[b+1])	{			deleteme[c]=a;			++c;			ee=b;			b=OTUs;			}	/* this species was not sampled			}	/* end search of observed taxa to find match		}for (c=0; c<cut; ++c)	{	for (a=0; a<nodes; ++a)	{		for (b=1; b<=tree[a][0]; ++b)	{			if (deleteme[c]==tree[a][b])	{				tree[a][b]=-1;				--tree[a][0];				b=tree[a][0]+1;				a=nodes;				}	/* delete taxon and decrement diversity				}		}	}/* tree matrix - rows 0...(OTUs-1) rows are for possible nodes	*//*		row OTUs-1 is for species branch lengths				*//*		row OTUs   is for nodal branch lengths					*//*		row OTUs+1 is for species FAs							*//*		row OTUs+2 is for species LAs							*//*		the first cell of rows 0…(OTUs-1) give # branches		*//*			(i.e., 2 for bifurcation w. no sampled ancestor)	*/tree=lmatrix(OTUs+3,OTUs);clearlmatrix(tree,OTUs+3,OTUs,-1);for (a=cumulativediv+1; a<mxtaxa; ++a)	f1[a]=ancestor[a]=0;if (observed[0]==-1)	{	printf("Taxa lost by line 377\a\n");	exit(0);	}/*********************************************************************************//*								Store True Phylogeny							 *//*********************************************************************************//**** LIST ANCESTORS OF EACH OBSERVED SPECIES ****/chucks=0;ancestor[0]=-1;/* find the distance from the base for each species */for (otu=0; otu<OTUs; ++otu)	{	sp=observed[otu];	anc=ancestor[sp];	if (anc>=0)		dbas[otu]=1;	for (a=1; anc>=0; ++a)	{		anc=ancestor[anc];		++dbas[otu];		}	}/* count the maximum number of ancestors */chucks=maxiarray(dbas,otu);/* list all of the ancestors for each species */forefathers=imatrix(OTUs,chucks+1);clearimatrix(forefathers,OTUs,chucks+1,-1);ancestor[0]=-1;for (otu=0; otu<OTUs; ++otu)	{	forefathers[otu][0]=sp=observed[otu];	anc=ancestor[sp];	for (a=1; anc>=0; ++a)	{		forefathers[otu][a]=anc;		anc=ancestor[anc];		}	}/* list the unsampled ancestors of each species *//* also, tally species with sampled descendants */free_ivector(f1);f1=ivector(OTUs);	/* 0: no sampled descendants; 1: 1+ sampled descendants *//* written out 2014-01-13	*/for (otu=0; otu<OTUs; ++otu)	{	/* rewrite this to count down until a common forefather		/* also, check to make sure that taxon is not ancestral; if it is, then make obsbl=0	*/	/* have it work down until it finds a number shared with another taxon;			keep the shortest one		*///	obsbl[otu]=1;	found=0;	for (a=1; a<dbas[otu]; ++a)	{		anc=forefathers[otu][a];		for (b=otu-1; b>=0; --b)	{			if (observed[b]==anc)	{				found=1;				f1[b]=1;				/* end loops 	*/				b=0;				a=dbas[otu];				}			}//		if (found==0)	++obsbl[otu];	/* this gives length to observed ancestor or base of tree	*/		}	}	/* create a matrix of branch distances between taxa *//* this gives distance to common ancestor, so the matrix is asymmetrical */pdmat=imatrix(otu,otu);camat=imatrix(otu,otu);for (otu=OTUs-1; otu>0; --otu)	{	for (otu2=otu-1; otu2>=0; --otu2)	{		for (a=0; a<=dbas[otu]; ++a)	{			sp=forefathers[otu][a];			for (b=0; b<=dbas[otu2]; ++b)	{				sp2=forefathers[otu2][b];				if (sp==sp2)	{					pdmat[otu][otu2]=a+1;					pdmat[otu2][otu]=b+1;					camat[otu][otu2]=camat[otu2][otu]=sp;					/* end loop */					b=dbas[otu2];					a=dbas[otu];					}				/* end loop if forefather[otu][a] cannot match forefather[otu2][any] */				else if (sp>sp2)	b=dbas[otu2];				}			}		}	}/* create a tree *//* keep track of common ancestors of each clade */nodes=found0=0;for (otu=OTUs-1; otu>0; --otu)	{	d=chucks;	for (otu2=otu-1; otu2>=0; --otu2)	{		if (pdmat[otu][otu2]<d)	{			d=pdmat[otu][otu2];			}		}	for (otu2=0; otu2<otu; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			anc=camat[otu][otu2];			found=-1;			for (a=0; a<nodes; ++a)	{				/* existing nodes found */				if (commonanc[a]==camat[otu][otu2])	{					found=0;					/* check to see if the species already is in the nodes */					for (b=1; b<=tree[a][0]; ++b)	{						if (otu2==tree[a][b])		found=1;						}					if (found==0)	{						for (b=1; b<=tree[a][0]; ++b)	{							if (otu==tree[a][b])	found=2;							}						}					/* if neither species already found */					if (found==0)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					/* if older species already found */					else if (found==1)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						}					/* if younger species already found */					else if (found==2)	{						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					a=nodes+1;					otu2=otu;					}				}	/* end search for previously found node */			/* new nodes found */			if (found==-1)	{				commonanc[nodes]=camat[otu][otu2];				tree[nodes][0]=2;				tree[nodes][1]=otu2;				tree[nodes][2]=otu;				++nodes;				if (otu2==0)	found0=1;				otu2=otu;				}	/* new node added */			}		}	}/* make sure that oldest species is included in the tree somewhere **/if (found0==0)	{	otu=0;	d=chucks;	for (otu2=1; otu<OTUs; ++otu2)	if (pdmat[otu][otu2]<d)		d=pdmat[otu][otu2];	for (otu2=1; otu<OTUs; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			tree[nodes][0]=2;			tree[nodes][1]=0;			tree[nodes][2]=otu2;			commonanc[nodes]=camat[0][otu2];			++nodes;			}		}	found0=1;	}	mxdv=2;for (a=0; a<nodes; ++a)	if (tree[a][0]>mxdv)	mxdv=tree[a][0];/*****  Sort Clades by Last Common Ancestor	*****/for (testnode=0; testnode<nodes; ++testnode)	{	d=commonanc[c=testnode];	for (clade=testnode+1; clade<nodes; ++clade)		if (commonanc[clade] <= d) d=commonanc[c=clade];	if (c != testnode)	{		commonanc[c]=commonanc[testnode];		commonanc[testnode]=d;		for (sp=0; sp<=mxdv; ++sp)	{			d=tree[testnode][sp];			tree[testnode][sp]=tree[c][sp];			tree[c][sp]=d;			}		}	}/**** WRITE OUT TREE ****/for (testnode=nodes-1; testnode>0; --testnode)	{	found=0;	sp=tree[testnode][1];	htu=testnode+OTUs;	for (plesion=testnode-1; found==0 && plesion>=0; --plesion)	{		for (a=1; a<=tree[plesion][0]; ++a)	{			sp2=tree[plesion][a];			/* ancestral node found */			if (sp2==sp)	{				if (sp<OTUs)	{					for (b=a+1; tree[plesion][b]<htu && b<=tree[plesion][0]; ++b)						tree[plesion][b-1]=tree[plesion][b];					tree[plesion][b-1]=htu;					}				/* different routine needed if clade */				else	{					oldfirst=tree[plesion][1];					for (b=a; tree[plesion][b-1]>htu; --b)	{						tree[plesion][b]=tree[plesion][b-1];						}					tree[plesion][b]=htu;					/* if first species was a clade but now is another clade */					/*   then the old must be replaced */					if (b==1 && oldfirst==tree[plesion][2])	{						sp=tree[plesion][2];						htu=tree[plesion][1];						}					}				/* if the first species was found, then it will be in lower clades 						*/				/* this means that the tree needs to be re-written or this node will never find a home  */				/*   So, swap the that species with the first species in tree[plesion] 					*/				/*     if a clade replaces a clade, htu remains unchanged */				if (a==1 || b==1)					htu=tree[plesion][1];				else					found=1;				a=tree[plesion][0];	/* end search */				}	/* end replacement of taxon within clade by node or new representative species */			}	/* end search of species within a lower node */		}	/* end search of nodes */	}		/************************  Determine Branch Lengths  ************************/for (sp=0; sp<OTUs; ++sp)	{	for (b=0; b<chucks; ++b)	{		for (c=(nodes-1); c>=0; --c)	{			if (forefathers[sp][b]==commonanc[c])	{				bl[sp]=b;				c=0;				b=chucks;				}			}		}	}//for (a=0; a<OTUs; ++a)					bl[a] = obsbl[a];for (a=OTUs; a<(OTUs+nodes); ++a)		bl[a] = 0;/***    Replace Branch lengths from sampled Ancestors to Nodes    ***/ for (sp=0; sp<OTUs; ++sp)	{	if (f1[sp]>0)	{		for (b=0; b<nodes; ++b)	{			if (commonanc[b]==observed[sp])	{				bl[b+OTUs] = bl[sp];				bl[sp] = 0;				}			}		}	}/* read back troufor (clade=(nodes-1); clade>=0; --clade)	{	a=clade;	d=0;	bl[OTUs+clade]=1;	while (d==0)	{		anc=ancestor[a];		for (c=(clade-1); c>=0; --c)	{			if (commonanc[c]==anc)	{				}			}		}		for (c=(clade-1)	}/***   Nodes Subsume the Apomorphies of their Unsampled Immediate Ancestors   ***/ for (clade=nodes-1; clade>=0; --clade)	{//	while (bl[clade+OTUs]>0 && clade>0)	--clade;//	if (clade<0)	break;	htu=commonanc[clade];			/* fixed 2014-01-14	*/	anc=ancestor[htu];				/* fixed 2014-01-14	*/	if (anc>=0)		found=0;		/* fixed 2014-01-14	*/	while (found==0)	{		++bl[clade+OTUs];			/* fixed 2014-01-14	*/		for (c=(clade-1); c>=0 && found==0; --c)	{			if (anc==commonanc[c])	{				found=1;			/* fixed 2014-01-14	*/				c=0;				/* fixed 2014-01-14	*/				}	/* examine common ancestors for ancestor of node	*/			if (commonanc[c]<anc)	c=0;	/* no more hope!  escape	*/			}		anc=ancestor[anc];			/* fixed 2014-01-14	*/		if (anc<0)	found=-1;		/* fixed 2014-01-14	*/		}	/* search through common ancestors to see if tis ancestor is found	*//*	for (a=0; (found==0 && anc>-1); ++a)	{		++bl[clade+OTUs];		for (b=0; b<OTUs; ++b)	{			/* if ancestor is observed, prepare to stop the loop *//*			if (observed[b]==anc)	{				found=1;				b=OTUs;				}			/* once species are older than ancestor, abandon search to speed loop *//*			else if (observed[b]>anc)	b=OTUs;			}		anc=ancestor[anc];		}	*/	}	/* count down all clades	*//* add branch lengths to tree  */for (a=0; a<OTUs; ++a)	tree[OTUs-1][a]=bl[a];for (b=0; b<nodes; ++b)	{	a=OTUs+b;	tree[OTUs][b]=bl[a];	}/* add first and last appearances to tree  */for (a=0; a<OTUs; ++a)	{	tree[OTUs+1][a]=fa[a];	tree[OTUs+2][a]=la[a];	}/* convert tree to Venn tree	*/for (cl=nodes-1; cl>=0; --cl)	{	for (ef1=1; ef1<=tree[cl][0]; ++ef1)	{		sp=tree[cl][ef1];		/* tally total diversity and cumulative membership */		if (sp>=OTUs)	{			dcl=sp-OTUs;			b=tree[dcl][0]-1;			for (a=tree[cl][0]; a>ef1; --a)			tree[cl][a+b]=tree[cl][a];			for (a=ef1; a<ef1+tree[dcl][0]; ++a)	tree[cl][a]=tree[dcl][1+a-ef1];			tree[cl][0]=tree[cl][0]+tree[dcl][0]-1;			ef1=ef1+tree[dcl][0]-1;			}		}	for (ef1=tree[cl][0]+1; ef1<=OTUs; ++ef1)	tree[cl][ef1]=-1;	}free_ivector(observed);free_ivector(commonanc);//free_ivector(obsbl);free_ivector(fa);free_ivector(la);free_ivector(bl);free_ivector(extants);free_ivector(ancestor);free_imatrix(forefathers,OTUs,chucks+1);free_ivector(f1);free_ivector(dbas);	free_dvector(tor);free_dvector(tex);free_imatrix(pdmat,otu,otu);free_imatrix(camat,otu,otu);return tree;}/* evolveunsampledbranches - Evolves a paleontological tree, with notu taxa sampled over time/* Requires:	notu - # of sampled taxa/*				MBL - simulation parameters where	 				MBL[0] (lmbd) - Speciation rate/*					MBL[1] (mu) - Extinction rate/*					MBL[2] (fr) - Preservation rate/*					MBL[3] (vr) - Variance in preservation rate				FOSSILS - (1) fossils sampled, (0) no fossils sampled/*				speciation - (1) bifurcation (0) budding cladogenesis/* Major Rewrite of Sampled Tree Construction 02/2003/* Rewritten to use real numbers from a single array (MBL)******************************************************************************************************/double **evolveunsampledbranches(int OTUs, double *MBL, int FOSSILS){long	attempts, base=100000, speciation;int		a, b, c, d, ee, charstandard, ch, latest, mxdv=6, chucks, brats;int		clade, otu, otu2, htu, sampled, initdiv, standingdiv, cumulativediv, stage, newby;int		species, anc, change, testnode, plesion, found0, oldfirst;int		reboot;int		sp, sp2, nodes, found;int		mxtaxa, mxstnd;int		*f1, **forefathers, *ancestor;int		*extants, *observed, *obsbl, *commonanc, *bl;int		*fa, *la, *dbas;int		**pdmat, **camat;long	**tree;double	lmbd, mu, fr, vr;double	speciate, extinct, find;double	*tor, *tex, *ff, *lf, **nddr;double	v, x, y, mod;lmbd=MBL[0];mu=MBL[1];fr=MBL[2];vr=MBL[3];if (vr<1)	vr=MBL[3]=1.0f;speciation=MBL[4];v=expectedpropsampled(MBL[1],MBL[2]);v=1/v;mxtaxa=10*v*OTUs;/*if (FOSSILS=1)	mxstnd=2*OTUs;	*//*else			mxstnd=3*OTUs;		*/mxstnd=3*OTUs;/* arrays for observed taxa - set to OTUs*/observed=ivector(OTUs);		/* observed (sampled) taxa 					*/fa=ivector(OTUs);			/* first appearance of a taxon				*/la=ivector(OTUs);			/* last appearance of a taxon				*/ff=dvector(OTUs);			/* first appearance of a taxon (real)		*/lf=dvector(OTUs);			/* last appearance of a taxon (real)		*/obsbl=ivector(OTUs);		/* branch lengths of sampled taxa			*/commonanc=ivector(2*OTUs);	/* ancestors of a taxon						*/dbas=ivector(OTUs);			/* patristic distance from base to taxon	*/bl=ivector(2*OTUs);			/* array for all elements of the tree 		*/extants = ivector(mxstnd+1);	/* array for standing taxa - set to mxstnd*/	/* arrays for sampled and unsampled taxa - set to mxtaxa */ancestor=ivector(mxtaxa);	/* ancestor of each taxon 					*/f1=ivector(mxtaxa);			/* number of descendants for each taxon 	*/tor=dvector(mxtaxa);		/* true origination - this is a real number */tex=dvector(mxtaxa);		/* true extinction - this is a real number 	*/reboot=0;a=b=c=d=ee=anc=0;charstandard = 1; /*charbase/100;*/sp = ch = change = find = 0;clearivector(observed,OTUs,-1);clearivector(obsbl,OTUs,-1);clearivector(ancestor,mxtaxa,-1);clearivector(extants,mxstnd+1,-1);latest = -1;attempts = initdiv = standingdiv = cumulativediv = stage = extants[0] = sampled = 0;/* use this to calculate how long the species will live */extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);tex[0]=(log(1-extinct)/log(1-mu));tor[0]=0.0f;		/*added 2014-01-13	*/while (sampled < OTUs)	{	initdiv = standingdiv+1;	for (sp=0; (sp<=standingdiv && cumulativediv<mxtaxa); ++sp)	{	/********************************************/	/*			Does Lineage Speciate?			*/	/********************************************/		if (sp<0 || sp>mxstnd)	{			printf("ERROR 108: %d is the wrong number of species!\n", sp);			exit(0);			}		species = extants[sp];/*		mod=1.0f;	*//*		if (tor[species]>stage)	*//*			mod=(stage+1)-tor[species];	/* mod reflects shortened time for extinction and speciation *//*		/*		v=1-pow((1-mu),mod);	/* this will equal mu if it survives the whole interval *//*		/* if v is still less than extinction rate, then the species dies this interval *//*		if (extinct<v)	{*//*			/* now randomly generate a number to show when it dies *//*			x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);*//*			/* if it existed at the beginning		*//*			if (tor[species]<=stage)	tex[species]+=x;*//*			/* if it originated durign this stage	*/ /*			else						tex[species]+=x*(((double) (stage+1))-tor[species]);*//*			}*//*		/* if it survies, then bump the extinction to the next interval	*//*		else							tex[species]=stage+1;	*/				if (f1[species]<mxdv)	speciate = (((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		else					speciate = 1.0f;				/* do this to shake up random number generator */		if (sp%2==0)			speciate=1-speciate;		v=lmbd;		if (tex[species]<(stage+1) || tor[species]>stage)	{			if (tex[species]<(stage+1) && tor[species]>stage)											mod=tex[species]-tor[species];			else if (tor[species]<stage)	mod=tex[species]-stage;			else if (tex[species]>stage+1)	mod=((double) (stage+1))-tor[species];			v=1-pow((1-lmbd),mod);	/* this will equal lmbd if it survives the whole interval */			}				if (speciation==1)	ee=2;		else				ee=1;		if (speciate <= v && (standingdiv<(mxstnd-ee)))		{			brats=1;			/* if bifurcation, then two descendants when ancestor disappears		*/			if (speciation==1)	brats=2;			/* if budding, then allow for multiple descendants at different times 	*/			else	{				if (tor[species]>stage)	v=(stage+1)-tor[species];				else					v=1;				x=Poisson(lmbd, v, 2);				if (v<x)				brats=2;				}			/* go through each descendant */			for (a=0; a<brats; ++a)	{				++standingdiv;				++cumulativediv;				extants[standingdiv] = cumulativediv;				if (cumulativediv > mxtaxa)	{					printf("ERROR Evolve 169 - In replication XXX");					printf(", more than %3d species were generated.  \n",mxtaxa);					sampled=OTUs;					exit(0);						}				if (standingdiv<0 || standingdiv>mxstnd)	{					printf("ERROR 175:  Standing diversity too high at %2d\n",standingdiv);					sampled=OTUs;					exit(0);						}							if (cumulativediv<0 || cumulativediv>=mxtaxa || species<0 || species>=mxtaxa)	{					printf("ERROR 180 - ancestor index out of range at %d and %d\n",species,cumulativediv);					sampled=OTUs;					exit(0);						}				ancestor[cumulativediv] = species;				anc = species;				++f1[anc];						/*******************************************************************************/		/* Ancestors become pseudo-extinct at bifurcation if that is what is happening */		/*******************************************************************************/				if (speciation==0 || (speciation==1 && a==0))	{					y=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					/* if ancestor originated during stage and extends into the next	*/					if (tex[anc]>stage+1 && tor[anc]>stage)						tor[cumulativediv]=tor[anc]+(y*((stage+1)-tor[anc]));					/* if ancestor goes extinct during stage and originated before it	*/					else if (tex[anc]<(stage+1) && tor[anc]<stage)						tor[cumulativediv]=stage+(y*(tex[anc]-stage));					/* if ancestor both originates and goes extinct during stage		*/					else if (tex[anc]<(stage+1) && tor[anc]>stage)						tor[cumulativediv]=tor[anc]+(y*(tex[anc]-tor[anc]));					else						tor[cumulativediv]=y+ ((double) stage);										/* if we are dealing with the first species of a bifurcation, give it ancestral extinction time.	*/					/* 		Ancestor disappears when descendants arise													*/ 					if (speciation==1)	{						tex[cumulativediv]=tex[anc];						tex[anc]=tor[cumulativediv];						}					}				/* second species of a bifurcation */				else if (a==1)	tor[cumulativediv]=tex[anc];								/* establish extinction if the species becomes extinct */				if (speciation==0 || (speciation ==1 && a==1))	{					/* if we are dealing with the second species, then give it its own extinction time but the same origination time */					extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					tex[cumulativediv]=tor[cumulativediv]+(log(1-extinct)/log(1-mu));					}				}			}		if (FOSSILS==0 && standingdiv>=OTUs-1)	sp = initdiv;	/* quit if enough taxa are alive */		}	/****  End Speciation Round ****/ 				if (FOSSILS==1)	{		/********************************************/		/*				 Do Sampling				*/		/*  Separated from Speciation Loop 1/3/97   */		/********************************************/		if (sampled < OTUs)	{			for (sp=0; sp<=standingdiv; ++sp)	{				species = extants[sp];								/* Raw Species Number *//*				find = (((unsigned int) rand())%base)+1;	*//*				if (f1[species]>=3 || cumulativediv>=(3*mxstnd))	find = 0;	*/				find=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				/* do this to shake up the random number generator */				if (sp%2==0)	find=1-find;								v=fr;				if (tex[species]<(stage+1) || tor[species]>stage)	{					/* if species originates and disappears in this interval 			*/					if (tex[species]<(stage+1) && tor[species]>stage)														mod=tex[species]-tor[species];					/* if species originated earlier but goes extinct in this interval	*/					else if (tex[species]<(stage+1))	mod=tex[species]-stage;					/* if species goes extinct later but originates in this interval	*/					else if (tex[species]>(stage+1))	mod=((double) (stage+1))-tor[species];//					v=1-pow(1-(fr*vfr),mod);					v=1-pow((1-fr),mod);	/* this will equal lmbd if it survives the whole interval */					}						if (find <= v)	{					newby = 0;					/** First sampled species goes straight into the array **/					if (sampled==0)	{						observed[sampled]=species;						fa[sampled]=la[sampled]=stage;						++sampled;						ff[sampled]=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);						lf[sampled]=ff[sampled]+=stage;						}					/** Test whether a sampled species had gone unsampled **/					else	{						for (otu = 0; otu < sampled;  ++otu)	{							if (observed[otu] == species)	{								newby = 1;		/* species is not new */								la[otu]=stage;								otu = sampled;								lf[sampled]=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);								lf[sampled]+=stage;								}							}						if (newby == 0 && sampled < OTUs)	{							/* sort species as you go */							a=sampled-1;							while (observed[a]>species && a>=0)	{								observed[a+1]=observed[a];								fa[a+1]=fa[a];								la[a+1]=la[a];								ff[a+1]=ff[a];								lf[a+1]=lf[a];								--a;								}							observed[a+1] = species;							fa[a+1]=la[a+1]=stage;							ff[sampled]=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);							lf[sampled]=ff[sampled]+=stage;							++sampled;							if (sampled<0 || sampled>OTUs)	{								printf("ERROR 1566: You somehow sampled %d\n",sampled);								exit(0);								}							if (sampled==OTUs)		sp = standingdiv;							}						}					latest = observed[sampled-1];					}	/* End Tallying of Sampled Horizon	*/				}	/*  End Sampling for Each Horizon	*/			}	/* only do test while we need to sampled taxa */		}	/* only sample if we are including fossils	*/			else {		sampled = standingdiv;		/* if there are no fossils, "present" is when									   OTUs taxa evolve */		if (sampled==OTUs-1)	for (sp=0; sp<OTUs; ++sp)	observed[sp]=extants[sp];		}	if (sampled>=OTUs)	break;	/* don't bother with the rest if done */			/* cull species that went extinct */	for (a=0; a<=standingdiv; ++a)	{		sp=extants[a];		if (tex[sp]<(stage+1))	{			for (b=a+1; b<=standingdiv; ++b)	extants[b-1]=extants[b];			extants[standingdiv]=-1;			--standingdiv;			--a;			}		}		initdiv=standingdiv;				/****** REBOOT ROUTINE ******/	if (standingdiv < 0 || (cumulativediv>=mxtaxa && sampled < OTUs))	{		latest = -1;		/* clear vectors set to maxtaxa */		for (sp=0; sp<cumulativediv; ++sp)			ancestor[sp]=tex[sp]=tor[sp]=f1[sp]=-1;		/* clear vectors set to OTUs */		for (sp=0; sp<sampled; ++sp)			ff[sp]=lf[sp]=fa[sp]=la[sp]=observed[sp]=-1;				standingdiv = initdiv = cumulativediv = extants[0] = sampled = 0;		stage = 0;		++attempts;		/* use this to calculate how long the species will live */		extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		tex[0]=(log(1-extinct)/log(1-mu));		tor[0]=0.0f;		/*added 2014-01-13	*//*		if ((attempts%5)==0)	printf ("%2d tries and counting.\n",attempts); */		}				/** Reboot simulation **/	else	{		if (sampled < OTUs)	++stage;		/*  All OTUs species found	*/		else if (FOSSILS==0 && cumulativediv==((2*OTUs)-2))	{			for (sp=0; sp<=standingdiv; ++sp)		observed[sp] = extants[sp];			sampled = OTUs;			reboot=1;			}		/* if species index is out of range, then reboot the whole thing */		}	}mxdv=1+maxiarray(f1,cumulativediv);/* tree matrix - rows 0...(OTUs-1) rows are for possible nodes	*//*		row OTUs-1 is for species branch lengths				*//*		row OTUs   is for nodal branch lengths					*//*		row OTUs+1 is for species FAs							*//*		row OTUs+2 is for species LAs							*//*		the first cell of rows 0…(OTUs-1) give # branches		*//*			(i.e., 2 for bifurcation w. no sampled ancestor)	*/tree=lmatrix(OTUs+3,OTUs);clearlmatrix(tree,OTUs+3,OTUs,-1);for (a=cumulativediv+1; a<mxtaxa; ++a)	f1[a]=ancestor[a]=0;if (observed[0]==-1)	{	printf("Taxa lost by line 365\a\n");	exit(0);	}/*********************************************************************************//*								Store True Phylogeny							 *//*********************************************************************************//**** LIST ANCESTORS OF EACH OBSERVED SPECIES ****/chucks=0;ancestor[0]=-1;/* find the distance from the base for each species */for (otu=0; otu<OTUs; ++otu)	{	sp=observed[otu];	anc=ancestor[sp];	if (anc>=0)		dbas[otu]=1;	for (a=1; anc>=0; ++a)	{		anc=ancestor[anc];		++dbas[otu];		}	}/* count the maximum number of ancestors */chucks=maxiarray(dbas,otu);/* list all of the ancestors for each species */forefathers=imatrix(OTUs,chucks+1);clearimatrix(forefathers,OTUs,chucks+1,-1);ancestor[0]=-1;for (otu=0; otu<OTUs; ++otu)	{	forefathers[otu][0]=sp=observed[otu];	anc=ancestor[sp];	for (a=1; anc>=0; ++a)	{		forefathers[otu][a]=anc;		anc=ancestor[anc];		}	}/* list the unsampled ancestors of each species *//* also, tally species with sampled descendants */free_ivector(f1);f1=ivector(OTUs);	/* 0: no sampled descendants; 1: 1+ sampled descendants */for (otu=0; otu<OTUs; ++otu)	{	obsbl[otu]=1;	found=0;	for (a=1; a<dbas[otu]; ++a)	{		anc=forefathers[otu][a];		for (b=otu-1; b>=0; --b)	{			if (observed[b]==anc)	{				found=1;				f1[b]=1;				/* end loops */				b=0;				a=dbas[otu];				}			}		if (found==0)	++obsbl[otu];		}	}/* create a matrix of branch distances between taxa *//* this gives distance to common ancestor, so the matrix is asymmetrical */pdmat=imatrix(otu,otu);camat=imatrix(otu,otu);for (otu=OTUs-1; otu>0; --otu)	{	for (otu2=otu-1; otu2>=0; --otu2)	{		for (a=0; a<=dbas[otu]; ++a)	{			sp=forefathers[otu][a];			for (b=0; b<=dbas[otu2]; ++b)	{				sp2=forefathers[otu2][b];				if (sp==sp2)	{					pdmat[otu][otu2]=a+1;					pdmat[otu2][otu]=b+1;					camat[otu][otu2]=camat[otu2][otu]=sp;					/* end loop */					b=dbas[otu2];					a=dbas[otu];					}				/* end loop if forefather[otu][a] cannot match forefather[otu2][any] */				else if (sp>sp2)	b=dbas[otu2];				}			}		}	}/* create a tree *//* keep track of common ancestors of each clade */nodes=found0=0;for (otu=OTUs-1; otu>0; --otu)	{	d=chucks;	for (otu2=otu-1; otu2>=0; --otu2)	{		if (pdmat[otu][otu2]<d)	{			d=pdmat[otu][otu2];			}		}	for (otu2=0; otu2<otu; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			anc=camat[otu][otu2];			found=-1;			for (a=0; a<nodes; ++a)	{				/* existing nodes found */				if (commonanc[a]==camat[otu][otu2])	{					found=0;					/* check to see if the species already is in the nodes */					for (b=1; b<=tree[a][0]; ++b)	{						if (otu2==tree[a][b])		found=1;						}					if (found==0)	{						for (b=1; b<=tree[a][0]; ++b)	{							if (otu==tree[a][b])	found=2;							}						}					/* if neither species already found */					if (found==0)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					/* if older species already found */					else if (found==1)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						}					/* if younger species already found */					else if (found==2)	{						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					a=nodes+1;					otu2=otu;					}				}	/* end search for previously found node */			/* new nodes found */			if (found==-1)	{				commonanc[nodes]=camat[otu][otu2];				tree[nodes][0]=2;				tree[nodes][1]=otu2;				tree[nodes][2]=otu;				++nodes;				if (otu2==0)	found0=1;				otu2=otu;				}	/* new node added */			}		}	}/* make sure that oldest species is included in the tree somewhere **/if (found0==0)	{	otu=0;	d=chucks;	for (otu2=1; otu<OTUs; ++otu2)	if (pdmat[otu][otu2]<d)		d=pdmat[otu][otu2];	for (otu2=1; otu<OTUs; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			tree[nodes][0]=2;			tree[nodes][1]=0;			tree[nodes][2]=otu2;			commonanc[nodes]=camat[0][otu2];			++nodes;			}		}	found0=1;	}	mxdv=2;for (a=0; a<nodes; ++a)	if (tree[a][0]>mxdv)	mxdv=tree[a][0];/*****  Sort Clades by Last Common Ancestor	*****/for (testnode=0; testnode<nodes; ++testnode)	{	d=commonanc[c=testnode];	for (clade=testnode+1; clade<nodes; ++clade)		if (commonanc[clade] <= d) d=commonanc[c=clade];	if (c != testnode)	{		commonanc[c]=commonanc[testnode];		commonanc[testnode]=d;		for (sp=0; sp<=mxdv; ++sp)	{			d=tree[testnode][sp];			tree[testnode][sp]=tree[c][sp];			tree[c][sp]=d;			}		}	}/**** WRITE OUT TREE ****/for (testnode=nodes-1; testnode>0; --testnode)	{	found=0;	sp=tree[testnode][1];	htu=testnode+OTUs;	for (plesion=testnode-1; found==0 && plesion>=0; --plesion)	{		for (a=1; a<=tree[plesion][0]; ++a)	{			sp2=tree[plesion][a];			/* ancestral node found */			if (sp2==sp)	{				if (sp<OTUs)	{					for (b=a+1; tree[plesion][b]<htu && b<=tree[plesion][0]; ++b)						tree[plesion][b-1]=tree[plesion][b];					tree[plesion][b-1]=htu;					}				/* different routine needed if clade */				else	{					oldfirst=tree[plesion][1];					for (b=a; tree[plesion][b-1]>htu; --b)	{						tree[plesion][b]=tree[plesion][b-1];						}					tree[plesion][b]=htu;					/* if first species was a clade but now is another clade */					/*   then the old must be replaced */					if (b==1 && oldfirst==tree[plesion][2])	{						sp=tree[plesion][2];						htu=tree[plesion][1];						}					}				/* if the first species was found, then it will be in lower clades 						*/				/* this means that the tree needs to be re-written or this node will never find a home  */				/*   So, swap the that species with the first species in tree[plesion] 					*/				/*     if a clade replaces a clade, htu remains unchanged */				if (a==1 || b==1)					htu=tree[plesion][1];				else					found=1;				a=tree[plesion][0];	/* end search */				}	/* end replacement of taxon within clade by node or new representative species */			}	/* end search of species within a lower node */		}	/* end search of nodes */	}		/************************  Determine Branch Lengths  ************************/for (a=0; a<OTUs; ++a)					bl[a] = obsbl[a];for (a=OTUs; a<(OTUs+nodes); ++a)		bl[a] = 0;/***    Replace Branch lengths from sampled Ancestors to Nodes    ***/ for (sp=0; sp<OTUs; ++sp)	{	if (f1[sp]>0)	{		for (b=0; b<nodes; ++b)	{			if (commonanc[b]==observed[sp])	{				bl[b+OTUs] = bl[sp];				bl[sp] = 0;				}			}		}	}nddr=dmatrix(OTUs,2);/***   Nodes Subsume the Apomorphies of their Unsampled Immediate Ancestors   ***/ for (clade=nodes-1; clade>=0; --clade)	{	while (bl[clade+OTUs]>0 && clade>0)	--clade;	if (clade<0)	break;	found=0;	anc=commonanc[clade];	nddr[clade][1]=lf[anc];	for (a=0; (found==0 && anc>-1); ++a)	{		++bl[clade+OTUs];		for (b=0; b<OTUs; ++b)	{			/* if ancestor is observed, prepare to stop the loop */			if (observed[b]==anc)	{				found=1;				b=OTUs;				}			/* once species are older than ancestor, abandon search to speed loop */			else if (observed[b]>anc)	b=OTUs;			}		anc=ancestor[anc];		nddr[clade][0]=ff[anc];		}	}/* add branch lengths to tree  */for (a=0; a<OTUs; ++a)	tree[OTUs-1][a]=bl[a];for (b=0; b<nodes; ++b)	{	a=OTUs+b;	tree[OTUs][b]=bl[a];	}for (a=0; a<OTUs; ++a)	{	tree[OTUs+1][a]=fa[a];	tree[OTUs+2][a]=la[a];	}free_ivector(observed);free_ivector(commonanc);free_ivector(obsbl);free_ivector(fa);free_ivector(la);free_ivector(bl);free_ivector(extants);free_ivector(ancestor);free_imatrix(forefathers,OTUs,chucks+1);free_ivector(f1);free_ivector(dbas);	free_dvector(tor);free_dvector(tex);free_imatrix(pdmat,otu,otu);free_imatrix(camat,otu,otu);free_lmatrix(tree,otu+1,otu);return nddr;}/* Returns a matrix for OTUs taxa with nchars characters.  Gaps and missing are kept in place *//* Requires:   tree - a VennTree where:   		tree[0][0]…tree[nodes][0] give the CUMULATIVE descendants of each node;   		tree[0][1…tree[0][0]]…tree[nodes][1…tree[nodes][0]] give the OTUS that (immediately or ultimately) evolved within this node	notu - number of taxa;	nodes - number of clades;		ADDED 2011-02-03!!!!!!	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	TTLSTP - the number of changes for the matrix;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/long **evolvematrix(long **tree, int notu, int nodes, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int ttlstp, int UNKNOWN, int INAP){int		a, b, c, d, br, ch, sc, ev, flip, sp, sp2;int		st, u, clse, best;int		avnodes, used, deltas, mxdel, ttlbr;int		*available, *branches, *steps, *trpd, *mpd, *der, *aptaxa;int		**taxachange;/*, **descnodes;	/* for debugging */long	**invmatrix;/* find the number of nodes and their diversities 	nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}										/* 2011-02-03: somehow, someway, I need a safeguard against fully bifurcating trees.... *//*nodes=cladecountbytaxa(tree,notu);			/* number of clades in tree									*/mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character 				*/mpd=ivector(nodes+notu);					/* morphologic changes along each branch 					*/trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */steps=ivector(nchars);						/* number of times each character changes 					*/der=ivector(nchars);						/* number of taxa with derived condition for each character */trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[nodes][sp];		/* array tree[notu-1] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[nodes+1][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	}	if (ttlbr<mxdel)	mxdel=ttlbr;/*if (ttltx<mxdel)	mxdel=ttltx;	/* 2014-03-21: we allow only as many changes as there are taxa that have changes	*//* allocate memory for arrays containing branches needing changes */available=ivector(ttlbr);branches=ivector(ttlbr);taxachange=imatrix(nchars, mxdel);	/* gives taxa that change for character */invmatrix=lmatrix(nchars, notu);aptaxa=applicabletaxa(matrix, nchars, notu, INAP);/* BEGIN HERE 5/18/01 describe each clade in terms of all species within it *//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********/	/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */avnodes=b=0;for (a=1; a<nodes; ++a)	{	avnodes=avnodes+trpd[a+notu];	for (c=0; c<trpd[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		available[b]=a;		++b;		}	}/* clear matrix */for (ch=0; ch<nchars; ++ch)	{	for (a=0; a<notu; ++a)	{		if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{			matrix[a][ch]=0;			}		invmatrix[ch][a]=matrix[a][ch];	/* for debugging */		}	}deltas=0;/* Step 1: Make sure each state is derived for each character *//*derive_each_char(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, aptaxa, mpd, trpd, notu, nchars, maxstp, mxdel, UNKNOWN, INAP, tree, branches, available, nodes, ttlbr);	*/for (ch=0; (ch<nchars && deltas<ttlstp); ++ch)	{	while (maxch[ch]==0 && ch<nchars)	++ch;	if (ch>=nchars)			break;	steps[ch]=st=0;	clearivector(taxachange[ch],mxdel,-1);	ev=0;			/* make sure that inapplicable characters have at least one taxon that can be changed */	if (aptaxa[ch]<notu)	{		/* count unknowns - these will be put back in later */		u=0;		for (a=0; a<notu; ++a)	if (matrix[a][ch]==UNKNOWN)	++u;		/* now find a node that has similar diversity */		clse=RAND_MAX;				/* start from the bottom if most taxa are scored */		if (aptaxa[ch]>(notu/2))	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==(notu-aptaxa[ch]))	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs((notu-aptaxa[ch])-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}		/* start from the top otherwise */		else	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==aptaxa[ch])	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs(aptaxa[ch]-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}				for (sp=0; sp<notu; ++sp)	{			if (aptaxa[ch]>(notu/2))	matrix[sp][ch]=0;			else						matrix[sp][ch]=INAP;			}		for (a=1; a<tree[best][0]; ++a)	{			sp=tree[best][a];			matrix[sp][a]=0;			}		}	/* end initial creation of inapplicable character */		/* make autapomorphic characters change on one species only */	/* invariants do not change at all */	for (ch=ch; maxch[ch]<=1; ++ch)	{		/* skip invariants and make autapomorphies autapomorphic */		if	(maxch[ch]==1)	{			c=0;			/* we will sample only from otus here - so do not include clades in branches array! */			/* this part rewritten with Cubs winning 7-0 against the Marlins in Game 4 */			for (sp=0; sp<notu; ++sp)				if ((matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP) && trpd[sp]>0)	++c;			if (c>0)	{				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || (trpd[sp]==0 || sp>=notu))					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=1;				taxachange[ch][0]=sp;				}			/* if only cells belong to species with 0 length branches */			if (c==0)	{				/* flip-flop an unknown apomorphic species with a known plesiomorphic one - give plesiomorphic species a ? and the other a 1 */				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || sp2>=notu)					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);								sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while (trpd[sp2]==0 || sp2>=notu)					sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp2][ch];				invmatrix[ch][sp2]=matrix[sp2][ch]=1;				taxachange[ch][0]=sp2;				}	/* end routine if all scored species were unknown */			ev=1;			++deltas;			++steps[ch];			++mpd[ch];			}		}	/* this should leave us with a character that needs to be changed OR out of characters */	if (ch>=nchars)	break;			used=0;	/* this tells how many branches are discarded; used > steps IF there are absents */	/* branch length is taken into account by trpd */	equalivector(branches,available,ttlbr);	/* Binary && unordered multistate is Easy */	/* for normal character, have it change until all X states are realized */	if (nstates[ch]==2 || ctype[ch]==1)	{		/* changed 10/14/2003 so that non-apomorphic characters	diagnose 2+ species */		for (st=0; (st<nstates[ch]-1 || der[ch]<=1); st=st)	{			/* There are ttlbr-used branches that could change */			ev=0;				/* fixed 2014-02-26	*/			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			/* have binary characters change on branches - if they are not autapomorphic, then they need to diagnose multiple species THIS WAS REMOVED 10/14/2003			else				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (avnodes-used));*/			sp = branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				ev=1;				if (nstates[ch]==2)	invmatrix[ch][sp]=matrix[sp][ch]=1;				else					invmatrix[ch][sp]=matrix[sp][ch]=st+1;				++der[ch];				/* add one to the number of species showing derived condition(s) */				}			else if (sp>notu)	{				/* use st+1 instead of nstates[ch] here - we want only 0…st+1 not 0…nstates    */				/*		(remember, st has not yet been incremented, so we need st+1) 		   */				/* This section modified 10/14/2003 to make sure characters are not apomorphic */				/* if multistate, then we need at least two iterations */				if (nstates[ch]>2)	{					/* if we have not yet derived all of the states, do it this way 			*/					/* if deriving first state (i.e., st=0), then it is the same as binary		*/					if (st<nstates[ch] && st==0)						evolvebinaryinclade(tree[sp-notu],matrix,ch);					/* if deriving subsequent states, then used change unmodified species to st+1 		*/					else if (st<(nstates[ch]-1) && st>=1)	{						for (c=1; c<=tree[sp-notu][0]; ++c)	{							sp2=tree[sp-notu][c];							if (matrix[sp2][ch]==0)	matrix[sp2][ch]=st+1;							}						}/*						evolveunorderedinclade(tree[sp-notu],matrix,ch,st+2,UNKNOWN,INAP);	*/					/* if we have an essentially apomorphic states, then just do it like any other time */					else						evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],UNKNOWN,INAP);					}				else		evolvebinaryinclade(tree[sp-notu],matrix,ch);				for (c=1; c<=tree[sp-notu][0]; ++c)	{					sp2=tree[sp-notu][c];					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					if (invmatrix[ch][sp2]!=0 && (invmatrix[ch][sp2]!=UNKNOWN && invmatrix[ch][sp2]!=INAP))						++der[ch];					else if (invmatrix[ch][sp2]==0)						--der[ch];					/* this will happen only if there are reversals */					}				/* if there was a change, then tally it */				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1) || der[ch]<=1)				removefromivector(branches,sp,&a);							if (used<steps[ch])	{				printf("ERROR LINE 954 - there are more changes than deleted branches for Ch%d…\n",ch+1);				}			/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				++st;	/* we increment this only if we have made a change */				}			}	/*end derivation of state */		}	/* end loop for binary / unordered characters */		/* Ordered Multistates are tougher */	else if (nstates[ch]>2 && ctype[ch]==0)	{		used=0;		for (st=0; (st<nstates[ch]-1 && (steps[ch]<mxdel && steps[ch]<maxch[ch])); st=st)	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			sp=branches[br];			/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				/* in this case all taxa must be examined just in case the matrix has been recentered due to a negative number */				for (sp2=0; sp2<notu; ++sp2)	{					if (ev==0 && invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					}				ev=1;				}							else if (sp>notu)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])	flip=1;				else				flip=-1;				evolveorderedinclade(tree[sp-notu],matrix,ch,flip, INAP, UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				/* in this case all taxa must be modified just in case the matrix has been recentered due to a negative number */				for (sp2=0; sp2<notu; ++sp2)	{					if (ev==0 && invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					}				}							/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				/* note - do not increment st here - that is done only if a new state is derived */				}			/* check if all states have been derived */			/* note: this is needed only for ordered multistates */			if (steps[ch]>=nstates[ch]-1)	{				for(a=0; a<notu; ++a)	{					if (matrix[a][ch]>st && (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN))						st=matrix[a][ch];					}				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1))				removefromivector(branches,sp,&a);			if (used<steps[ch])				printf("ERROR LINE 2145 - there are more changes than deleted branches for Ch%d…\n",ch+1);						/* emergency reboot procedure! - clear everything and start over again */			if (used==ttlbr)	{				for (a=0; a<steps[ch]; ++a)	{					sp=taxachange[ch][a];					--mpd[sp];					taxachange[ch][a]=0;					}				deltas=deltas-steps[ch];				st=steps[ch]=used=0;				for (sp=0; sp<notu; ++sp)					if (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN)						invmatrix[ch][sp]=matrix[sp][ch]=0;				for (sp=0; sp<ttlbr; ++sp)	branches[sp]=available[sp];				}			}		/* if there are many states and few taxa, then you do not want to mess with this anymore.  Any changes will either eliminate extreme states,		or simply shift the state up or down one (resulting in no observable change once standardized.  So, if steps >= half the taxa, then shut it down */				}	/* end loop for ordered multistates */	}	/* end derivation of all character states *//* Step #2: make sure that each apomorphic species has a derivation */for (sp=0; (sp<notu+nodes && deltas<ttlstp); ++sp)	{	if (mpd[sp]==0 && trpd[sp]>0)	{		while (mpd[sp]==0)	{			ev=0;			ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));			while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))				ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));						if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				if (nstates[ch]==2)						invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);				else if (ctype[ch]==1)					invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);				else if (ctype[ch]==0)	{					invmatrix[ch][sp]=matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);					/* make sure no negative numbers are kept! */					multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);					}				ev=1;	/* this means that there was a change */				}						else if (sp>notu)	{				d=0;				/* make sure that there are taxa with scorable conditions for this character 		*/				/* and also that not all the descendants have changed already for this character 	*/				/* (the latter can be omitted as evolution cannot know this - but it makes the 		*/				/* output easier to compare to empirical studies.)									*/						for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;					else	{						for (c=0; c<steps[ch]; ++c)	{							if (taxachange[ch][c]==sp2)	{								++d;								c=steps[ch];								}							}						}		/* if any taxa have not yet changed, then d < clade diversity */					}	/* end search for scored taxa */					/* if d is less than clade diversity, then proceed with change */				if (d<tree[sp-notu][0])	{					/* if character is an unordered multistate, then we need an array	*/					/* that tells how each state changed withing the clade				*/					if (ctype[ch]==1)	{						/* routine for unordered multistates */						if (nstates[ch]>2)	{							evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);							}						/* routine for binaries */						else	{							evolvebinaryinclade(tree[sp-notu],matrix,ch);							}						}	/* end routine for unordered / binary characters */					/* routine for ordered multistate */					else {						/* flip is used only for multistates */						flip = ((int) (100 * rand() / RAND_MAX));						if (flip<bias[ch])	flip=1;						else				flip=-1;						evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					/* now make sure that there was change */					for (c=0; c<notu; ++c)	{						if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;						invmatrix[ch][c]=matrix[c][ch];						}					}	/* end conditional loop */				}	/* end routine for clade */			/* if there was a change, then ev = 1.  Now tally the information */			if (ev==1)	{				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++mpd[sp];				++deltas;				}	/* add changes if there actually was a change */			}	/* routine is repeated until an apomorphy is acquired */					}	/* end derivation of apomorphy for this branch */	}	/* end derivation for each apomorphic branch *//* Step #3: DO ADDITIONAL STEPS NOW */for (deltas=deltas; deltas < ttlstp; deltas=deltas)	{	/* first choose a character */	ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))		ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	/**************************************************************************/	/* do not change the character on a branch where it already has changed */	for (br=0; br<ttlbr; ++br)	branches[br]=available[br];		used=0;	/* used will tally the number of deleted branches */	for (d=0; d<steps[ch]; ++d)	{		for (c=0; c<(ttlbr-used); ++c)	{			/* if branch with change is found, delete it from possible changes */			if (branches[c]==taxachange[ch][d])	{				for (a=c; a<ttlbr-1; ++a)	branches[a]=branches[a+1];				/* some taxa will be in 2+ times - step back to delete them all */				--c;				branches[ttlbr-(used+1)]=-1;				++used;				}			}		}	/* choose a branch from one available */	/* used will be equal to or greater than steps[ch] (due to long branches) */	br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));	sp = branches[br];	/* this shouldn't be necessary, but occassionaly the random number generator */	/* produces a number outside of the proscribed limits */	while (trpd[sp]==0 || br>=(ttlbr-used))	{		br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));		sp = branches[br];		}	ev=0;	if (nstates[ch]==2)	{		/* routine for binary characters */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);			ev=1;			}		/* routine for clade */		else if (sp>=notu)	{			evolvebinaryinclade(tree[sp-notu],matrix,ch);			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;				invmatrix[ch][sp2]=matrix[sp2][ch];				}				}	/* end routine for clade */		}	/* Ordered Multistates */	else if (ctype[ch]==0)	{		flip = ((int) (100 * rand() / RAND_MAX));		if (flip<bias[ch])						flip=1;		else									flip=-1;				/* routine for species */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;			if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;			else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;			ev=1;			}		/* routine for clade */		else if (sp>=notu)	{			/* make sure that not all descendants have already changed! */			d=0;			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;				else	{					for (c=0; c<steps[ch]; ++c)	{						if (taxachange[ch][c]==sp2)	{							++d;							c=steps[ch];							}	/* end test of whether particular change matches species */						}	/* end search through each step */					}	/* end search for unchanged taxa */				}			if (d<tree[sp-notu][0])	{				evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				}			/* now make sure that there was change */			for (c=0; c<notu; ++c)	{				if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;				invmatrix[ch][c]=matrix[c][ch];				}			}	/* end routine for clade */		}	/** END ROUTINE FOR ORDERED MULTISTATES **/	/* Unordered Multistate Characters */	else if (ctype[ch]==1)	{		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);			ev=1;			}					else if (sp>notu)	{			evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);			/* make sure that there is change */			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	{						invmatrix[ch][sp2]=matrix[sp2][ch];						ev=1;						}					}				}			}	/* end unordered change for a clade */			/* if change is made, tally */		}	/* end unordered change */	/* if ev = 1, then there has been a change.  Tally it */	if (ev==1)	{		++deltas;		taxachange[ch][steps[ch]]=sp;		++steps[ch];		++mpd[sp];		}		}	/* end additional steps */free_ivector(der);free_ivector(mpd);free_ivector(trpd);free_ivector(steps);free_ivector(available);free_ivector(branches);free_ivector(aptaxa);free_imatrix(taxachange,nchars,mxdel);free_lmatrix(invmatrix,nchars, notu);return matrix;}/* evolvecompat - evolves matrix and returns compatibility for min to max steps.  Gaps and missing are kept in place *//* Requires:   tree - a matrix containing members of each node, with daughter nodes given a number of OTUs+node#;		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[OTUs-1]) gives it for species;			the second line (tree[OTUs]) gives it for internal nodes;	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	maxch - maximum number of changes per character	minstep - the maximum number of changes for the matrix;	maxstep - the maximum number of changes for the matrix;	comptype - 0 for normal compatibility, 1 for hierarchical compatibility;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/long *evolvecompat(long **tree, int notu, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int minstp, int maxstp, int comptype, int UNKNOWN, int INAP){int		a, b, c, d, br, ch, sc, ev, flip, sp, sp2;int		st, u, clse, best;int		avnodes, nodes, used, deltas, mxdel, ttlbr;int		*available, *branches, *steps, *trpd, *mpd, *der, *aptaxa;int		**taxachange;/*, **descnodes;	/* for debugging */long	*compatibility;long	**invmatrix;/* find the number of nodes and their diversities */nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character */mpd=ivector(nodes+notu);					/* morphologic changes along each branch */trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */steps=ivector(nchars);						/* number of times each character changes */der=ivector(nchars);						/* number of taxa with derived condition for each character */compatibility=lvector(1+(maxstp-minstp));	/* compatibility[X] is compatibility after X steps */trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	/* check tomake sure that this shouldn't be tree[nodes][sp]	*/	trpd[sp]=tree[nodes][sp];		/* array tree[notu-1] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[nodes+1][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	}	if (ttlbr<mxdel)	mxdel=ttlbr;/*if (ttltx<mxdel)	mxdel=ttltx;	/* 2014-03-21: we allow only as many changes as there are taxa that have changes	*//* allocate memory for arrays containing branches needing changes */available=ivector(ttlbr);branches=ivector(ttlbr);taxachange=imatrix(nchars, mxdel);	/* gives taxa that change for character */invmatrix=lmatrix(nchars, notu);aptaxa=applicabletaxa(matrix, nchars, notu, INAP);/* BEGIN HERE 5/18/01 describe each clade in terms of all species within it *//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********/	/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */avnodes=b=0;for (a=1; a<nodes; ++a)	{	avnodes=avnodes+trpd[a+notu];	for (c=0; c<trpd[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		available[b]=a;		++b;		}	}/* clear matrix */for (ch=0; ch<nchars; ++ch)	{	for (a=0; a<notu; ++a)	{		if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{			matrix[a][ch]=0;			}		invmatrix[ch][a]=matrix[a][ch];	/* for debugging */		}	}deltas=0;/* Step 1: Make sure each state is derived for each character *//*derive_each_char(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, aptaxa, mpd, trpd, notu, nchars, maxstp, mxdel, UNKNOWN, INAP, tree, branches, available, nodes, ttlbr);	*/for (ch=0; (ch<nchars && deltas<maxstp); ++ch)	{	while (maxch[ch]==0 && ch<nchars)	++ch;	if (ch>=nchars)			break;	steps[ch]=st=0;	clearivector(taxachange[ch],mxdel,-1);	ev=0;			/* make sure that inapplicable characters have at least one taxon that can be changed */	if (aptaxa[ch]<notu)	{		/* count unknowns - these will be put back in later */		u=0;		for (a=0; a<notu; ++a)	if (matrix[a][ch]==UNKNOWN)	++u;		/* now find a node that has similar diversity */		clse=RAND_MAX;				/* start from the bottom if most taxa are scored */		if (aptaxa[ch]>(notu/2))	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==(notu-aptaxa[ch]))	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs((notu-aptaxa[ch])-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}		/* start from the top otherwise */		else	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==aptaxa[ch])	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs(aptaxa[ch]-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}				for (sp=0; sp<notu; ++sp)	{			if (aptaxa[ch]>(notu/2))	matrix[sp][ch]=0;			else						matrix[sp][ch]=INAP;			}		for (a=1; a<tree[best][0]; ++a)	{			sp=tree[best][a];			matrix[sp][a]=0;			}		}	/* end initial creation of inapplicable character */		/* make autapomorphic characters change on one species only */	/* invariants do not change at all */	for (ch=ch; maxch[ch]<=1; ++ch)	{		/* skip invariants and make autapomorphies autapomorphic */		if	(maxch[ch]==1)	{			c=0;			/* we will sample only from otus here - so do not include clades in branches array! */			/* this part rewritten with Cubs winning 7-0 against the Marlins in Game 4 */			for (sp=0; sp<notu; ++sp)				if ((matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP) && trpd[sp]>0)	++c;			if (c>0)	{				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || (trpd[sp]==0 || sp>=notu))					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=1;				taxachange[ch][0]=sp;				}			/* if only cells belong to species with 0 length branches */			if (c==0)	{				/* flip-flop an unknown apomorphic species with a known plesiomorphic one - give plesiomorphic species a ? and the other a 1 */				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || sp2>=notu)					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);								sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while (trpd[sp2]==0 || sp2>=notu)					sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp2][ch];				invmatrix[ch][sp2]=matrix[sp2][ch]=1;				taxachange[ch][0]=sp2;				}	/* end routine if all scored species were unknown */			ev=1;			++deltas;			++steps[ch];			++mpd[ch];			}		}	/* this should leave us with a character that needs to be changed OR out of characters */	if (ch>=nchars)	break;			used=0;	/* this tells how many branches are discarded; used > steps IF there are absents */	/* branch length is taken into account by trpd */	equalivector(branches,available,ttlbr);	/* Binary && unordered multistate is Easy */	/* for normal character, have it change until all X states are realized */	if (nstates[ch]==2 || ctype[ch]==1)	{		/* changed 10/14/2003 so that non-apomorphic characters	diagnose 2+ species */		for (st=0; (st<nstates[ch]-1 || der[ch]<=1); st=st)	{			/* There are ttlbr-used branches that could change */			ev=0;				/* fixed 2014-02-26	*/			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			/* have binary characters change on branches - if they are not autapomorphic, then they need to diagnose multiple species THIS WAS REMOVED 10/14/2003			else				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (avnodes-used));*/			sp = branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				ev=1;				if (nstates[ch]==2)	invmatrix[ch][sp]=matrix[sp][ch]=1;				else					invmatrix[ch][sp]=matrix[sp][ch]=st+1;				++der[ch];				/* add one to the number of species showing derived condition(s) */				}			else if (sp>notu)	{				/* use st+1 instead of nstates[ch] here - we want only 0…st+1 not 0…nstates    */				/*		(remember, st has not yet been incremented, so we need st+1) 		   */				/* This section modified 10/14/2003 to make sure characters are not apomorphic */				/* if multistate, then we need at least two iterations */				if (nstates[ch]>2)	{					/* if we have not yet derived all of the states, do it this way 			*/					/* if deriving first state (i.e., st=0), then it is the same as binary		*/					if (st<nstates[ch] && st==0)						evolvebinaryinclade(tree[sp-notu],matrix,ch);					/* if deriving subsequent states, then used change unmodified species to st+1 		*/					else if (st<(nstates[ch]-1) && st>=1)	{						for (c=1; c<=tree[sp-notu][0]; ++c)	{							sp2=tree[sp-notu][c];							if (matrix[sp2][ch]==0)	matrix[sp2][ch]=st+1;							}						}/*						evolveunorderedinclade(tree[sp-notu],matrix,ch,st+2,UNKNOWN,INAP);	*/					/* if we have an essentially apomorphic states, then just do it like any other time */					else						evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],UNKNOWN,INAP);					}				else		evolvebinaryinclade(tree[sp-notu],matrix,ch);				for (c=1; c<=tree[sp-notu][0]; ++c)	{					sp2=tree[sp-notu][c];					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					if (invmatrix[ch][sp2]!=0 && (invmatrix[ch][sp2]!=UNKNOWN && invmatrix[ch][sp2]!=INAP))						++der[ch];					else if (invmatrix[ch][sp2]==0)						--der[ch];					/* this will happen only if there are reversals */					}				/* if there was a change, then tally it */				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1) || der[ch]<=1)				removefromivector(branches,sp,&a);							if (used<steps[ch])	{				printf("ERROR LINE 954 - there are more changes than deleted branches for Ch%d…\n",ch+1);				}			/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				++st;	/* we increment this only if we have made a change */				}			}	/*end derivation of state */		}	/* end loop for binary / unordered characters */		/* Ordered Multistates are tougher */	else if (nstates[ch]>2 && ctype[ch]==0)	{		used=0;		for (st=0; (st<nstates[ch]-1 && (steps[ch]<mxdel && steps[ch]<maxch[ch])); st=st)	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			sp=branches[br];			/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				/* in this case all taxa must be examined just in case the matrix has been recentered due to a negative number */				for (sp2=0; sp2<notu; ++sp2)	{					if (ev==0 && invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					}				ev=1;				}							else if (sp>notu)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])	flip=1;				else				flip=-1;				evolveorderedinclade(tree[sp-notu],matrix,ch,flip, INAP, UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				/* in this case all taxa must be modified just in case the matrix has been recentered due to a negative number */				for (sp2=0; sp2<notu; ++sp2)	{					if (ev==0 && invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					}				}							/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				/* note - do not increment st here - that is done only if a new state is derived */				}			/* check if all states have been derived */			/* note: this is needed only for ordered multistates */			if (steps[ch]>=nstates[ch]-1)	{				for(a=0; a<notu; ++a)	{					if (matrix[a][ch]>st && (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN))						st=matrix[a][ch];					}				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1))				removefromivector(branches,sp,&a);			if (used<steps[ch])				printf("ERROR LINE 2145 - there are more changes than deleted branches for Ch%d…\n",ch+1);						/* emergency reboot procedure! - clear everything and start over again */			if (used==ttlbr)	{				for (a=0; a<steps[ch]; ++a)	{					sp=taxachange[ch][a];					--mpd[sp];					taxachange[ch][a]=0;					}				deltas=deltas-steps[ch];				st=steps[ch]=used=0;				for (sp=0; sp<notu; ++sp)					if (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN)						invmatrix[ch][sp]=matrix[sp][ch]=0;				for (sp=0; sp<ttlbr; ++sp)	branches[sp]=available[sp];				}			}		/* if there are many states and few taxa, then you do not want to mess with this anymore.  Any changes will either eliminate extreme states,		or simply shift the state up or down one (resulting in no observable change once standardized.  So, if steps >= half the taxa, then shut it down */				}	/* end loop for ordered multistates */	}	/* end derivation of all character states *//* Step #2: make sure that each apomorphic species has a derivation */for (sp=0; (sp<notu+nodes && deltas<maxstp); ++sp)	{	if (mpd[sp]==0 && trpd[sp]>0)	{		while (mpd[sp]==0)	{			ev=0;			ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));			while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))				ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));						if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				if (nstates[ch]==2)						invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);				else if (ctype[ch]==1)					invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);				else if (ctype[ch]==0)	{					invmatrix[ch][sp]=matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);					/* make sure no negative numbers are kept! */					multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);					}				ev=1;	/* this means that there was a change */				}						else if (sp>notu)	{				d=0;				/* make sure that there are taxa with scorable conditions for this character 		*/				/* and also that not all the descendants have changed already for this character 	*/				/* (the latter can be omitted as evolution cannot know this - but it makes the 		*/				/* output easier to compare to empirical studies.)									*/						for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;					else	{						for (c=0; c<steps[ch]; ++c)	{							if (taxachange[ch][c]==sp2)	{								++d;								c=steps[ch];								}							}						}		/* if any taxa have not yet changed, then d < clade diversity */					}	/* end search for scored taxa */					/* if d is less than clade diversity, then proceed with change */				if (d<tree[sp-notu][0])	{					/* if character is an unordered multistate, then we need an array	*/					/* that tells how each state changed withing the clade				*/					if (ctype[ch]==1)	{						/* routine for unordered multistates */						if (nstates[ch]>2)	{							evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);							}						/* routine for binaries */						else	{							evolvebinaryinclade(tree[sp-notu],matrix,ch);							}						}	/* end routine for unordered / binary characters */					/* routine for ordered multistate */					else {						/* flip is used only for multistates */						flip = ((int) (100 * rand() / RAND_MAX));						if (flip<bias[ch])	flip=1;						else				flip=-1;						evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					/* now make sure that there was change */					for (c=0; c<notu; ++c)	{						if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;						invmatrix[ch][c]=matrix[c][ch];						}					}	/* end conditional loop */				}	/* end routine for clade */			/* if there was a change, then ev = 1.  Now tally the information */			if (ev==1)	{				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++mpd[sp];				++deltas;				}	/* add changes if there actually was a change */			}	/* routine is repeated until an apomorphy is acquired */					}	/* end derivation of apomorphy for this branch */	}	/* end derivation for each apomorphic branch *//* Step #3: DO ADDITIONAL STEPS NOW */for (deltas=deltas; deltas < maxstp; deltas=deltas)	{	/* first choose a character */	ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))		ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	/**************************************************************************/	/* do not change the character on a branch where it already has changed */	for (br=0; br<ttlbr; ++br)	branches[br]=available[br];		used=0;	/* used will tally the number of deleted branches */	for (d=0; d<steps[ch]; ++d)	{		for (c=0; c<(ttlbr-used); ++c)	{			/* if branch with change is found, delete it from possible changes */			if (branches[c]==taxachange[ch][d])	{				for (a=c; a<ttlbr-1; ++a)	branches[a]=branches[a+1];				/* some taxa will be in 2+ times - step back to delete them all */				--c;				branches[ttlbr-(used+1)]=-1;				++used;				}			}		}	/* choose a branch from one available */	/* used will be equal to or greater than steps[ch] (due to long branches) */	br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));	sp = branches[br];	/* this shouldn't be necessary, but occassionaly the random number generator */	/* produces a number outside of the proscribed limits */	while (trpd[sp]==0 || br>=(ttlbr-used))	{		br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));		sp = branches[br];		}	ev=0;	if (nstates[ch]==2)	{		/* routine for binary characters */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);			ev=1;			}		/* routine for clade */		else if (sp>=notu)	{			evolvebinaryinclade(tree[sp-notu],matrix,ch);			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;				invmatrix[ch][sp2]=matrix[sp2][ch];				}				}	/* end routine for clade */		}	/* Ordered Multistates */	else if (ctype[ch]==0)	{		flip = ((int) (100 * rand() / RAND_MAX));		if (flip<bias[ch])						flip=1;		else									flip=-1;				/* routine for species */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;			if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;			else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;			ev=1;			}		/* routine for clade */		else if (sp>=notu)	{			/* make sure that not all descendants have already changed! */			d=0;			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;				else	{					for (c=0; c<steps[ch]; ++c)	{						if (taxachange[ch][c]==sp2)	{							++d;							c=steps[ch];							}	/* end test of whether particular change matches species */						}	/* end search through each step */					}	/* end search for unchanged taxa */				}			if (d<tree[sp-notu][0])	{				evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				}			/* now make sure that there was change */			for (c=0; c<notu; ++c)	{				if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;				invmatrix[ch][c]=matrix[c][ch];				}			}	/* end routine for clade */		}	/** END ROUTINE FOR ORDERED MULTISTATES **/	/* Unordered Multistate Characters */	else if (ctype[ch]==1)	{		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);			ev=1;			}					else if (sp>notu)	{			evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);			/* make sure that there is change */			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	{						invmatrix[ch][sp2]=matrix[sp2][ch];						ev=1;						}					}				}			}	/* end unordered change for a clade */			/* if change is made, tally */		}	/* end unordered change */	/* if ev = 1, then there has been a change.  Tally it */	if (ev==1)	{		++deltas;		taxachange[ch][steps[ch]]=sp;		++steps[ch];		++mpd[sp];		if (deltas >= minstp && deltas <= maxstp)	{			compatibility[deltas-minstp]=a=nu_comp(nstates, notu, matrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);			}		}		}	/* end additional steps */free_ivector(der);free_ivector(mpd);free_ivector(trpd);free_ivector(steps);free_ivector(available);free_ivector(branches);free_ivector(aptaxa);free_imatrix(taxachange,nchars,mxdel);free_lmatrix(invmatrix,nchars, notu);return compatibility;}/* evolvetocompat - evolves a matrix until it reaches a particular compatibility.  Gaps and missing are kept in place *//* Requires:   tree - a matrix containing every observed descendant of each node		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[nodes]) gives it for species;			the second line (tree[nodes+1]) gives it for internal nodes;	tcomp - compatibility that must be evolved (usually based on observed compatibility);	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	maxch - the maximum number of changes for each character;	depend - array giving character dependency (if depend[a]=a then it is independent);	comptype - 0 for normal compatibility, 1 for hierarchical compatibility;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;/* Returns:	matrix - a matrix with compatibility = tcomp;*******************************************************************************************************************************************/long **evolvetocompat(long **tree, int tcomp, int notu, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int *depend, int comptype, int UNKNOWN, int INAP){int		a, b, c, d, br, ch, sc, ev, flip, sp, sp2, cmp, nodes;int		avnodes, deltas, mxdel, ttlbr, mxdp=1, avch, avbr, htu;int		reboot, trial, trying=0, maxtrial=5;int		lch[1000];int		*availablech, *availablebr, *branches, *steps, *trpd, *mpd, *sychos;//int		*missing;int		**taxachange, **sychomat;/*, *der, **descnodes, *aptaxa;	/* for debugging */long	**invmatrix;/* find the number of nodes and their diversities *//*nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}	*/nodes=cladecountbytaxa(tree,notu);mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character */trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */mpd=ivector(nodes+notu);					/* morphologic changes along each branch 						*/steps=ivector(nchars);						/* number of times each character changes 						*//*der=ivector(nchars);						/* number of taxa with derived condition for each character 	*/sychos=ivector(nchars);						/* number of dependendent characters attached to a character 	*//*missing=ivector(nchars);					/* 2011-03-31: # missing or inapplicable taxa for a character	*//* 2011-03-31: tally whether there are missing data for this character	*/ /*for (ch=0; ch<nchars; ++ch)	{	missing[ch]=0;	for (sp=0; sp<notu && missing[ch]==0; ++sp)	if (matrix[sp][ch]==UNKNOWN || matrix[sp][ch]==INAP)	missing[ch]=1;	}	*/for (ch=0; ch<nchars; ++ch)	++sychos[depend[ch]];	/* sychos[x] gives the number of characters dependent on x; if 0 then character is dependent */mxdp=maxiarray(sychos,nchars);						/* b will be the maximum number of dependent characters for any character */if (mxdp>1)	{	sychomat=imatrix(nchars,mxdp);	clearivector(sychos,nchars,0);	for (ch=0; ch<nchars; ++ch)	{		sychomat[depend[ch]][sychos[depend[ch]]]=ch;		++sychos[depend[ch]];		}	}/*descnodes=descendantnodes(tree,notu);	*//*nodestates=lmatrix(nodes,nchars);	*/trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[nodes][sp];		/* array tree[nodes] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[nodes+1][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	}	ttlbr=sumivector(trpd,notu+nodes);	if (ttlbr<mxdel)	mxdel=ttlbr;/*if (ttltx<mxdel)	mxdel=ttltx;	/* 2014-03-21: we allow only as many changes as there are taxa that have changes	*//* allocate memory for arrays containing branches needing changes */availablech=ivector(nchars);				/* lists each character available to a branch									*/availablebr=ivector(ttlbr);					/* lists each otu & htu once for every branch length; ancestors therefore lost	*/branches=ivector(ttlbr);					/* lists each htu & non-ancestral otu that is scored for a character			*/taxachange=imatrix(10*nchars, 10*mxdel);	/* gives taxa that change for character */invmatrix=lmatrix(nchars, notu);/*aptaxa=applicabletaxa(matrix, nchars, notu, INAP);	*//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********//******* MORE REWRITING 3/31/11: Man, I'm on a road to nowhere!!!		*********/	reboot=0;while (reboot==0)	{	/* determine appropriate branches for changes - all nodes & species without sampled descendants */	/* we'll ignore the basal node, assuming that it is all 0's */	avnodes=b=0;	++trying;							/* 2011-02-07 DEBUGGING	*/	for (a=1; a<nodes; ++a)	{		avnodes=avnodes+trpd[a+notu];		for (c=0; c<trpd[a+notu]; ++c)	{			availablebr[b]=a+notu;			++b;			}		}	for (a=0; a<notu; ++a)	{		for (c=0; c<trpd[a]; ++c)	{			availablebr[b]=a;			++b;			}		}	/* clear matrix */	for (ch=0; ch<nchars; ++ch)	{		for (a=0; a<notu; ++a)	{			if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{				matrix[a][ch]=0;				}			invmatrix[ch][a]=matrix[a][ch];	/* for debugging */			}		}	clearivector(steps,nchars,0);	clearivector(mpd,notu+nodes,0);		/* 2014-03-19: mpd gives branch length in changes: this must be zero at the outset	*/	clearimatrix(taxachange,nchars,mxdel,0);	deltas=0;	/* Step #2: make sure that each apomorphic species has a derivation */	ensure_apomorphies(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);	deltas=sumivector(steps,nchars);		/* Step 1: Make sure each state is derived for each character */	ensure_charstates(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);	deltas=sumivector(steps,nchars);	/* Step #3: DO ADDITIONAL STEPS NOW */	trial=0;	cmp=nu_comp(nstates, notu, matrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);		if (cmp>tcomp)	{		avch=0;		/* all characters that still can change go into availablech	*/		for (ch=0; ch<nchars; ++ch)	{			if ((ctype[ch]==1 && steps[ch]<maxch[ch]) || (ctype==0 && steps[ch]>(notu/2)))	{				availablech[avch]=ch;				++avch;				}			}		/* 2011-02-07: was trial < 3	*/		for (deltas=deltas; trial < maxtrial && cmp!=tcomp; deltas=deltas)	{			/* first choose a character */			c=(int)((double)rand() / ((double)RAND_MAX + 1) * avch);			ch=availablech[c];						for (sp=0; sp<notu; ++sp)	lch[sp]=matrix[sp][ch];		/* record matrix as it was	*/			/************************************************************************************/			/* eliminated the missing characters routine on 2011-10-28: it was causing problems	*/			/************************************************************************************/			/* now, find available branches for this character	*//*			if (missing[ch]==0)	{				for (br=0; br<ttlbr; ++br) branches[br]=availablebr[br];				avbr=ttlbr;				}	*//*		else	{	*/			avbr=0;			for (br=0; br<ttlbr; ++br)	{				htu=availablebr[br];				/* taxon (otu or clade) represented: before I screwed up and used br itself; that was fine for ultrametric cladograms, though	*/				if ((htu<notu && trpd[htu]>0) && (matrix[htu][ch]!=UNKNOWN && matrix[htu][ch]!=INAP))	{/*				if ((br<notu && trpd[htu]>0) && (matrix[br][ch]!=UNKNOWN && matrix[br][ch]!=INAP))	{	*/					for (a=0; a<trpd[htu]; ++a)	{/*						branches[avbr]=br;	*/						branches[avbr]=htu;						++avbr;						}					}				/* taxachange gets nuked here in run 1 around taxon 22	*/				else if (htu>=notu)	{					/* for each node, make sure that at least one species has this character observed	*/					d=0;	/* becomes 1 when clade is scored	*/					for (sc=1; sc<=tree[htu-notu][0] && d==0; ++sc)	{						sp=tree[htu-notu][sc];						if (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP)	d=1;						}					if (d==1)	{						for (a=0; a<trpd[htu]; ++a)	{							branches[avbr]=htu;							++avbr;							}						}	/* end adding clade to available branches	*/					}	/* end test to see whether clade is among available branches	*/								br+=(trpd[htu]-1);	/* 2011-03-31: skip rest of this taxon	*/				}	/* end compiling of available branches for character ch	*//*			}	/* end case where only some branches can be sampled;						/* remove branches where there already has been change	*/			for (a=0; a<steps[ch]; ++a)	{				sp=taxachange[ch][a];				removefromivector(branches,sp,&avbr);				}						br=(int)((double)rand() / ((double)RAND_MAX +1) * avbr);			sp=branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=avbr)	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * avbr);				sp = branches[br];				}			ev=0;			if (nstates[ch]==2)	{				/* routine for binary characters */				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);					ev=1;					}				/* routine for clade */				else if (sp>=notu)	{					evolvebinaryinclade(tree[sp-notu],matrix,ch);					for (a=1; a<=tree[sp-notu][0]; ++a)	{						sp2=tree[sp-notu][a];						if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;						invmatrix[ch][sp2]=matrix[sp2][ch];						}						}	/* end routine for clade */				}			/* Ordered Multistates */			else if (ctype[ch]==0)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])						flip=1;				else									flip=-1;								/* routine for species */				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;					if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;					else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;					ev=1;					}				/* routine for clade */				else if (sp>=notu)	{					/* make sure that not all descendants have already changed! */					d=0;					for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{						sp2=tree[sp-notu][sc];						if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;						else	{							for (c=0; c<steps[ch]; ++c)	{								if (taxachange[ch][c]==sp2)	{									++d;									c=steps[ch];									}	/* end test of whether particular change matches species */								}	/* end search through each step */							}	/* end search for unchanged taxa */						}					if (d<tree[sp-notu][0])	{						evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					/* now make sure that there was change */					for (c=0; c<notu; ++c)	{						if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;						invmatrix[ch][c]=matrix[c][ch];						}					}	/* end routine for clade */				}	/** END ROUTINE FOR ORDERED MULTISTATES **/			/* Unordered Multistate Characters */			else if (ctype[ch]==1)	{				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);					ev=1;					}									else if (sp>notu)	{					evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);					/* make sure that there is change */					for (a=1; a<=tree[sp-notu][0]; ++a)	{						sp2=tree[sp-notu][a];						if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{							if (invmatrix[ch][sp2]!=matrix[sp2][ch])	{								invmatrix[ch][sp2]=matrix[sp2][ch];								ev=1;								}							}						}					}	/* end unordered change for a clade */					/* if change is made, tally */				}	/* end unordered change */			/* if ev = 1, then there has been a change.  Tally it */			if (ev==1)	{				cmp=nu_comp(nstates, notu, matrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);				if (cmp<tcomp)	{					++trial;/*					printf("Try %d, trial %d\n",trying,trial);	/* DEBUGGING CODE 2011-02-02	*/					for (sp=0; sp<notu; ++sp)	invmatrix[ch][sp]=matrix[sp][ch]=lch[sp];//					--deltas;					}				/* register change, etc., only if we are keeping it	*/				else	{/*					trial=0;	*/					++deltas;					taxachange[ch][steps[ch]]=sp;					if (ch<0 || ch>=nchars)						printf("out of bounds at %d steps with character %d\n",deltas,ch);					if (steps[ch]<0 || steps[ch]>=mxdel)						printf("out of bounds at %d steps for character %d\n",steps[ch],ch);					++steps[ch];					if (steps[ch]==mxdel)	removefromivector(availablech,ch,&avch);					++mpd[sp];					}				}			/* if we are three steps removed from the the right compatibility, reboot */			if (trial==maxtrial)	{/*				printf("Try %d\n",trying);	/* DEBUGGING CODE 2011-02-07	*/				reboot = 0;				clearivector(mpd,nodes+notu,0);				clearivector(steps,nchars,0);/*				clearivector(der,nchars,0);	*/				}			if (cmp==tcomp)	reboot=1;			}	/* end additional steps */		}	}	/* end search for matrix with compatibility tcmp *//* 2011-02-10: found an error for Ordovician Echinoids that is revealed here: something gets overwritten!	*///free_ivector(der);//free_ivector(aptaxa);free_ivector(mpd);										/* free vector recording branch lengths in changes		*/free_ivector(trpd);										/* free vector recording branch lengths	in ancestors	*/free_ivector(steps);									/* free vector recording steps per character			*/free_ivector(availablech);								/* free vector recording characters that can change		*/free_ivector(availablebr);								/* free vector recording branches that can change		*/free_ivector(branches);									/* free vector recording branches						*/free_ivector(sychos);									/* free vector recording dependent characters			*//*free_ivector(missing);									/* 2011-03-31: # missing or inapplicable taxa for a character	*/if (mxdp>1)	free_imatrix(sychomat,nchars,nchars);	/* START HERE	*/free_imatrix(taxachange,10*nchars,mxdel);free_lmatrix(invmatrix,nchars, notu);return matrix;}/* evolvetocompatibility - evolves a matrix until it reaches a particular compatibility.  Gaps and missing are kept in place *//* Requires:   tree - a matrix containing every observed descendant of each node		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[nodes]) gives it for species;			the second line (tree[nodes+1]) gives it for internal nodes;	tcomp - compatibility that must be evolved (usually based on observed compatibility);	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	maxch - the maximum number of changes for each character;	depend - array giving character dependency (if depend[a]=a then it is independent);	comptype - 0 for normal compatibility, 1 for hierarchical compatibility;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;/* Returns:	matrix - a matrix with compatibility = tcomp;*******************************************************************************************************************************************/long **evolvetocompatibility(long **tree, int tcomp, int notu, int nodes, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int *depend, int comptype, int UNKNOWN, int INAP){int		a, b, c, d, br, ch, sc, ev, flip, sp, sp2, cmp;int		avnodes, deltas, mxdel, ttlbr, ttltx=0, mxdp=1, avch, avbr;int		reboot, trial, trying=0, maxtrial=5;int		lch[1000];int		*availablech, *availablebr, *branches, *steps, *trpd, *mpd, *sychos;/*int		*missing;	*/int		**taxachange, **sychomat;/*, *der, **descnodes, *aptaxa;	/* for debugging */long	**invmatrix;/* find the number of nodes and their diversities *//*nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}	nodes=cladecountbytaxa(tree,notu);*/mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character */trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */mpd=ivector(nodes+notu);					/* morphologic changes along each branch 						*/steps=ivector(nchars);						/* number of times each character changes 						*//*der=ivector(nchars);						/* number of taxa with derived condition for each character 	*/sychos=ivector(nchars);						/* number of dependendent characters attached to a character 	*//*missing=ivector(nchars);					/* 2011-03-31: # missing or inapplicable taxa for a character	*//* 2011-03-31: tally whether there are missing data for this character	for (ch=0; ch<nchars; ++ch)	{	missing[ch]=0;	for (sp=0; sp<notu && missing[ch]==0; ++sp)	if (matrix[sp][ch]==UNKNOWN || matrix[sp][ch]==INAP)	missing[ch]=1;	}	*/ for (ch=0; ch<nchars; ++ch)	++sychos[depend[ch]];	/* sychos[x] gives the number of characters dependent on x; if 0 then character is dependent */mxdp=maxiarray(sychos,nchars);						/* b will be the maximum number of dependent characters for any character */if (mxdp>1)	{	sychomat=imatrix(nchars,mxdp);	clearivector(sychos,nchars,0);	for (ch=0; ch<nchars; ++ch)	{		sychomat[depend[ch]][sychos[depend[ch]]]=ch;		++sychos[depend[ch]];		}	}/*descnodes=descendantnodes(tree,notu);	*//*nodestates=lmatrix(nodes,nchars);	*/trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[nodes][sp];		/* array tree[nodes] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	if (trpd[sp]>0)	++ttltx;	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[nodes+1][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	if (trpd[sp+notu]>0)	++ttltx;	}	ttlbr=sumivector(trpd,notu+nodes);	if (ttlbr<mxdel)	mxdel=ttlbr;if (ttltx<mxdel)	mxdel=ttltx;	/* 2014-03-21: we allow only as many changes as there are taxa that have changes	*//* allocate memory for arrays containing branches needing changes */availablech=ivector(nchars);				/* lists each character available to a branch									*/availablebr=ivector(ttlbr);					/* lists each otu & htu once for every branch length; ancestors therefore lost	*/branches=ivector(ttlbr);					/* lists each htu & non-ancestral otu that is scored for a character			*/taxachange=imatrix(10*nchars, 10*mxdel);	/* gives taxa that change for character */invmatrix=lmatrix(nchars, notu);/*aptaxa=applicabletaxa(matrix, nchars, notu, INAP);	*//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********//******* MORE REWRITING 3/31/11: Man, I'm on a road to nowhere!!!		*********/	reboot=0;while (reboot==0)	{	/* determine appropriate branches for changes - all nodes & species without sampled descendants */	/* we'll ignore the basal node, assuming that it is all 0's */	avnodes=b=0;	++trying;							/* 2011-02-07 DEBUGGING	*/	for (a=1; a<nodes; ++a)	{		avnodes=avnodes+trpd[a+notu];		for (c=0; c<trpd[a+notu]; ++c)	{			availablebr[b]=a+notu;			++b;			}		}	for (a=0; a<notu; ++a)	{		for (c=0; c<trpd[a]; ++c)	{			availablebr[b]=a;			++b;			}		}	/* clear matrix */	for (ch=0; ch<nchars; ++ch)	{		for (a=0; a<notu; ++a)	{			if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{				matrix[a][ch]=0;				}			invmatrix[ch][a]=matrix[a][ch];	/* for debugging */			}		}	clearivector(steps,nchars,0);	clearivector(mpd,notu+nodes,0);		/* 2014-03-19: mpd gives branch length in changes: this must be zero at the outset	*/	clearimatrix(taxachange,nchars,mxdel,0);	deltas=0;	/* Step #2: make sure that each apomorphic species has a derivation */	ensure_apomorphies(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);	deltas=sumivector(steps,nchars);		/* Step 1: Make sure each state is derived for each character */	ensure_charstates(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);	deltas=sumivector(steps,nchars);	/* Step #3: DO ADDITIONAL STEPS NOW */	trial=0;	cmp=nu_comp(nstates, notu, matrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);		if (cmp>tcomp)	{		avch=0;		/* all characters that still can change go into availablech	*/		for (ch=0; ch<nchars; ++ch)	{			if ((ctype[ch]==1 && steps[ch]<maxch[ch]) || (ctype==0 && steps[ch]>(notu/2)))	{				availablech[avch]=ch;				++avch;				}			}		/* 2011-02-07: was trial < 3	*/		for (deltas=deltas; trial < maxtrial && cmp!=tcomp; deltas=deltas)	{			/* first choose a character */			c=(int)((double)rand() / ((double)RAND_MAX + 1) * avch);			ch=availablech[c];			while (steps[ch]>=ttltx)	{				c=(int)((double)rand() / ((double)RAND_MAX + 1) * avch);				ch=availablech[c];				}						for (sp=0; sp<notu; ++sp)	lch[sp]=matrix[sp][ch];		/* record matrix as it was	*/			/**************************************************************************/			for (br=0; br<ttlbr; ++br) branches[br]=availablebr[br];			avbr=ttlbr;			/* old routine for dealing with characters with missing data.  This caused grief and problems!	*/			/* now, find available branches for this character	*///			if (missing[ch]==0)	{//				for (br=0; br<ttlbr; ++br) branches[br]=availablebr[br];//				avbr=ttlbr;//				}//			else	{//				avbr=0;//				for (br=0; br<ttlbr; ++br)	{//					htu=availablebr[br];				/* taxon (otu or clade) represented: before I screwed up and used br itself; that was fine for ultrametric cladograms, though	*///					if ((htu<notu && trpd[htu]>0) && (matrix[htu][ch]!=UNKNOWN && matrix[htu][ch]!=INAP))	{//	/*				if ((br<notu && trpd[htu]>0) && (matrix[br][ch]!=UNKNOWN && matrix[br][ch]!=INAP))	{	*///						for (a=0; a<trpd[htu]; ++a)	{//	/*						branches[avbr]=br;	*///							branches[avbr]=htu;//							++avbr;//							}//						}				/* taxachange gets nuked here in run 1 around taxon 22	*///					else if (htu>=notu)	{//						/* for each node, make sure that at least one species has this character observed	*///						d=0;	/* becomes 1 when clade is scored	*///						for (sc=1; sc<=tree[htu-notu][0] && d==0; ++sc)	{//							sp=tree[htu-notu][sc];//							if (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP)	d=1;//							}//						if (d==1)	{//							for (a=0; a<trpd[htu]; ++a)	{//								branches[avbr]=htu;//								++avbr;//								}//							}	/* end adding clade to available branches	*///						}	/* end test to see whether clade is among available branches	*///					//					br+=(trpd[htu]-1);	/* 2011-03-31: skip rest of this taxon	*///					}	/* end compiling of available branches for character ch	*///				}	/* end case where only some branches can be sampled;						/* remove branches where there already has been change	*/			for (a=0; a<steps[ch]; ++a)	{				sp=taxachange[ch][a];				removefromivector(branches,sp,&avbr);				}						br=(int)((double)rand() / ((double)RAND_MAX +1) * avbr);			sp=branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=avbr)	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * avbr);				sp = branches[br];				}			ev=0;			if (nstates[ch]==2)	{				/* routine for binary characters */				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);					ev=1;					}				/* routine for clade */				else if (sp>=notu)	{					evolvebinaryinclade(tree[sp-notu],matrix,ch);					for (a=1; a<=tree[sp-notu][0]; ++a)	{						sp2=tree[sp-notu][a];						if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;						invmatrix[ch][sp2]=matrix[sp2][ch];						}						}	/* end routine for clade */				}			/* Ordered Multistates */			else if (ctype[ch]==0)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])						flip=1;				else									flip=-1;								/* routine for species */				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;					if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;					else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;					ev=1;					}				/* routine for clade */				else if (sp>=notu)	{					/* make sure that not all descendants have already changed! */					d=0;					for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{						sp2=tree[sp-notu][sc];						if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;						else	{							for (c=0; c<steps[ch]; ++c)	{								if (taxachange[ch][c]==sp2)	{									++d;									c=steps[ch];									}	/* end test of whether particular change matches species */								}	/* end search through each step */							}	/* end search for unchanged taxa */						}					if (d<tree[sp-notu][0])	{						evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					/* now make sure that there was change */					for (c=0; c<notu; ++c)	{						if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;						invmatrix[ch][c]=matrix[c][ch];						}					}	/* end routine for clade */				}	/** END ROUTINE FOR ORDERED MULTISTATES **/			/* Unordered Multistate Characters */			else if (ctype[ch]==1)	{				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);					ev=1;					}									else if (sp>notu)	{					evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);					/* make sure that there is change */					for (a=1; a<=tree[sp-notu][0]; ++a)	{						sp2=tree[sp-notu][a];						if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{							if (invmatrix[ch][sp2]!=matrix[sp2][ch])	{								invmatrix[ch][sp2]=matrix[sp2][ch];								ev=1;								}							}						}					}	/* end unordered change for a clade */					/* if change is made, tally */				}	/* end unordered change */			/* if ev = 1, then there has been a change.  Tally it */			if (ev==1)	{				cmp=nu_comp(nstates, notu, matrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);				if (cmp<tcomp)	{					++trial;/*					printf("Try %d, trial %d\n",trying,trial);	/* DEBUGGING CODE 2011-02-02	*/					for (sp=0; sp<notu; ++sp)	invmatrix[ch][sp]=matrix[sp][ch]=lch[sp];//					--deltas;					}				/* register change, etc., only if we are keeping it	*/				else	{/*					trial=0;	*/					++deltas;					taxachange[ch][steps[ch]]=sp;					if (ch<0 || ch>=nchars)						printf("out of bounds at %d steps with character %d\n",deltas,ch);					if (steps[ch]<0 || steps[ch]>=mxdel)						printf("out of bounds at %d steps for character %d\n",steps[ch],ch);					++steps[ch];					if (steps[ch]==mxdel)	removefromivector(availablech,ch,&avch);					++mpd[sp];					}				}			/* if we are three steps removed from the the right compatibility, reboot */			if (trial==maxtrial)	{/*				printf("Try %d\n",trying);	/* DEBUGGING CODE 2011-02-07	*/				reboot = 0;				clearivector(mpd,nodes+notu,0);				clearivector(steps,nchars,0);/*				clearivector(der,nchars,0);	*/				}			if (cmp==tcomp)	reboot=1;			}	/* end additional steps */		}	}	/* end search for matrix with compatibility tcmp *//* 2011-02-10: found an error for Ordovician Echinoids that is revealed here: something gets overwritten!	*///free_ivector(der);//free_ivector(aptaxa);free_ivector(mpd);										/* free vector recording branch lengths in changes		*/free_ivector(trpd);										/* free vector recording branch lengths	in ancestors	*/free_ivector(steps);									/* free vector recording steps per character			*/free_ivector(availablech);								/* free vector recording characters that can change		*/free_ivector(availablebr);								/* free vector recording branches that can change		*/free_ivector(branches);									/* free vector recording branches						*/free_ivector(sychos);									/* free vector recording dependent characters			*//*free_ivector(missing);									/* 2011-03-31: # missing or inapplicable taxa for a character	*/if (mxdp>1)	free_imatrix(sychomat,nchars,nchars);	/* START HERE	*/free_imatrix(taxachange,10*nchars, 10*mxdel);			/* free matrix tallying changes */free_lmatrix(invmatrix,nchars, notu);return matrix;}/* evolvetocompatdelt - evolves a matrix until it reaches a particular compatibility.  Gaps and missing are kept in place *//* Requires:   tree - a matrix containing members of each node, with daughter nodes given a number of OTUs+node#;		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[OTUs-1]) gives it for species;			the second line (tree[OTUs]) gives it for internal nodes;	tcomp - compatibility that must be evolved (usually based on observed compatibility);	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	maxch - the maximum number of changes for each character;	depend - array giving character dependency (if depend[a]=a then it is independent);	comptype - 0 for normal compatibility, 1 for hierarchical compatibility;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;/* Returns:	matrix - a matrix with compatibility = tcomp;*******************************************************************************************************************************************/long **evolvetocompatdelt(long **tree, int tcomp, int notu, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int *depend, int comptype, int UNKNOWN, int INAP, int /*&*/deltas){int		a, b, c, d, br, ch, sc, ev, flip, sp, sp2, cmp;int		avnodes, nodes, mxdel, ttlbr, mxdp=1, avch, avbr;int		reboot, trial;int		lch[1000];int		*availablech, *availablebr, *branches, *steps, *trpd, *mpd, *der, *aptaxa, *sychos;int		**taxachange, **sychomat;/*, **descnodes;	/* for debugging */long	**invmatrix;/* find the number of nodes and their diversities */nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}mpd=ivector(nodes+notu);					/* morphologic changes along each branch */steps=ivector(nchars);						/* number of times each character changes */der=ivector(nchars);						/* number of taxa with derived condition for each character */sychos=ivector(nchars);						/* number of dependendent characters attached to a character *//*dummy=lvector(nchars);						/* character vector prior to change */trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character */for (ch=0; ch<nchars; ++ch)	++sychos[depend[ch]];	/* sychos[x] gives the number of characters dependent on x; if 0 then character is dependent */mxdp=maxiarray(sychos,nchars);						/* b will be the maximum number of dependent characters for any character */if (mxdp>1)	{	sychomat=imatrix(nchars,mxdp);	clearivector(sychos,nchars,0);	for (ch=0; ch<nchars; ++ch)	{		sychomat[depend[ch]][sychos[depend[ch]]]=ch;		++sychos[depend[ch]];		}	}/*descnodes=descendantnodes(tree,notu);	*//*nodestates=lmatrix(nodes,nchars);	*/trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	/* check tomake sure that this shouldn't be tree[nodes][sp]	*/	trpd[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	}	if (ttlbr<mxdel)	mxdel=ttlbr;/*if (ttltx<mxdel)	mxdel=ttltx;	/* 2014-03-21: we allow only as many changes as there are taxa that have changes	*//* allocate memory for arrays containing branches needing changes */availablech=ivector(nchars);availablebr=ivector(ttlbr);branches=ivector(ttlbr);taxachange=imatrix(10*nchars, 10*mxdel);	/* gives taxa that change for character */invmatrix=lmatrix(nchars, notu);aptaxa=applicabletaxa(matrix, nchars, notu, INAP);/******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********/	reboot=0;while (reboot==0)	{	/* determine appropriate branches for changes - all nodes & species without sampled descendants */	/* we'll ignore the basal node, assuming that it is all 0's */	avnodes=b=0;	for (a=1; a<nodes; ++a)	{		avnodes=avnodes+trpd[a+notu];		for (c=0; c<trpd[a+notu]; ++c)	{			availablebr[b]=a+notu;			++b;			}		}	for (a=0; a<notu; ++a)	{		for (c=0; c<trpd[a]; ++c)	{			availablebr[b]=a;			++b;			}		}	/* clear matrix */	for (ch=0; ch<nchars; ++ch)	{		for (a=0; a<notu; ++a)	{			if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{				matrix[a][ch]=0;				}			invmatrix[ch][a]=matrix[a][ch];	/* for debugging */			}		}	clearivector(steps,nchars,0);	clearivector(mpd,notu+nodes,0);		/* 2014-03-19: mpd gives branch length in changes: this must be zero at the outset	*/	clearimatrix(taxachange,nchars,mxdel,0);	deltas=0;	/* Step #2: make sure that each apomorphic species has a derivation */	ensure_apomorphies(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);	deltas=sumivector(steps,nchars);		/* Step 1: Make sure each state is derived for each character */	ensure_charstates(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);	deltas=sumivector(steps,nchars);	/* Step #3: DO ADDITIONAL STEPS NOW */	trial=0;	cmp=nu_comp(nstates, notu, matrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);		if (cmp>tcomp)	{		avch=0;		/* all characters that still can change go into availablech	*/		for (ch=0; ch<nchars; ++ch)	{			if ((ctype[ch]==1 && steps[ch]<maxch[ch]) || (ctype==0 && steps[ch]>(notu/2)))	{				availablech[avch]=ch;				++avch;				}			}		for (deltas=deltas; trial < 3 && cmp!=tcomp; deltas=deltas)	{			/* first choose a character */			c=(int)((double)rand() / ((double)RAND_MAX + 1) * avch);			ch=availablech[c];						for (sp=0; sp<notu; ++sp)	lch[sp]=matrix[sp][ch];		/* record matrix as it was	*/			/**************************************************************************/			/* now, find available branches for this character	*/			avbr=0;			for (br=0; br<ttlbr; ++br)	{/*				htu=availablebr[br];			/* THIS WAS MISSING!!!! 2011-10-31	*/				/* ugh: I do not know what is up here.  I think that an htu variable is needed	*/				if ((br<notu && trpd[br]>0) && (matrix[br][ch]!=UNKNOWN && matrix[br][ch]!=INAP))	{					for (a=0; a<trpd[br]; ++a)	{						branches[avbr]=br;						++avbr;						}					}				else if (br>=notu)	{					/* for each node, make sure that at least one species has this character observed	*/					d=0;	/* becomes 1 when clade is scored	*/					for (sc=1; sc<=tree[br-notu][0] && d==0; ++sc)	{						sp=tree[br-notu][sc];						if (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP)	d=1;						}					if (d==1)	{						for (a=0; a<trpd[br]; ++a)	{							branches[avbr]=br;							++avbr;							}						}	/* end adding clade to available branches	*/					}	/* end test to see whether clade is among available branches	*/				}	/* end compiling of available branches for character ch	*/						/* remove branches where there already has been change	*/			for (a=0; a<steps[ch]; ++a)	{				sp=taxachange[ch][a];				removefromivector(branches,sp,&avbr);				}						br=(int)((double)rand() / ((double)RAND_MAX +1) * avbr);			sp=branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=avbr)	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * avbr);				sp = branches[br];				}			ev=0;				/* will become 1 if change is registered	*/			if (nstates[ch]==2)	{				/* routine for binary characters */				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);					ev=1;		/* change is registered						*/					}				/* routine for clade */				else if (sp>=notu)	{					evolvebinaryinclade(tree[sp-notu],matrix,ch);					for (a=1; a<=tree[sp-notu][0]; ++a)	{						sp2=tree[sp-notu][a];						if (invmatrix[ch][sp2]!=matrix[sp2][ch])							ev=1;		/* change is registered				*/						invmatrix[ch][sp2]=matrix[sp2][ch];						}						}	/* end routine for clade */				}			/* Ordered Multistates */			else if (ctype[ch]==0)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])						flip=1;				else									flip=-1;								/* routine for species */				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;					if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;					else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;					ev=1;		/* change is registered						*/					}				/* routine for clade */				else if (sp>=notu)	{					/* make sure that not all descendants have already changed! */					d=0;					for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{						sp2=tree[sp-notu][sc];						if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;						else	{							for (c=0; c<steps[ch]; ++c)	{								if (taxachange[ch][c]==sp2)	{									++d;									c=steps[ch];									}	/* end test of whether particular change matches species */								}	/* end search through each step */							}	/* end search for unchanged taxa */						}					if (d<tree[sp-notu][0])	{						evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					/* now make sure that there was change */					for (c=0; c<notu; ++c)	{						if (invmatrix[ch][c]!=matrix[c][ch])							ev=1;		/* change is registered				*/						invmatrix[ch][c]=matrix[c][ch];						}					}	/* end routine for clade */				}	/** END ROUTINE FOR ORDERED MULTISTATES **/			/* Unordered Multistate Characters */			else if (ctype[ch]==1)	{				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);					ev=1;		/* change is registered						*/					}									else if (sp>notu)	{					evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);					/* make sure that there is change */					for (a=1; a<=tree[sp-notu][0]; ++a)	{						sp2=tree[sp-notu][a];						if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{							if (invmatrix[ch][sp2]!=matrix[sp2][ch])	{								invmatrix[ch][sp2]=matrix[sp2][ch];								ev=1;		/* change is registered				*/								}							}						}					}	/* end unordered change for a clade */					/* if change is made, tally */				}	/* end unordered change */			/* if ev = 1, then there has been a change.  Tally it */			if (ev==1)	{				cmp=nu_comp(nstates, notu, matrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);				if (cmp<tcomp)	{					++trial;					for (sp=0; sp<notu; ++sp)	invmatrix[ch][sp]=matrix[sp][ch]=lch[sp];					}				else	{					trial=0;					++deltas;					taxachange[ch][steps[ch]]=sp;					if (ch<0 || ch>=nchars)						printf("out of bounds at %d steps with character %d\n",deltas,ch);					if (steps[ch]<0 || steps[ch]>=mxdel)						printf("out of bounds at %d steps for character %d\n",steps[ch],ch);					++steps[ch];					if (steps[ch]==mxdel)	removefromivector(availablech,ch,&avch);					++mpd[sp];					}				}			/* if we are three steps removed from the the right compatibility, reboot */			if (trial==3)	{				reboot = 0;				clearivector(mpd,nodes+notu,0);				clearivector(steps,nchars,0);				clearivector(der,nchars,0);				}			if (cmp==tcomp)	reboot=1;			}	/* end additional steps */		}	}	/* end search for matrix with compatibility tcmp */free_ivector(der);free_ivector(mpd);free_ivector(trpd);free_ivector(steps);free_ivector(availablech);free_ivector(availablebr);free_ivector(branches);free_ivector(aptaxa);free_ivector(sychos);if (mxdp>1)	free_imatrix(sychomat,nchars,nchars);	/* START HERE	*/free_imatrix(taxachange,10*nchars,mxdel);free_lmatrix(invmatrix,nchars, notu);return matrix;}/* evolvetocompatsavesteps - evolves a matrix until it reaches a particular compatibility, saving the character's steps.  Gaps and missing are kept in place *//* Requires:   tree - a matrix containing members of each node, with daughter nodes given a number of OTUs+node#;		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[OTUs-1]) gives it for species;			the second line (tree[OTUs]) gives it for internal nodes;	tcomp - compatibility that must be evolved (usually based on observed compatibility);	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	maxch - the maximum number of changes for each character;	chsteps - array giving number of steps per character;	depend - array giving character dependency (if depend[a]=a then it is independent);	comptype - 0 for normal compatibility, 1 for hierarchical compatibility;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;/* Returns:	matrix - a matrix with compatibility = tcomp;*******************************************************************************************************************************************/long **evolvetocompatsavessteps(long **tree, int tcomp, int notu, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int *depend, int *chsteps, int comptype, int UNKNOWN, int INAP){int		a, b, c, d, br, ch, sc, ev, flip, sp, sp2, cmp;int		avnodes, nodes, deltas, mxdel, ttlbr, mxdp=1, avch, avbr;int		reboot, trial;int		lch[1000];int		*availablech, *availablebr, *branches, *trpd, *mpd, *der, *aptaxa, *sychos;int		**taxachange, **sychomat;/*, **descnodes;	/* for debugging */long	**invmatrix;/* find the number of nodes and their diversities */nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}mpd=ivector(nodes+notu);					/* morphologic changes along each branch */der=ivector(nchars);						/* number of taxa with derived condition for each character */sychos=ivector(nchars);						/* number of dependendent characters attached to a character */trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character */for (ch=0; ch<nchars; ++ch)	++sychos[depend[ch]];	/* sychos[x] gives the number of characters dependent on x; if 0 then character is dependent */mxdp=maxiarray(sychos,nchars);						/* b will be the maximum number of dependent characters for any character */if (mxdp>1)	{	sychomat=imatrix(nchars,mxdp);	clearivector(sychos,nchars,0);	for (ch=0; ch<nchars; ++ch)	{		sychomat[depend[ch]][sychos[depend[ch]]]=ch;		++sychos[depend[ch]];		}	}/*descnodes=descendantnodes(tree,notu);	*//*nodestates=lmatrix(nodes,nchars);	*/trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	/* check tomake sure that this shouldn't be tree[nodes][sp]	*/	trpd[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	}	if (ttlbr<mxdel)	mxdel=ttlbr;/*if (ttltx<mxdel)	mxdel=ttltx;	/* 2014-03-21: we allow only as many changes as there are taxa that have changes	*//* allocate memory for arrays containing branches needing changes */availablech=ivector(nchars);availablebr=ivector(ttlbr);branches=ivector(ttlbr);taxachange=imatrix(10*nchars, 10*mxdel);	/* gives taxa that change for character */invmatrix=lmatrix(nchars, notu);aptaxa=applicabletaxa(matrix, nchars, notu, INAP);/******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********/reboot=0;while (reboot==0)	{	/* determine appropriate branches for changes - all nodes & species without sampled descendants */	/* we'll ignore the basal node, assuming that it is all 0's */	avnodes=b=0;	for (a=1; a<nodes; ++a)	{		avnodes=avnodes+trpd[a+notu];		for (c=0; c<trpd[a+notu]; ++c)	{			availablebr[b]=a+notu;			++b;			}		}	for (a=0; a<notu; ++a)	{		for (c=0; c<trpd[a]; ++c)	{			availablebr[b]=a;			++b;			}		}	/* clear matrix */	for (ch=0; ch<nchars; ++ch)	{		for (a=0; a<notu; ++a)	{			if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{				matrix[a][ch]=0;				}			invmatrix[ch][a]=matrix[a][ch];	/* for debugging */			}		}	clearivector(chsteps,nchars,0);	clearimatrix(taxachange,nchars,mxdel,0);	deltas=0;	/* Step #2: make sure that each apomorphic species has a derivation */	ensure_apomorphies(matrix, invmatrix, taxachange, nstates, ctype, maxch, chsteps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);	deltas=sumivector(chsteps,nchars);		/* Step 1: Make sure each state is derived for each character */	ensure_charstates(matrix, invmatrix, taxachange, nstates, ctype, maxch, chsteps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);	deltas=sumivector(chsteps,nchars);	/* Step #3: DO ADDITIONAL STEPS NOW */	trial=0;	cmp=nu_comp(nstates, notu, matrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);		if (cmp>tcomp)	{		avch=0;		/* all characters that still can change go into availablech	*/		for (ch=0; ch<nchars; ++ch)	{			if ((ctype[ch]==1 && chsteps[ch]<maxch[ch]) || (ctype==0 && chsteps[ch]>(notu/2)))	{				availablech[avch]=ch;				++avch;				}			}		for (deltas=deltas; trial < 3 && cmp!=tcomp; deltas=deltas)	{			/* first choose a character */			c=(int)((double)rand() / ((double)RAND_MAX + 1) * avch);			ch=availablech[c];						for (sp=0; sp<notu; ++sp)	lch[sp]=matrix[sp][ch];		/* record matrix as it was	*/			/**************************************************************************/			/* now, find available branches for this character	*/			avbr=0;			for (br=0; br<ttlbr; ++br)	{				if ((br<notu && trpd[br]>0) && (matrix[br][ch]!=UNKNOWN && matrix[br][ch]!=INAP))	{					for (a=0; a<trpd[br]; ++a)	{						branches[avbr]=br;						++avbr;						}					}				else if (br>=notu)	{					/* for each node, make sure that at least one species has this character observed	*/					d=0;	/* becomes 1 when clade is scored	*/					for (sc=1; sc<=tree[br-notu][0] && d==0; ++sc)	{						sp=tree[br-notu][sc];						if (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP)	d=1;						}					if (d==1)	{						for (a=0; a<trpd[br]; ++a)	{							branches[avbr]=br;							++avbr;							}						}	/* end adding clade to available branches	*/					}	/* end test to see whether clade is among available branches	*/				}	/* end compiling of available branches for character ch	*/						/* remove branches where there already has been change	*/			for (a=0; a<chsteps[ch]; ++a)	{				sp=taxachange[ch][a];				removefromivector(branches,sp,&avbr);				}						br=(int)((double)rand() / ((double)RAND_MAX +1) * avbr);			sp=branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=avbr)	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * avbr);				sp = branches[br];				}			ev=0;			if (nstates[ch]==2)	{				/* routine for binary characters */				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);					ev=1;					}				/* routine for clade */				else if (sp>=notu)	{					evolvebinaryinclade(tree[sp-notu],matrix,ch);					for (a=1; a<=tree[sp-notu][0]; ++a)	{						sp2=tree[sp-notu][a];						if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;						invmatrix[ch][sp2]=matrix[sp2][ch];						}						}	/* end routine for clade */				}			/* Ordered Multistates */			else if (ctype[ch]==0)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])						flip=1;				else									flip=-1;								/* routine for species */				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;					if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;					else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;					ev=1;					}				/* routine for clade */				else if (sp>=notu)	{					/* make sure that not all descendants have already changed! */					d=0;					for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{						sp2=tree[sp-notu][sc];						if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;						else	{							for (c=0; c<chsteps[ch]; ++c)	{								if (taxachange[ch][c]==sp2)	{									++d;									c=chsteps[ch];									}	/* end test of whether particular change matches species */								}	/* end search through each step */							}	/* end search for unchanged taxa */						}					if (d<tree[sp-notu][0])	{						evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					/* now make sure that there was change */					for (c=0; c<notu; ++c)	{						if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;						invmatrix[ch][c]=matrix[c][ch];						}					}	/* end routine for clade */				}	/** END ROUTINE FOR ORDERED MULTISTATES **/			/* Unordered Multistate Characters */			else if (ctype[ch]==1)	{				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);					ev=1;					}									else if (sp>notu)	{					evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);					/* make sure that there is change */					for (a=1; a<=tree[sp-notu][0]; ++a)	{						sp2=tree[sp-notu][a];						if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{							if (invmatrix[ch][sp2]!=matrix[sp2][ch])	{								invmatrix[ch][sp2]=matrix[sp2][ch];								ev=1;								}							}						}					}	/* end unordered change for a clade */					/* if change is made, tally */				}	/* end unordered change */			/* if ev = 1, then there has been a change.  Tally it */			if (ev==1)	{				cmp=nu_comp(nstates, notu, matrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);				if (cmp<tcomp)	{					++trial;					for (sp=0; sp<notu; ++sp)	invmatrix[ch][sp]=matrix[sp][ch]=lch[sp];					}				else	{					trial=0;					++deltas;					taxachange[ch][chsteps[ch]]=sp;					if (ch<0 || ch>=nchars)						printf("out of bounds at %d steps with character %d\n",deltas,ch);					if (chsteps[ch]<0 || chsteps[ch]>=mxdel)						printf("out of bounds at %d steps for character %d\n",chsteps[ch],ch);					++chsteps[ch];					if (chsteps[ch]==mxdel)	removefromivector(availablech,ch,&avch);					++mpd[sp];					}				}			/* if we are three steps removed from the the right compatibility, reboot */			if (trial==3)	{				reboot = 0;				clearivector(mpd,nodes+notu,0);				clearivector(chsteps,nchars,0);				clearivector(der,nchars,0);				}			if (cmp==tcomp)	reboot=1;			}	/* end additional steps */		}	}	/* end search for matrix with compatibility tcmp */free_ivector(der);free_ivector(mpd);free_ivector(trpd);free_ivector(availablech);free_ivector(availablebr);free_ivector(branches);free_ivector(aptaxa);free_ivector(sychos);if (mxdp>1)	free_imatrix(sychomat,nchars,nchars);	/* START HERE	*/free_imatrix(taxachange,10*nchars,mxdel);free_lmatrix(invmatrix,nchars, notu);return matrix;}/* Evolves a single character given a rate, a tree and a matrix, leaving the rest of the matrix in tact/* Returns a matrix for notu taxa with nchars characters.  Gaps and missing are kept in place./* Requires:	charn - the character in question.	pi - the per branch rate of character change (a real number).	tree - a matrix containing members of each node (with ALL species belonging to the clade);		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[notu-1]) gives it for species;			the second line (tree[notu]) gives it for internal nodes;	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/long **EvolveCharacterRate(int charn, double pi, long **tree, int notu, long **matrix, int *nstates, int *ctype, int *bias, int UNKNOWN, int INAP){int		a, b, c, d, st, sc, ttlbr;int		flip, sp, sp2, nodes, branches;int		*available, *unord, *undum, *trpd, *change;long	*character;/* find the number of nodes and their diversities */nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}/* allocate memory for branch lengths */trpd=ivector(nodes+notu);/* allocate memory for arrays to be used for unordered multistates */unord=ivector(nstates[charn]);undum=ivector(nstates[charn]);trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	/* check tomake sure that this shouldn't be tree[nodes][sp]	*/	trpd[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	}/* allocate memory for arrays containing branches needing changes */available=ivector(ttlbr);/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */b=0;for (a=1; a<nodes; ++a)	{	for (c=0; c<trpd[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		available[b]=a;		++b;		}	}/* allocate memory for branches that do change */change=ivector(b);branches=0;for (a=0; a<b; ++a)	{	c=(int)((double)rand() / ((double)RAND_MAX + 1) * 10000);	if (c<(pi*10000))	{		change[branches]=available[a];		++branches;		}	}/* allocate character array and clear it */character=lvector(notu);for (a=0; a<notu; ++a)	{	if (matrix[a][charn]!=INAP && matrix[a][charn]!=UNKNOWN)	{		character[a]=0;		}	else	character[a]=matrix[a][charn];	}/* now, make changes */for (d=0; d<branches; ++d)	{	sp=change[d];	/* routine for binary characters */	if (nstates[charn]==2)	{		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			if (character[sp]==0)	character[sp]=1;			else					character[sp]=0;			}	/* end binary change for species */		/* routine for clade */		else	{			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))	{					if (character[sp]==0)	character[sp2]=1;					else					character[sp2]=0;					}				}	/* end binary change for species within clade */			}	/* end binary change for clade */		}	/* end routine for binary characters */			/** routine for unordered multistate **/	else if (ctype[charn]==1)	{		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			for (b=character[sp]; b==character[sp]; b=b)	{				b=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[charn]);				}			character[sp]=b;			}	/* end unordered multistate change for species */		/* routine for clade */		else	{			/* first create an array stating which states change to which 	*/			for (a=0; a<nstates[charn]; ++a)	undum[a]=0;			/* now come up with new transitions for this clade 				*/			for (a=0; a<nstates[charn]; ++a)	{				b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[charn]-a));				unord[a]=undum[b];				/* do not let unord[a]==a */				while (unord[a]==a || a>=nstates[charn])	{					b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[charn]-a));					unord[a]=undum[b];					}				/* unord[0] cannot be a (otherwise we wouldn't have this problem */				/* therefore, flip-flop unord[0] and unord[a] */				if (unord[a]==a && a==(nstates[charn]-1))	{					unord[a]=unord[0];					unord[0]=a;					}									/* remove assigned state from possibilities */				for (c=b; c<nstates[charn]; ++c)					undum[c]=undum[c+1];				/* reboot if the final possible state matches original */				if (a==(nstates[charn]-2) && (a+1)==undum[0])	{					a=-1;	/* will increment to 0*/					for (b=0; b<nstates[charn]; ++b)	undum[b]=b;					}				}	/* end assignment of state changes */						/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))					character[sp2]=unord[character[sp2]];				}	/* end unordered multistate change for species within clade */			}	/* end unordered multistate change within clade */		}	/* end routine for unordered multistate characters */			/** routine for ordered multistate **/	else if (ctype[charn]==0)	{		/* determine whether state increases or decreases */		for (flip=-1; flip<0 || flip>99; flip=flip)	{			flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);			}		if (flip<bias[charn])	flip=1;		else				flip=-1;		/* routine for species */		if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{			character[sp]=character[sp]+flip;			}	/* end ordered multistate change for species */		/* routine for clade */		else	{			/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))					character[sp2]=character[sp2]+flip;				}	/* end ordered multistate change for species within clade */			}	/* end ordered multistate change within clade */				/* Now, make sure that the lowest value is 0, not -1 or 1 */		st=nstates[charn];		for (a=0; a<notu; ++a) {			if (character[a]<st)	st=character[a];			}		if (st!=0)	{			for (a=0; a<notu; ++a) {				character[a]=character[a]-st;				}			}		}	/* end routine for ordered multistate characters */	}for (sp=0; sp<notu; ++sp)	matrix[sp][charn]=character[sp];free_ivector(trpd);free_ivector(available);free_ivector(unord);free_ivector(undum);free_ivector(change);free_lvector(character);return matrix;}/* Evolves a single character vector given a number of steps (N), a tree (tree) and information about a character (states, ordering, etc.)/* Returns a vector of length notu (number of taxa), with gaps and missing are kept in place.  This can be integrated back into a notu x nchar matrix.  /* Requires:	N - the per branch rate of character change (a real number).	tree - a matrix containing members of each node (with ALL species belonging to the clade);		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[notu-1]) gives it for species;			the second line (tree[notu]) gives it for internal nodes;	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/long *evolvecharacterNsteps(long **tree, int N, int notu, long *chvector, int nstates, int ctype, int bias, int UNKNOWN, int INAP){int		a, b, c, d, st, sc, ttlbr;int		flip, sp, sp2, nodes, branches;int		*available, *unord, *undum, *trpd, *change;/* find the number of nodes and their diversities */nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}/* 2010-01-18: Removed so that you can do one step at a time, keeping track as you go		*//* Here after, remember to clear the vector prior to this routine							*//*for (a=0; a<notu; ++a)	if (chvector[a]!=UNKNOWN && chvector[a]!=INAP)	chvector[a]=0;	*//* allocate memory for branch lengths */trpd=ivector(nodes+notu);/* allocate memory for arrays to be used for unordered multistates */if (nstates>2 && ctype==1)	{	unord=ivector(nstates);	undum=ivector(nstates);	}trpd[notu]=0;for (sp=0; sp<notu; ++sp)	{	/* check tomake sure that this shouldn't be tree[nodes][sp]	*/	trpd[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors */	}/* allocate memory for arrays containing branches needing changes */ttlbr=branchnumber(tree,notu);available=ivector(2*ttlbr);		/* this should not be necessary	*//* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */b=0;for (a=1; a<nodes; ++a)	{	for (c=0; c<trpd[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		available[b]=a;		++b;		}	}/* allocate memory for branches that do change */change=ivector(N);b=branches=0;for (a=0; a<N; ++a)	{	c=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-b));	sp=available[c];	if (sp>notu)	{		/* make sure that some members of the clade are scored, rather than all missing / inap	*/		d=0;		for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{			sp2=tree[sp-notu][sc];			if (chvector[sp2]!=UNKNOWN && chvector[sp2]!=INAP)	{				++d;				sc=tree[sp-notu][0];				}			/* if there are any species scored as having the character, then use this clade	*/			if (d>0)	{				change[branches]=sp;				b=b+trpd[change[branches]];				++branches;				}			else	--a;			}		}	else if (sp<notu)	{		if (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP)	{			change[branches]=sp;			b=b+trpd[change[branches]];			++branches;			}		else	--a;		}	removefromivector(available,sp,&ttlbr);	}/* now, make changes */for (d=0; d<N; ++d)	{	sp=change[d];	/* routine for binary characters */	if (nstates==2)	{		/* routine for species */		if (sp<notu && (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP))	{			chvector[sp]=swap(chvector[sp]);			}	/* end binary change for species */		/* routine for clade */		else	{			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (chvector[sp2]!=UNKNOWN && chvector[sp2]!=INAP))	{					chvector[sp2]=swap(chvector[sp2]);					}				}	/* end binary change for species within clade */			}	/* end binary change for clade */		}	/* end routine for binary characters */			/** routine for unordered multistate **/	else if (ctype==1)	{		/* routine for species */		if (sp<notu && (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP))	{			for (b=chvector[sp]; b==chvector[sp]; b=b)				b=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates);			chvector[sp]=b;			}	/* end unordered multistate change for species */		/* routine for clade */		else	{			/* first create an array stating which states change to which 	*/			for (a=0; a<nstates; ++a)	undum[a]=a;			/* now come up with new transitions for this clade 				*/			for (a=0; a<nstates; ++a)	{				b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates-a));				unord[a]=undum[b];				/* do not let unord[a]==a */				while (unord[a]==a || a>=nstates)	{					b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates-a));					unord[a]=undum[b];					}				/* unord[0] cannot be a (otherwise we wouldn't have this problem */				/* therefore, flip-flop unord[0] and unord[a] */				if (unord[a]==a && a==(nstates-1))	{					unord[a]=unord[0];					unord[0]=a;					}									/* remove assigned state from possibilities */				for (c=b; c<nstates; ++c)					undum[c]=undum[c+1];				/* reboot if the final possible state matches original */				if (a==(nstates-2) && (a+1)==undum[0])	{					a=-1;	/* will increment to 0*/					for (b=0; b<nstates; ++b)	undum[b]=b;					}				}	/* end assignment of state changes */						/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (chvector[sp2]!=UNKNOWN && chvector[sp2]!=INAP))					chvector[sp2]=unord[chvector[sp2]];				}	/* end unordered multistate change for species within clade */			}	/* end unordered multistate change within clade */		}	/* end routine for unordered multistate characters */			/** routine for ordered multistate **/	else if (ctype==0)	{		/* determine whether state increases or decreases */		for (flip=-1; flip<0 || flip>99; flip=flip)	{			flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);			}		if (flip<bias)	flip=1;		else				flip=-1;		/* routine for species */		if (sp<notu && (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP))	{			chvector[sp]=chvector[sp]+flip;			}	/* end ordered multistate change for species */		/* routine for clade */		else	{			/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (chvector[sp2]!=UNKNOWN && chvector[sp2]!=INAP))					chvector[sp2]=chvector[sp2]+flip;				}	/* end ordered multistate change for species within clade */			}	/* end ordered multistate change within clade */				/* Now, make sure that the lowest value is 0, not -1 or 1 */		st=nstates;		for (a=0; a<notu; ++a) {			if (chvector[a]<st)	st=chvector[a];			}		if (st!=0)	{			for (a=0; a<notu; ++a) {				chvector[a]=chvector[a]-st;				}			}		}	/* end routine for ordered multistate characters */	}free_ivector(trpd);free_ivector(available);free_ivector(change);if (nstates>2 && ctype==1)	{	free_ivector(unord);	free_ivector(undum);	}return chvector;}/* Evolves a single character vector given a number of steps (N), a tree (tree) and information about a character (states, ordering, etc.)/* Returns a vector of length notu (number of taxa), with gaps and missing are kept in place.  This can be integrated back into a notu x nchar matrix.  /* Requires:	N - the per branch rate of character change (a real number).	tree - a matrix containing members of each node (with ALL species belonging to the clade);		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[notu-1]) gives it for species;			the second line (tree[notu]) gives it for internal nodes;	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/long *evolvecharacterNstepsovertime(long **tree, int N, int notu, long *chvector, int nstates, int ctype, int bias, int UNKNOWN, int INAP){int		a, b, c, d, st, sc, ttlbr;int		flip, sp, sp2, nodes, branches;int		*available, *unord, *undum, *trpd, *change;/* find the number of nodes and their diversities */nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}for (a=0; a<notu; ++a)	if (chvector[a]!=UNKNOWN && chvector[a]!=INAP)	chvector[a]=0;/* allocate memory for branch lengths */trpd=ivector(nodes+notu);/* allocate memory for arrays to be used for unordered multistates */if (nstates>2 && ctype==1)	{	unord=ivector(nstates);	undum=ivector(nstates);	}trpd[notu]=0;for (sp=0; sp<notu; ++sp)	{	/* check tomake sure that this shouldn't be tree[nodes][sp]	*/	trpd[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors */	}/* allocate memory for arrays containing branches needing changes */ttlbr=branchnumber(tree,notu);available=ivector(ttlbr);/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */b=0;for (a=1; a<nodes; ++a)	{	for (c=0; c<trpd[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		available[b]=a;		++b;		}	}/* allocate memory for branches that do change */change=ivector(N);b=branches=0;for (a=0; a<N; ++a)	{	c=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-b));	sp=available[c];	if (sp>notu)	{		/* make sure that some members of the clade are scored, rather than all missing / inap	*/		d=0;		for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{			sp2=tree[sp-notu][sc];			if (chvector[sp2]!=UNKNOWN && chvector[sp2]!=INAP)	{				++d;				sc=tree[sp-notu][0];				}			/* if there are any species scored as having the character, then use this clade	*/			if (d>0)	{				change[branches]=sp;				b=b+trpd[change[branches]];				++branches;				}			else	--a;			}		}	else if (sp<notu)	{		if (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP)	{			change[branches]=sp;			b=b+trpd[change[branches]];			++branches;			}		else	--a;		}/*	removefromivector(available,sp,&ttlbr);	*/		for (sc=c; sc<ttlbr-1; ++sc)	{		available[sc]=available[sc+1];		}	--ttlbr;	available[ttlbr]=0;	}/* now, make changes */for (d=0; d<N; ++d)	{	sp=change[d];	/* routine for binary characters */	if (nstates==2)	{		/* routine for species */		if (sp<notu && (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP))	{			chvector[sp]=swap(chvector[sp]);			}	/* end binary change for species */		/* routine for clade */		else	{			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (chvector[sp2]!=UNKNOWN && chvector[sp2]!=INAP))	{					chvector[sp2]=swap(chvector[sp2]);					}				}	/* end binary change for species within clade */			}	/* end binary change for clade */		}	/* end routine for binary characters */			/** routine for unordered multistate **/	else if (ctype==1)	{		/* routine for species */		if (sp<notu && (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP))	{			for (b=chvector[sp]; b==chvector[sp]; b=b)				b=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates);			chvector[sp]=b;			}	/* end unordered multistate change for species */		/* routine for clade */		else	{			/* first create an array stating which states change to which 	*/			for (a=0; a<nstates; ++a)	undum[a]=a;			/* now come up with new transitions for this clade 				*/			for (a=0; a<nstates; ++a)	{				b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates-a));				unord[a]=undum[b];				/* do not let unord[a]==a */				while (unord[a]==a || a>=nstates)	{					b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates-a));					unord[a]=undum[b];					}				/* unord[0] cannot be a (otherwise we wouldn't have this problem */				/* therefore, flip-flop unord[0] and unord[a] */				if (unord[a]==a && a==(nstates-1))	{					unord[a]=unord[0];					unord[0]=a;					}									/* remove assigned state from possibilities */				for (c=b; c<nstates; ++c)					undum[c]=undum[c+1];				/* reboot if the final possible state matches original */				if (a==(nstates-2) && (a+1)==undum[0])	{					a=-1;	/* will increment to 0*/					for (b=0; b<nstates; ++b)	undum[b]=b;					}				}	/* end assignment of state changes */						/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (chvector[sp2]!=UNKNOWN && chvector[sp2]!=INAP))					chvector[sp2]=unord[chvector[sp2]];				}	/* end unordered multistate change for species within clade */			}	/* end unordered multistate change within clade */		}	/* end routine for unordered multistate characters */			/** routine for ordered multistate **/	else if (ctype==0)	{		/* determine whether state increases or decreases */		for (flip=-1; flip<0 || flip>99; flip=flip)	{			flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);			}		if (flip<bias)	flip=1;		else				flip=-1;		/* routine for species */		if (sp<notu && (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP))	{			chvector[sp]=chvector[sp]+flip;			}	/* end ordered multistate change for species */		/* routine for clade */		else	{			/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (chvector[sp2]!=UNKNOWN && chvector[sp2]!=INAP))					chvector[sp2]=chvector[sp2]+flip;				}	/* end ordered multistate change for species within clade */			}	/* end ordered multistate change within clade */				/* Now, make sure that the lowest value is 0, not -1 or 1 */		st=nstates;		for (a=0; a<notu; ++a) {			if (chvector[a]<st)	st=chvector[a];			}		if (st!=0)	{			for (a=0; a<notu; ++a) {				chvector[a]=chvector[a]-st;				}			}		}	/* end routine for ordered multistate characters */	}free_ivector(trpd);free_ivector(available);free_ivector(change);if (nstates>2 && ctype==1)	{	free_ivector(unord);	free_ivector(undum);	}return chvector;}/* Evolves a single character vector given a number of steps (N), a tree (tree) and information about a character (states, ordering, etc.)/* Returns a vector of length notu (number of taxa), with gaps and missing are kept in place.  This can be integrated back into a notu x nchar matrix.  /* Requires:	N - the per branch rate of character change (a real number).	tree - a matrix containing members of each node (with ALL species belonging to the clade);		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[notu-1]) gives it for species;			the second line (tree[notu]) gives it for internal nodes;	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************//* evolveorderedinclade - evolve multistate characters within a clade;/* Requires:	clade: a vector giving clade members (from a Venn tree), with clade[0] giving the number of members	matrix: the character matrix	ch: the character being changed;	delta: the increment/decrement;	INAP: code for inapplicable characters	UNKNOWN: code for unknown characters*******************************************************************************************************************************************/void evolveorderedinclade(long *clade, long **matrix, int ch, int delta, int INAP, int UNKNOWN){int	s, sp;for (s=1; s<=clade[0]; ++s)	{	sp=clade[s];	if (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN)		matrix[sp][ch]=matrix[sp][ch]+delta;	}}/* multistatevett - make sure that all states in a multistate are between 0 and #states/* Requires:	matrix: character matrix	ch: character number	st: number of states for character ch	notu: number of taxa in the matrix	INAP: code for inapplicables	UNKNOWN: code for unknown*******************************************************************************************************************************************/void multistatevett (long **matrix, int ch, int st, int notu, int INAP, int UNKNOWN){int	s, mn=st, mx=0;for (s=0; s<notu; ++s)	{	while ((matrix[s][ch]==INAP || matrix[s][ch]==UNKNOWN) && s<notu)	++s;	if (s>=notu)	break;		if (matrix[s][ch]>mx)	mx=matrix[s][ch];	if (matrix[s][ch]<mn)	mn=matrix[s][ch];		}/* two possibilities - we lost the initial 0, so 1 becomes the new 0 OR we have to scale up a negative */if (mn!=0)	{	for (s=0; s<notu; ++s)	{		while ((matrix[s][ch]==INAP || matrix[s][ch]==UNKNOWN) && s<notu)	++s;		if (s>=notu)	break;		matrix[s][ch]=matrix[s][ch]-mn;		}	}/* make sure that there are no states too high *//* this might happen if everything got shifted up one and the minimum now is too low *//* note: if there are three states, then the maximum state should be 2 */ else if (mx==st && mn>0)	{	for (s=0; s<notu; ++s)	{		while ((matrix[s][ch]==INAP || matrix[s][ch]==UNKNOWN) && s<notu)	++s;		if (s>=notu)	break;		matrix[s][ch]=matrix[s][ch]-(mx-st);		}	}/* this also might happen if everything got shifted up one and the minimum now is too low */else if (mx==st && mn==0)	{	for (s=0; s<notu; ++s)	{		while ((matrix[s][ch]==INAP || matrix[s][ch]==UNKNOWN) && s<notu)	++s;		if (s>=notu)	break;		/* all species with matrix[s][ch]=st must have just gotten that condition - reverse those to 1 less than the maximum */		if (matrix[s][ch]==mx)	matrix[s][ch]=st-2;		}	}}/* evolveunorderedinclade - evolve unordered character (binary or multistate) within a clade;/*		this works by randomly assigning a descendant state to each state yielding an array of descendant/*		changes.  If a we have a 3 state character and changes[0]=1, changes[1]=2 and changes[2]=0, then/*		all species in the clade that had 0 now will have 1; those with 1 will have 2; etc.  /* Requires:	clade: a vector giving clade members (from a Venn tree), with clade[0] giving the number of members	matrix: the character matrix	ch: the character being changed;	states: the number of states;	INAP: code for inapplicable characters	UNKNOWN: code for unknown characters/* returns:	matrix modified for new states*******************************************************************************************************************************************/void evolveunorderedinclade(long *clade, long **matrix, int ch, int states, int INAP, int UNKNOWN){int	a, b, s, sp, old, flush;int *changes;changes=ivector(states);flush=0;while (flush==0)	{	for (s=0; s<states; ++s)	changes[s]=s;	for (s=0; s<states; ++s)	{		if (changes[s]==s)	{			a=s;			/* we need to make sure that all states change to a new state (no silent substitutions!)			  */			/* Also, every once in a while the random number generator goes screwy and overshoots - do not let it */			while (a==s || (a<0 || a>=states))	{				a=(int)((double)rand() / ((double)RAND_MAX + 1) * states);				}			/* shuffle character states */			b=changes[s];			changes[s]=changes[a];			changes[a]=b;			}		}	/* debugging fun - it seems that sometimes improper numbers creep into this */	flush=1;	for (s=0; s<states; ++s)	{		if (changes[s]>=states || changes[s]<0)	{			flush=0;			s=states;			}		}	}for (s=1; s<=clade[0]; ++s)	{	sp=clade[s];	if (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN)	{		old=matrix[sp][ch];		/* this should not be necessary, but..... */		if (old<0)			old=matrix[sp][ch]=0;		else if (old>=states)			old=matrix[sp][ch]=(states-1);		matrix[sp][ch]=changes[old];		}	}free_ivector(changes);}/* evolvebinaryinclade - evolve unordered character (binary or multistate) within a clade;/* Requires:	clade: a vector giving clade members (from a Venn tree), with clade[0] giving the number of members	matrix: the character matrix	ch: the character being changed;	INAP: code for inapplicable characters	UNKNOWN: code for unknown characters*******************************************************************************************************************************************/void evolvebinaryinclade(long *clade, long **matrix, int ch){int	s, sp;for (s=1; s<=clade[0]; ++s)	{	sp=clade[s];	if (matrix[sp][ch]==0)		matrix[sp][ch]=1;	else if (matrix[sp][ch]==1)	matrix[sp][ch]=0;	}}/* Turns 0 to 1 and 1 to 0; leaves anything else (? or -, hopefully) alone./* Requires:/*	c - the number to swap;/* Returns:/*	c - the new number.*******************************************************************************************************************************************/long swap(long c){if (c==0)		c=1;else if (c==1)	c=0;return c;}/* Turns c to any number from 0 to X (unordered character change)/* Requires:	c - the number to swap;	X - the number of states;*******************************************************************************************************************************************/long mswap(long c, int x){int	i;/*i=((int) ((X-1) * rand() / RAND_MAX));	*/i = (int)((double)rand() / ((double)RAND_MAX + 1) * x);/*if (i>=c && i<(X-1))	++i;		*//*else if (i==(X-1))		i=0;	*/while (i==c || (i<0 || i>=x))	i = (int)((double)rand() / ((double)RAND_MAX + 1) * x);return i;}/* Turns c to c-1 or c+1 (ordered character change)/* Requires:	c - the number to swap;	bias - bias increase/decrease;	this can return -1, so make sure you either want that OR can correct for it!	this also can return values greater than the highest state - make sure you can deal with that!*******************************************************************************************************************************************/long multi(long c, int bias){int	i;	i=((int) (100 * rand() / RAND_MAX));	if (i<bias)	++c;	else		--c;return c;}/* Create a cladistic phylogeny, with no extinction/* Requires:	notu: number of taxa;	tree; the matrix of phylogenetic information;/* Each tree[x][0] gives the number of species in that node;/* Each tree[x][1]..tree[x][i] gives species 1...i in that node, with numbers >=notu being nodes.		Thus, taxon notu is the basal node./* tree[notu-1][0…notu] gives the branch length of each observed taxon /* tree[notu][0…notu] gives the branch length of each ancestral taxon*******************************************************************************************************************************************/long **evolvecladogram(int notu, long **tree){int	a, b, c, sp, nodes;tree[nodes=0][0]=2;tree[nodes][1]=0;tree[nodes][2]=1;for (sp=2; sp<notu; ++sp)	{	a = (int)((double)rand() / ((double)RAND_MAX + 1) * sp);	for (b=0; b<=nodes; ++b)	{		for (c=1; c<=tree[b][0]; ++c)	{			if (a==tree[b][c])	{				++nodes;				tree[b][c]=nodes+notu;				c=tree[nodes][0]=2;				tree[nodes][1]=a;				tree[nodes][2]=sp;				b=nodes;				}			}		}	}for (sp=0; sp<notu; ++sp)	tree[notu-1][sp]=1;for (sp=0; sp<nodes; ++sp)	tree[notu][sp]=1;return tree;}double MinRate(int notu){int	a;double	x, R;x=5*notu;R=1/x;x=1000*R;a=x;x=a;R=x/1000;return R;}double MaxRate(int notu, int MXST){int	a;double	x, y, R;y=3*MXST;x=5*notu;R=y/x;x=1000*R;a=x;x=a;R=x/1000;return R;}/* Routine to count the number of non-zero length branches on a simulated tree/*/*	tree: phylogeny/*	notu: number of species*******************************************************************************************************************************************/int branchnumber(long **tree, int notu){int	sp,nodes,ttlbr;/* find the number of nodes and their diversities */nodes=0;for (sp=0; sp<notu; ++sp)	{	if (tree[sp][0]>1)	++nodes;	else				sp=notu;	}/* find the number of non-zero length branches */ttlbr=0;for (sp=0; sp<notu; ++sp)	{	ttlbr=ttlbr+tree[notu-1][sp];	/* array tree[notu-1] gives branch lengths of species */	}for (sp=1; sp<nodes; ++sp)	{	ttlbr=ttlbr+tree[notu][sp];		/* array tree[notu] gives branch lengths of ancestors */	}return ttlbr;}/* evolveadditivedependent - a routine for evolving a dependent color (e.g., feather color) given an independent/*		character (e.g., feathers present) by first evolving a dependent character with as many "presents"/*		as there are taxa for which the dependent character is applicable/* Requires:/*		charn - the characer number/*		N - number of changes (NOTE: this can be Zero!/*		tree - matrix[i][j] gives the jth member of the ith node/*		notu - number of observed taxa/*		matrix - character state for taxon i, character j/*		nstates - number of states for character k/*		ctype - type (ordered, unordered) for charcter k/*		bias - biased transition for character k/*		UNKNOWN - matrix code for "?"/*		APS - number of otus for which character charn is applicable/* Returns:/*		matrix - original matrix with new character modified.  /************************************************************************************************************/long **evolveadditivedependent(int charn, int N, long **tree, int notu, long **matrix, int *nstates, int *ctype, int *bias, int UNKNOWN, int INAP, int APS){int		a, b, c, d, der, st, sc, br, ttlbr, TtlAp, delta=0;int		flip, sp, sp2, nodes, used;int		*available, *branches, *unord, *undum, *trpd, *change, *derivation, **descnodes;long	*character, *independent, *nodestate, *nodedepnd;/* evolve an independent character that will yield the same number of dependents as real data */nodes=number_of_nodes(tree,notu);trpd=ivector(notu+nodes);for (sp=0; sp<notu; ++sp)	{	/* check tomake sure that this shouldn't be tree[nodes][sp]	*/	trpd[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors	*/	}ttlbr=0;for (sp=0; sp<(notu+nodes); ++sp)	ttlbr=ttlbr+trpd[sp];available=ivector(ttlbr);branches=ivector(ttlbr);independent=lvector(notu);nodestate=lvector(nodes);nodedepnd=lvector(nodes);descnodes=descendantnodes(tree,notu);character=lvector(notu);/* allocate memory for arrays to be used for unordered multistates */unord=ivector(nstates[charn]);undum=ivector(nstates[charn]);/* determine how many branches are available for each taxon and node */a=0;for (sp=0; sp<nodes; ++sp)	{	for (b=0; b<trpd[sp+notu]; ++b)	{		branches[a]=available[a]=sp+notu;		++a;		}	}	for (sp=0; sp<notu; ++sp)	{	for (b=0; b<trpd[sp]; ++b)	{		branches[a]=available[a]=sp;		++a;		}	}derivation=ivector(APS);change=ivector(APS);/* Now, sample from available until APS is reached 						*//* first we will do this with no changes for the dependent character 	*//* a is the number of species changed (reversals, too 					*/delta=used=a=0;for (a=0; a!=APS; a=a)	{	/* if one short, grab a species at random until one can gain in parallel */	if (a==APS-1)	{		b=0;		sp=notu;		/* put something in here to make sure that it does not get stuck */		d=0;		while ((b==0 && sp>=notu) && d<2*notu)	{			sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);			++d;			if (trpd[sp]>0 && independent[sp]==0)	{				b=1;				/* make sure that the species has not already changed */				for (c=0; c<delta; ++c)	{					if (sp==change[c])	{						c=delta;						b=0;						}					}				}			else	sp=notu;			}	/* end search for single species to change */		/* count branches */		for (br=0; sp!=branches[br]; br=br)	++br;		}	/* if one too many, grab a species at random until one can be reversed  */	else if (a==APS+1)	{		b=0;		sp=notu;		/* put something in here to make sure that it does not get stuck */		d=0;		while ((b==0 && sp>=notu) && d<2*notu)	{			sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);			++d;			if (trpd[sp]>0 && independent[sp]==1)	{				b=1;				/* make sure that the species has not already changed */				for (c=0; c<delta; ++c)	{					if (sp==change[c])	{						c=delta;						b=0;						}					}				}			else	sp=notu;			}	/* end search for single species to change */		/* count branches */		for (br=0; sp!=branches[br]; br=br)	++br;		}		else	{		br=ttlbr+1;		while (br<0 || br>=ttlbr)			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));		sp=branches[br];		/* convert random number to a species */		}		used=used+trpd[sp];		/* change the number of taxa from which to sample */		/* remove species (all entries) from possible changes */	for (b=br; b<ttlbr-used; ++b)	{		branches[b]=branches[b+trpd[sp]];		}	branches[b]=-1;		/* make note */	change[delta]=sp;	++delta;	/* if a node, change species within the node */	if (sp>=notu)	{		/* first, modify the node's state - if it goes from 0->1, its a new derivation */		nodestate[sp-notu]=swap(nodestate[sp-notu]);		/* second, update descendant clades of the node (if any) */		for (b=1; b<=descnodes[sp-notu][0]; ++b)	{			sp2=descnodes[sp-notu][b];			nodestate[sp2]=swap(nodestate[sp2]);			}				/* third, change states of species within node */		for (b=1; b<=tree[sp-notu][0]; ++b)	{			sp2=tree[c=sp-notu][b];			independent[sp2]=swap(independent[sp2]);			}		}	/* if a species, then just change the species */	else		independent[sp]=swap(independent[sp]);	/* now find out how many derivations there are */	der=0;	for (b=0; b<delta; ++b)	{		sp=change[b];		if ((sp>=notu && nodestate[sp-notu]==1) || (sp<notu && independent[sp]==1))	{			derivation[der]=sp;			++der;			}		}			/* calculate the number of species that will have secondary traits */	a=0;	for (b=0; b<notu; ++b)	a=a+independent[b];		/* if incorrect number of derived taxa are produced, then try again 			*/	/* if correct number but too few derivations to get # of states, also try again	*/	if ((a>APS || delta==(APS-1)) || (a==APS && der<(nstates[charn]-N)))	{		for (b=0; b<ttlbr; ++b)	branches[b]=available[b];		clearlvector(independent,notu,0);		clearlvector(nodestate,nodes,0);		clearivector(derivation,APS,0);		clearivector(change,APS,0);		a=used=c=delta=der=0;		clearivector(branches,ttlbr,0);		for (sp=0; sp<ttlbr; ++sp)			branches[sp]=available[sp];		}	}	/* end derivation of independent character */	for (sp=0; sp<notu; ++sp)	character[sp]=INAP;for (sp=0; sp<nodes; ++sp)	nodedepnd[sp]=INAP;/* make each derivation its own state	*/for (st=0; st<der; ++st)	{	sp=derivation[st];	/* simple for species */	if (sp<notu)	{		if (st<nstates[charn])	character[sp]=st;		else				character[sp]=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[charn]);		}	/* go through clade - but some species might have lost independent character */	else	{		if (st<nstates[charn])	nodedepnd[sp-notu]=st;		else				nodedepnd[sp-notu]=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[charn]);		for (sp2=1; sp2<=tree[sp-notu][0]; ++sp2)	{			a=tree[sp-notu][sp2];			if (independent[a]==1)	{				if (st<nstates[charn])					character[sp2]=st;				else					character[sp2]=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[charn]);				}			}		}	}if (N>0)	{	/* redo the available species */	clearivector(available,ttlbr,0);	clearivector(branches,ttlbr,0);	/* Now separate branches for change */	/* make sure that it is not one of the derivation branches */	TtlAp=0;	for (sp=0; sp<nodes; ++sp)	{		/* include nodes that have independent states */		if (nodestate[sp]==1)	{			c=0;			/* der gives the number of derivations */			/* exclude branches where independent kicks in */			for (sp2=0; sp2<der; ++sp2)	{				if ((sp+notu)==derivation[sp2])	{					c=1;					sp2=der;					}				}			if (c==0)	{				for (b=0; b<trpd[sp+notu]; ++b)	{					branches[TtlAp]=available[TtlAp]=sp+notu;					++TtlAp;					}				}			}	/* End test of node with derived condition */		}		/* Now do this for OTUs */	for (sp=0; sp<notu; ++sp)	{		/* include otus that have independent states */		if (independent[sp]==1)	{			c=0;			/* der gives the number of derivations */			/* exclude branches where independent kicks in */			for (sp2=0; sp2<der; ++sp2)	{				if (sp==derivation[sp2])	{					c=1;					sp2=der;					}				}			/* if c=0 then the character can change on this branch */			if (c==0)	{				for (b=0; b<trpd[sp]; ++b)	{					branches[TtlAp]=available[TtlAp]=sp;					++TtlAp;					}				}			}	/* End test of species with derived condition */		}	free_ivector(change);	change=ivector(N);	used=0;	for (st=0; st<N; ++st)	{		br=-1;		for (br=-1; br<0 || br>=TtlAp; br=br)			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (TtlAp-used));		sp=change[st]=branches[br];		used=used+trpd[sp];		for (b=br; b<TtlAp-used; ++b)	branches[b]=branches[b+trpd[sp]];		}/* now make changes */	for (d=0; d<N; ++d)	{		sp=change[d];		/* routine for binary characters */		if (nstates[charn]==2)	{			/* routine for species */			if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{				if (character[sp]==0)	character[sp]=1;				else					character[sp]=0;				}	/* end binary change for species */			/* routine for clade */			else	{				/* first change node */				if (nodedepnd[sp-notu]==0)	nodedepnd[sp-notu]=1;				else						nodedepnd[sp-notu]=0;				/* now change descendants */				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))	{						if (character[sp]==0)	character[sp2]=1;						else					character[sp2]=0;						}					else if (sp2>=notu)	{						if (nodedepnd[sp-notu]==0)	nodedepnd[sp2-notu]=1;						else						nodedepnd[sp2-notu]=0;						}					}	/* end binary change for species within clade */				}	/* end binary change for clade */			}	/* end routine for binary characters */					/** routine for unordered multistate **/		else if (ctype[charn]==1)	{			/* routine for species */			if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{				for (b=character[sp]; b==character[sp]; b=b)					b=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates[charn]);				character[sp]=b;				}	/* end unordered multistate change for species */			/* routine for clade */			else	{				/* first create an array stating which states change to which 	*/				for (a=0; a<nstates[charn]; ++a)	undum[a]=a;				/* now come up with new transitions for this clade 				*/				for (a=0; a<nstates[charn]; ++a)	{					b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[charn]-a));					unord[a]=undum[b];					/* do not let unord[a]==a */					while (unord[a]==a || a>=nstates[charn])	{						b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates[charn]-a));						unord[a]=undum[b];						}					/* unord[0] cannot be a (otherwise we wouldn't have this problem */					/* therefore, flip-flop unord[0] and unord[a] */					if (unord[a]==a && a==(nstates[charn]-1))	{						unord[a]=unord[0];						unord[0]=a;						}											/* remove assigned state from possibilities */					for (c=b; c<nstates[charn]; ++c)						undum[c]=undum[c+1];					/* reboot if the final possible state matches original */					if (a==(nstates[charn]-2) && (a+1)==undum[0])	{						a=-1;	/* will increment to 0*/						for (b=0; b<nstates[charn]; ++b)	undum[b]=b;						}					}	/* end assignment of state changes */								/* now make changes */				/* change node first */				nodedepnd[sp-notu]=unord[nodedepnd[sp-notu]];				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))						character[sp2]=unord[character[sp2]];					/* change descendants node */					else if (sp2>=notu)						nodedepnd[sp2-notu]=unord[nodedepnd[sp2-notu]];					}	/* end unordered multistate change for species within clade */				}	/* end unordered multistate change within clade */			}	/* end routine for unordered multistate characters */					/** routine for ordered multistate **/		else if (ctype[charn]==0)	{			/* determine whether state increases or decreases */			for (flip=-1; flip<0 || flip>99; flip=flip)	{				flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);				}			if (flip<bias[charn])	flip=1;			else				flip=-1;			/* routine for species */			if (sp<notu && (character[sp]!=UNKNOWN && character[sp]!=INAP))	{				character[sp]=character[sp]+flip;				}	/* end ordered multistate change for species */			/* routine for clade */			else	{				nodedepnd[sp-notu]=nodedepnd[sp-notu]+flip;				/* now make changes */				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (sp2<notu && (character[sp2]!=UNKNOWN && character[sp2]!=INAP))						character[sp2]=character[sp2]+flip;					else if (sp2>=notu)	{						nodedepnd[sp2-notu]=nodedepnd[sp2-notu]+flip;						}					}	/* end ordered multistate change for species within clade */				}	/* end ordered multistate change within clade */						/* Now, make sure that the lowest value is 0, not -1 or 1 */			st=nstates[charn];			for (a=0; a<notu; ++a) {				if (character[a]<st)	st=character[a];				}			if (st!=0)	{				for (a=0; a<notu; ++a) {					character[a]=character[a]-st;					}				}			}	/* end routine for ordered multistate characters */		}	}	for (sp=0; sp<notu; ++sp)	matrix[sp][charn]=character[sp];/*available, *branches, *unord, *undum, *trpd, *change, *derivation, **descnodes;*character, *independent, *nodestate*/free_ivector(available);free_ivector(branches);free_ivector(unord);free_ivector(undum);free_ivector(trpd);free_ivector(change);free_ivector(derivation);free_lvector(character);free_lvector(independent);free_lvector(nodestate);free_imatrix(descnodes,nodes,nodes);return matrix;}/* descendantnodes/* Routine to calculate the number of nodes descended from a more basal node given a VennTree/* Requires:/*		tree - a matrix in which row i gives the j descended OTUs/*		notu - number of otus/* Returns:/*		descnodes - a matrix in which row i gives the j descended nodes of clade i;/********************************************************************************************************/int	**descendantnodes (long ** tree, int notu)	{int	a, b, c;int	species, nodes;int	**descnodes;nodes=number_of_nodes(tree,notu);descnodes=imatrix(nodes,nodes);for (a=nodes-1; a>0; --a)	{	species=tree[a][1];	for (b=a-1; b>=0; --b)	{		for (c=1; c<=tree[b][0]; ++c)	{			if (species==tree[b][c])	{				++descnodes[b][0];				descnodes[b][descnodes[b][0]]=a;				c=tree[b][0];				}			}		}	}return descnodes;}/* number_of_nodes/* Routine to calculate the number of nodes descended from a more basal node given a VennTree/* Requires:/*		tree - a matrix in which row i gives the j descended OTUs/*		notu - number of otus/* Returns:/*		nodes - the number of nodes/********************************************************************************************************/int number_of_nodes(long ** tree, int notu){int	a, nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}return nodes;}/* getfossilparams - routine to get speciation, extinction, preservation and variable preservation ratesreturns - MBL[0] - input cladogenesis rate        - MBL[1] - input extinction rate        - MBL[2] - input preservation rate        - MBL[3] - input variable preservation rate******************************************************************************************/double *getfossilparams(){char	r;double	*MBL;MBL=dvector(5);cleardvector(MBL,5,2);printf("When simulating fossil taxa, species will be sampled over time until\n");printf("\tthe simulated sample size equals the observed sample size.\n");printf("\tPreservation, extinction and origination rates affect how many true\n");printf("\tspecies are needed to sample X species.  This actually has little affect\n");printf("\talthough it is easier to get patterns suggesting correlated evolution \n");printf("\twhen some branches are much longer than others.  Nevertheless, we suggest\n");printf("\tusing empirically derived rates as models for these analyses.  For methods\n");printf("\tdoing this, see Foote [1997 Paleobiology 23:278-300].\n\n");while (MBL[0]<=0 || MBL[0]>=1)	{	printf("Enter the cladogenesis rate (greater than 0 and less than 1.0): ");	scanf("%lf",&MBL[0]);	printf("\n");		if (MBL[0]<=0 || MBL[0]>=1)	printf("Enter a number between 0 and 1!\n");	}while (MBL[1]<=0 || MBL[1]>=1)	{	printf("Enter the extinction rate (greater than 0 and less than 1.0): ");	scanf("%lf",&MBL[1]);	printf("\n");		if (MBL[1]<=0 || MBL[1]>=1)	printf("Enter a number between 0 and 1!\n");	}while (MBL[2]<=0 || MBL[2]>=1)	{	printf("Enter the preservation rate (greater than 0 and less than 1.0): ");	scanf("%lf",&MBL[2]);	printf("\n");		if (MBL[2]<=0 || MBL[2]>=1)	printf("Enter a number between 0 and 1!\n");	}printf("\tIf you would like variable preservation, enter 'y', otherwise enter 'n':  ");scanf("%s",&r);printf("\n");if (r=='y' || r =='Y')	{	printf("Enter the variance in preservation rate (greater than 0 and less than 1.0): ");	scanf("%lf",&MBL[3]);	printf("\n");		if (MBL[3]<=0 || MBL[3]>=1)	printf("Enter a number between 0 and 1!\n");	}else	MBL[3]=0.0;while (MBL[4]!=0 && MBL[4]!=1)	{	printf("Enter 1 for anagenetic/bifurcating speciation or 0 for budding speciation: ");	scanf("%lf",&MBL[4]);	printf("\n");		if (MBL[4]!=0 && MBL[4]!=1)	{		printf("Enter 0 or 1!\n");		scanf("%lf",&MBL[4]);		printf("\n");		}	}return	MBL;}	/* end gathering of parameters for sampling fossil taxa */void derive_each_char(long **matrix, long **invmatrix, int **taxachange, int *nstates, int *ctype, int *maxch, int *steps, int *bias, int *sychos, int *aptaxa, int *mpd, int *trpd, int notu, int nchars, int maxstp, int mxdel, int UNKNOWN, int INAP, long **tree, int *branches, int *available, int nodes, int ttlbr, int *deltas){int	a, b, c, u;int	br, ev, ch, st, sp, sp2, best, clse, used, flip;for (ch=0; (ch<nchars && *deltas<maxstp); ++ch)	{	while ((sychos[ch]==0 || maxch[ch]==0) && ch<nchars)	++ch;	if (ch>=nchars)			break;	steps[ch]=st=0;	clearivector(taxachange[ch],mxdel,-1);	ev=0;			/* make sure that dependent characters have at least one taxon per state  - this requires that each independent be "on" for X taxa if the dependent has X states */	if (aptaxa[ch]<notu)	{		/* count unknowns - these will be put back in later */		u=0;		for (a=0; a<notu; ++a)	if (matrix[a][ch]==UNKNOWN)	++u;		/* now find a node that has similar diversity */		clse=RAND_MAX;				/* start from the bottom if most taxa are scored */		if (aptaxa[ch]>(notu/2))	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==(notu-aptaxa[ch]))	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs((notu-aptaxa[ch])-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}		/* start from the top otherwise */		else	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==aptaxa[ch])	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs(aptaxa[ch]-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}				for (sp=0; sp<notu; ++sp)	{			if (aptaxa[ch]>(notu/2))	matrix[sp][ch]=0;			else						matrix[sp][ch]=INAP;			}		for (a=1; a<tree[best][0]; ++a)	{			sp=tree[best][a];			matrix[sp][a]=0;			}		}	/* end initial creation of inapplicable character */		/* make autapomorphic characters change on one species only */	/* invariants do not change at all */	for (ch=ch; maxch[ch]<=1; ++ch)	{		/* skip invariants and make autapomorphies autapomorphic */		if	(maxch[ch]==1)	{			c=0;			/* we will sample only from otus here - so do not include clades in branches array! */			/* this part rewritten with Cubs winning 7-0 against the Marlins in Game 4 */			for (sp=0; sp<notu; ++sp)				if ((matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP) && trpd[sp]>0)	++c;			if (c>0)	{				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || (trpd[sp]==0 || sp>=notu))					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=1;				taxachange[ch][0]=sp;				}			/* if only cells belong to species with 0 length branches */			if (c==0)	{				/* flip-flop an unknown apomorphic species with a known plesiomorphic one - give plesiomorphic species a ? and the other a 1 */				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || sp2>=notu)					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);								sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while (trpd[sp2]==0 || sp2>=notu)					sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp2][ch];				invmatrix[ch][sp2]=matrix[sp2][ch]=1;				taxachange[ch][0]=sp2;				}	/* end routine if all scored species were unknown */			ev=1;			++*deltas;			++steps[ch];			++mpd[ch];			}		}	/* this should leave us with a character that needs to be changed OR out of characters */	if (ch>=nchars)	break;			used=0;	/* this tells how many branches are discarded; used > steps IF there are absents */	/* branch length is taken into account by trpd */	equalivector(branches,available,ttlbr);	/* Binary && unordered multistate is Easy */	/* for normal character, have it change until all X states are realized */	if (nstates[ch]==2 || ctype[ch]==1)	{		for (st=0; st<nstates[ch]-1; st=st)	{			/* There are ttlbr-used branches that could change */			ev=0;				/* fixed 2014-02-26	*/			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			sp = branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				ev=1;				invmatrix[ch][sp]=matrix[sp][ch]=st+1;				}			else if (sp>notu)	{				/* use st+1 instead of nstates[ch] here - we want only 0…st+1 not 0…nstates */				/*		(remember, st has not yet been incremented, so we need st+1 		*/				if (st>0)	{					for (b=1; b<=tree[sp-notu][1]; ++b)	{						sp2=tree[sp-notu][b];						if (matrix[sp2][ch]==0)	matrix[sp2][ch]=st+1;						}					}				else		evolvebinaryinclade(tree[sp-notu],matrix,ch);				for (c=0; c<notu; ++c)	{					if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;					invmatrix[ch][c]=matrix[c][ch];					}				/* if there was a change, then tally it */				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1))				removefromivector(branches,sp,&a);							if (used<steps[ch])	{				printf("ERROR LINE 954 - there are more changes than deleted branches for Ch%d…\n",ch+1);				}			/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++*deltas;				++st;	/* we increment this only if we have made a change */				}			}	/*end derivation of state */		}	/* end loop for binary / unordered characters */		/* Ordered Multistates are tougher */	else if (nstates[ch]>2 && ctype[ch]==0)	{		used=0;		for (st=0; (st<nstates[ch]-1 && (steps[ch]<mxdel && steps[ch]<maxch[ch])); st=st)	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			sp=branches[br];			/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				ev=1;				}							else if (sp>notu)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])	flip=1;				else				flip=-1;				evolveorderedinclade(tree[sp-notu],matrix,ch,flip, INAP, UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				}							for (c=0; c<notu; ++c)	{				if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;				invmatrix[ch][c]=matrix[c][ch];				}			/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++*deltas;				/* note - do not increment st here - that is done only if a new state is derived */				}			/* check if all states have been derived */			/* note: this is needed only for ordered multistates */			if (steps[ch]>=nstates[ch]-1)	{				for(a=0; a<notu; ++a)	{					if (matrix[a][ch]>st && (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN))						st=matrix[a][ch];					}				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1))				removefromivector(branches,sp,&a);			if (used<steps[ch])				printf("ERROR LINE 2145 - there are more changes than deleted branches for Ch%d…\n",ch+1);						/* emergency reboot procedure! - clear everything and start over again */			if (used==ttlbr)	{				for (a=0; a<steps[ch]; ++a)	{					sp=taxachange[ch][a];					--mpd[sp];					taxachange[ch][a]=0;					}				*deltas=*deltas-steps[ch];				st=steps[ch]=used=0;				for (sp=0; sp<notu; ++sp)					if (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN)						invmatrix[ch][sp]=matrix[sp][ch]=0;				for (sp=0; sp<ttlbr; ++sp)	branches[sp]=available[sp];				}			}		/* if there are many states and few taxa, then you do not want to mess with this anymore.  Any changes will either eliminate extreme states,		or simply shift the state up or down one (resulting in no observable change once standardized.  So, if steps >= half the taxa, then shut it down */				if (steps[ch]>(notu/2))	mxdel=steps[ch];				}	/* end loop for ordered multistates */	}	/* end derivation of all character states */}/* ensure_charstates - routine to make sure that all the character states are evolved/* requires:/*	matrix: taxon x character long matrix giving the states for each taxon/*	invmatrix: taxon x character long matrix giving states for each character/*	taxachange: long matrix listing all the branches that change for each character/*	nstates: number of states for each character/*	ctype: type of each character with (0) ordered and (1) unordered/*	maxch: maximum changes per character/*	steps: steps for each character/*	bias: biased directional change, with 55 meaning a 55% chance of increase/*	mpd: length of each branch/*	trpd: length of each branch (in no. of speciations or chances to change)/*	notu: number of taxa/*	nchars: number of character/*	mxdel: maximum number of changes/*	UNKNOWN: code for taxa with unknown conditions/*	INAP: code for taxa for which a character does not apply/*	tree: matrix listing all otus descended from a node, with tree[x][0] giving the total number sampled descendants/*	nodes: number of nodes in a tree (this is <(notu-1) if there are polytomies/*	deltas: total number of changes/* REMOVE *deltas - just sum steps[ch] at the end...../********************************************************************************************************//* check on use of maxdel	*/void ensure_charstates(long **matrix, long **invmatrix, int **taxachange, int *nstates, int *ctype, int *maxch, int *steps, int *bias, int *mpd, int *trpd, int notu, int nchars, int UNKNOWN, int INAP, long **tree, int nodes/*, int *deltas*/){int b, c, d, s;int	ch, sp, sp2, nd, flip, ev, mxd;int	asp=0, abr=0, och, tbr=0;int	*available, *otxch, *missing;long	*ocode;for (sp=0; sp<notu; ++sp)	if (trpd[sp]>0)			asp+=trpd[sp];		/* total number of branches leading directly to species one which there are changes	*/for (nd=0; nd<nodes; ++nd)	if (trpd[nd+notu]>0)	abr+=trpd[nd+notu];	/* total number of branches leading directly to nodes on which there are changes	*/available=ivector(asp+abr);mxd=maxiarray(maxch,nchars);ocode=lvector(notu);				/* original code for taxa for this character	*/otxch=ivector(mxd);					/* original taxa changing for this character	*/missing=ivector(nchars);	for (ch=0; ch<nchars; ++ch)	{	equalivector(otxch,taxachange[ch],mxd);	s=no_states(matrix,ch,notu,UNKNOWN,INAP);		/* only do this if not all states are derived	*/	while (s>=nstates[ch] && ch<(nchars-1))		s=no_states(matrix,++ch,notu,UNKNOWN,INAP);		if (ch>=nchars)	break;		equallvector(ocode,invmatrix[ch],notu);	och=steps[ch];		tbr=0;	/* Set aside available species	*/	for (sp=0; sp<notu; ++sp)	{		if(matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP)	{			for (b=0; b<trpd[sp]; ++b)	{				available[tbr]=sp;				++tbr;				}			}		}	/* end adding branch lengths of otus	*/			/* binary apomorphy easy	*/	if (maxch[ch]==1 && steps[ch]==0)	{		c=(int)((double)rand() / ((double)RAND_MAX + 1) * (asp));		sp=available[c];		while (trpd[sp]<1)	{			c=(int)((double)rand() / ((double)RAND_MAX + 1) * (asp));			sp=available[c];			}		if (matrix[sp][ch]==0)	{			invmatrix[ch][sp]=matrix[sp][ch]=1;			}		else	{			invmatrix[ch][sp]=matrix[sp][ch]=0;			}		++mpd[sp];/*		++*deltas;	*/		taxachange[ch][steps[ch]]=sp;		++steps[ch];		}	/*multistate autapomorphies also pretty easy	*/	else if (maxch[ch]<nstates[ch])	{		tbr=asp;				/* remove species that already have changed	*/		for (c=0; c<steps[ch]; ++c)	{			if ((sp=taxachange[ch][c])<notu)	removefromivector(available,sp,&tbr);			available[tbr]=-1;			}		/* now add changes but only to species branches	*/		for (d=0; d<nstates[ch]-1; ++d)		{			c=(int)((double)rand() / ((double)RAND_MAX + 1) * tbr);			sp=available[c];			invmatrix[ch][sp]=matrix[sp][ch]=d+1;			removefromivector(available,sp,&tbr);			available[tbr]=-1;						/* clear end of available			*//*			++*deltas;								/* tally total steps				*/			taxachange[ch][steps[ch]]=sp;			++steps[ch];							/* tally steps for character		*/			}		}	/* end multistate where each state diagnoses one taxon	*/		/* characters potentially diagnosing clades	*/	else	{		/* Set aside available nodes	*/		for (nd=0; nd<nodes; ++nd)	{			/* make sure that clade has at least one species scored for this character	*/			d=0;			for (c=1; c<tree[nd][0] && d==0; ++c)	{				sp=tree[nd][c];				if (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP)	d=1;				}			/* d will be 1 if there is a coded species in the clade	*/			if (d>0)	{				for (b=0; b<trpd[nd+notu]; ++b)		{					available[tbr]=nd+notu;					++tbr;					}				}			}	/* end adding branch lengths of nodes	*/					/* remove any branches that have already changed	*/		for (c=0; c<steps[ch]; ++c)	{			sp=taxachange[ch][c];			removefromivector(available,sp,&tbr);			available[tbr]=-1;			}		/* now evolve until all states exist	*/		/* safeguard to prevent too many changes added 2011-04-02: quit at maxchange or when branches expire		*/		for (s=s; s<nstates[ch] && (steps[ch]<maxch[ch] && tbr>0); s=no_states(matrix,ch,notu,UNKNOWN,INAP))	{			c=(int)((double)rand() / ((double)RAND_MAX + 1) * tbr);			sp=available[c];/*			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{	*/			if (sp<notu)	{				if (nstates[ch]==2)						invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);				else if (ctype[ch]==1)					invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);				else if (ctype[ch]==0)	{					matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);					/* make sure no negative numbers are kept! */					multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);					for (sp2=0; sp2<notu; ++sp2)	invmatrix[ch][sp2]=matrix[sp2][ch];					}/*				++*deltas;	*/				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				}						else if (sp>notu)	{/*				d=0;				/* make sure that there are taxa with scorable conditions for this character 		*/				/* and also that not all the descendants have changed already for this character 	*/				/* (the latter can be omitted as evolution cannot know this - but it makes the 		*/				/* output easier to compare to empirical studies.)									*/		/*				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;					else	sc=tree[sp-notu][0];/*					else	{						for (c=0; c<steps[ch]; ++c)	{							if (taxachange[ch][c]==sp2)	{								++d;								c=steps[ch];								}							}						}		/* if any taxa have not yet changed, then d < clade diversity *//*					}	/* end search for scored taxa */					/* if d is less than clade diversity, then proceed with change *//*				if (d<tree[sp-notu][0])	{					/* if character is an unordered multistate, then we need an array	*/					/* that tells how each state changed withing the clade				*/				if (ctype[ch]==1)	{					/* routine for unordered multistates */					if (nstates[ch]>2)	{						evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);						}					/* routine for binaries */					else	{						evolvebinaryinclade(tree[sp-notu],matrix,ch);						}					}	/* end routine for unordered / binary characters */					/* routine for ordered multistate */				else {					/* flip is used only for multistates */					flip = ((int) (100 * rand() / RAND_MAX));					if (flip<bias[ch])	flip=1;					else				flip=-1;					evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);					multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);					}				/* now make sure that there was change */				for (c=0; c<notu; ++c)	{					if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;					invmatrix[ch][c]=matrix[c][ch];					}/*					}	/* end conditional loop */				if (ev==1)	{/*					++*deltas;	*/					++mpd[sp];					taxachange[ch][steps[ch]]=sp;					++steps[ch];					}				}	/* end routine for clade */			removefromivector(available,sp,&tbr);			available[tbr]=-1;						/* sometimes with multistate characters, you will run out of branches before all the states evolve	*/			if (steps[ch]>maxch[ch])	{/*				*deltas=*deltas-(steps[ch]-och);	*/				/* two possibilities: if we have only one more state to go, then it is OK	*/				steps[ch]=och;				for (sp=0; sp<notu; ++sp)	matrix[sp][ch]=invmatrix[ch][sp]=ocode[sp];				equalivector(taxachange[ch],otxch,mxd);								/* Set aside available nodes & species HERE - REMOVE OTXCH TAXA!	*/				tbr=0;				for (sp=0; sp<notu; ++sp)	{					for (b=0; b<trpd[sp]; ++b)	{						available[tbr]=sp;						++tbr;						}					}	/* end adding branch lengths of otus	*/				for (nd=0; nd<nodes; ++nd)	{					for (b=0; b<trpd[nd+notu]; ++b)		{						available[tbr]=nd+notu;						++tbr;						}					}	/* end adding branch lengths of nodes	*/				for (s=0; s<steps[ch]; ++s)	{					sp=otxch[s];					removefromivector(available,sp,&tbr);					}				}	/* end reboot when one state short	*/			}	/* end change */		}	/* finish case of non-autapomorphies	*/	}	/* finish adding states for characters	*/free_ivector(available);free_ivector(missing);free_lvector(ocode);}/* ensure_apomorphies - routine to make sure that all the character states are evolved/* requires:/*	matrix: taxon x character long matrix giving the states for each taxon/*	invmatrix: taxon x character long matrix giving states for each character/*	taxachange: long matrix listing all the branches that change for each character/*	nstates: number of states for each character/*	ctype: type of each character with (0) ordered and (1) unordered/*	maxch: maximum changes per character/*	steps: steps for each character/*	bias: biased directional change, with 55 meaning a 55% chance of increase/*	mpd: length of each branch/*	trpd: length of each branch (in no. of speciations or chances to change)/*	notu: number of taxa/*	nchars: number of character/*	mxdel: maximum number of changes/*	UNKNOWN: code for taxa with unknown conditions/*	INAP: code for taxa for which a character does not apply/*	tree: Venn tree matrix listing all otus descended from a node, with tree[x][0] giving the total number sampled descendants/*	nodes: number of nodes in a tree (this is <(notu-1) if there are polytomies/*	deltas: total number of changes/* REMOVE *deltas - just sum steps[ch] at the end...../********************************************************************************************************/void ensure_apomorphies(long **matrix, long **invmatrix, int **taxachange, int *nstates, int *ctype, int *maxch, int *steps, int *bias, int *mpd, int *trpd, int notu, int nchars, int UNKNOWN, int INAP, long **tree, int nodes/*, int *deltas*/){int c, d;int	ev, ch, sc, sp, sp2, flip, avch;int *available;available=ivector(nchars);for (sp=0; sp<notu+nodes; ++sp)	{	if (mpd[sp]==0 && trpd[sp]>0)	{		/* find which characters can change	*/		avch=0;		for (ch=0; ch<nchars; ++ch)	{			d=0;			/* if it is a clade, then it can take only non-autapomorphic characters; also, it must have at least one coded species for the character */			if (sp>=notu && maxch[ch]>=nstates[ch])	{				d=0;				for (sc=1; d==0 && sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (matrix[sp2][c]!=UNKNOWN || matrix[sp2][c]!=INAP)	d=1;					}				}			/* if it is a species, then add it only if it is not inapplicable or missing	*/			else if (sp<notu && (matrix[sp][ch] != UNKNOWN && matrix[sp][ch]!=INAP))	d=1; 			if (d==1)	{				available[avch]=ch;				++avch;				}			}			while (mpd[sp]==0)	{			ev=0;			c=(int)((double)rand() / ((double)RAND_MAX + 1) * avch);			ch=available[c];/*			ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));			while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))				ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	*/									if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				if (nstates[ch]==2)						invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);				else if (ctype[ch]==1)					invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);				else if (ctype[ch]==0)	{					matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);					/* make sure no negative numbers are kept! */					multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);										for (c=0; c<notu; ++c)	invmatrix[ch][c]=matrix[c][ch];										}				ev=1;	/* this means that there was a change */				}						else if (sp>notu)	{				d=0;				/* make sure that there are taxa with scorable conditions for this character 		*/				/* and also that not all the descendants have changed already for this character 	*/				/* (the latter can be omitted as evolution cannot know this - but it makes the 		*/				/* output easier to compare to empirical studies.)									*/						for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;					else	{						for (c=0; c<steps[ch]; ++c)	{							if (taxachange[ch][c]==sp2)	{								++d;								c=steps[ch];								}							}						}		/* if any taxa have not yet changed, then d < clade diversity */					}	/* end search for scored taxa */					/* if d is less than clade diversity, then proceed with change */				if (d<tree[sp-notu][0])	{					/* if character is an unordered multistate, then we need an array	*/					/* that tells how each state changed withing the clade				*/					if (ctype[ch]==1)	{						/* routine for unordered multistates */						if (nstates[ch]>2)	{							evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);							}						/* routine for binaries */						else	{							evolvebinaryinclade(tree[sp-notu],matrix,ch);							}						}	/* end routine for unordered / binary characters */					/* routine for ordered multistate */					else {						/* flip is used only for multistates */						flip = ((int) (100 * rand() / RAND_MAX));						if (flip<bias[ch])	flip=1;						else				flip=-1;						evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					/* now make sure that there was change */					for (c=0; c<notu; ++c)	{						if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;						invmatrix[ch][c]=matrix[c][ch];						}					}	/* end conditional loop */				}	/* end routine for clade */			/* if there was a change, then ev = 1.  Now tally the information */			if (ev==1)	{				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++mpd[sp];/*				++*deltas;	*/				}	/* add changes if there actually was a change */			}	/* routine is repeated until an apomorphy is acquired */					}	/* end derivation of apomorphy for this branch */	}	/* end derivation for each apomorphic branch */free_ivector(available);}/* evolvedependent - evolves a dependent character enough times to realize all of its states. Missing are kept in place *//* Requires:	matrix - a taxon X character matrix with character data; this will be returned modified;    tree - a matrix containing members of each node, with daughter nodes given a number of OTUs+node#;		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[OTUs-1]) gives it for species;			the second line (tree[OTUs]) gives it for internal nodes;	trpd - branch lengths of each otu & htu;	ttlbr - number of taxa;	notu - number of taxa;	steps - the number of changes for each character;	ind - the number of the independent character;	dep - the number of the dependent character;	nstates - the number of states for the dependent character;	ctype - the type of the dependent character;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease) for the dependent character;	taxachange - a character x total branches matrix listing all the branches that change for each character;	deltas - the total changes.  Note that this is a pointer because the value will change.	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/void evolvedependent(long **matrix,long **tree,int *trpd,int ttlbr,int notu,int *steps,int ind,int dep,int nstates,int ctype,int bias,int **taxachange,int *deltas,int UNKNOWN,int INAP){int a, b;int br, ch, cl, sp, sp2, st, nodes;int flip, ev;int *available, *depvector, *indvectora;int **descnodes;depvector=ivector(notu);nodes=number_of_nodes(tree,notu);indvectora=ivector(nodes);descnodes=descendantnodes(tree,notu);/* identify nodal conditions for indendent character *//* indvectora now can be used to determine whether nodal branches can switch */for (a=0; a<steps[ind]; ++a)	{	sp=taxachange[ind][a];	if (sp>notu)	{		cl=sp-notu;		if (indvectora[cl]==0)	indvectora[cl]=1;		else					indvectora[cl]=0;		for (b=1; b<=descnodes[cl][0]; ++b)	{			sp2=descnodes[cl][b];			if (indvectora[sp2]==0)	indvectora[sp2]=1;			else					indvectora[sp2]=0;			}		}	}/* set dependent to inapplicable when the independent state is absent */for (sp=0; sp<notu; ++sp)	{	if (matrix[sp][ind]==UNKNOWN)	depvector[sp]=matrix[sp][dep]=UNKNOWN;	else if (matrix[sp][ind]==0)	depvector[sp]=matrix[sp][dep]=INAP;/*	else							depvector[sp]=matrix[sp][dep]=0;	*/	}	st=0;for (a=0; a<steps[ind]; ++a)	{	sp=taxachange[ind][a];	if (sp<notu)	{		if (matrix[sp][ind]==1)	{			if (st<nstates)	{				depvector[sp]=matrix[sp][dep]=st;				++st;				}			else	depvector[sp]=matrix[sp][dep]=ch=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates);			}		else if (matrix[sp][ind]==0)		depvector[sp]=matrix[sp][dep]=INAP;		else if (matrix[sp][ind]==UNKNOWN)	depvector[sp]=matrix[sp][dep]=UNKNOWN;		}	/* only do this for clades if the are gaining the independent */	if (sp>notu && indvectora[sp-notu]==1)	{		ev=0;		for (b=1; b<=tree[sp-notu][0]; ++b)	{			sp2=tree[sp-notu][b];			if (matrix[sp2][dep]!=UNKNOWN && matrix[sp2][dep]!=INAP)	{				depvector[sp2]=matrix[sp2][dep]=st;				ev=1;	/* register that a change is made - this won't happen if the clade lost the independent character */				}			}		if (ev==1)	++st;		}	}/* if we cannot derive all of the states just with the derivations of the independent, then we need some evolution *//* note that this cannot happen unless there is at least one clade for which the independent is a synapomorphy - we want only its descendants */if (st<nstates)	{	available=ivector(ttlbr);		/* first add all taxa that can have the dependent character to array available.  We will remove the ones that acquire the independent later */	/* first the clades */	br=0;	for (a=1; a<nodes; ++a)	{		sp=a+notu;		if (indvectora[a]==1)	{			for (b=br; b<br+trpd[sp]; ++b)	available[b]=sp;			br=br+trpd[sp];			}		}	/* second the species, omitting those with 0-length branches */	for (sp=0; sp<notu; ++sp)	{		if ((depvector[sp]>=0 & depvector[sp]<nstates) && trpd[sp]>0)	{			for (b=br; b<br+trpd[sp]; ++b)	available[b]=sp;			br=br+trpd[sp];			}		}		/* now remove those branches that acquired the independent state - they already have been done */	for (a=0; a<steps[ind]; ++a)	{		sp=taxachange[ind][a];		removefromivector(available,sp,&br);		}			/* At this point, we should have an array of otus and  htus where the dependent characters could change */	/* Now, draw at random until we have all of the states													*/		for (st=st; st<nstates && br>=0; st=st)	{		b=(int)((double)rand() / ((double)RAND_MAX + 1) * br);				sp=available[b];		if (sp<notu && (matrix[sp][dep]!=UNKNOWN && matrix[sp][dep]!=INAP))	{			if (ctype==1)	depvector[sp]=matrix[sp][dep]=st;			else	{				flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);				if (flip<bias)	flip=1;				else			flip=-1;				depvector[sp]=matrix[sp][dep]=matrix[sp][dep]+1;				}			/* we now have a change in the dependent character */			taxachange[dep][steps[dep]]=sp;			++*deltas;			++steps[dep];			/* if dependent state is ordered, then this change might not produce a new state */			if (matrix[sp][dep]==st)	++st;			}		else if (sp>notu)	{			ev=0;			if (ctype==0)	{				flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);				if (flip<bias)	flip=1;				else			flip=-1;				}			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (ctype==1)	{					if (matrix[sp2][dep]!=UNKNOWN && matrix[sp2][dep]!=INAP)	{						depvector[sp2]=matrix[sp2][dep]=st;						ev=1;						}					}				else if (ctype==0)	{					if (matrix[sp2][dep]!=UNKNOWN && matrix[sp2][dep]!=INAP)	{						depvector[sp2]=matrix[sp2][dep]=matrix[sp2][dep]+flip;						if (matrix[sp2][dep]==st)	++st;						ev=1;						}					}				}			if (ev==1)	{				if (ctype==1)	++st;				taxachange[dep][steps[dep]]=sp;				++*deltas;				++steps[dep];				}			}		removefromivector(available,sp,&br);		}	free_ivector(available);	}free_imatrix(descnodes,nodes,nodes);free_ivector(depvector);free_ivector(indvectora);}/* evolvedependentNSteps - evolves a dependent character enough times to realize all of its states. Missing are kept in place *//* Requires:	N - the number of steps.	matrix - a taxon X character matrix with character data; this will be returned modified;    tree - a matrix containing members of each node, with daughter nodes given a number of OTUs+node#;		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[OTUs-1]) gives it for species;			the second line (tree[OTUs]) gives it for internal nodes;	notu - number of taxa;	ind - the number of the independent character;	dep - the number of the dependent character;	nstates - the number of states for the dependent character;	ctype - the type of the dependent character;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease) for the dependent character;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/void evolvedependentNsteps(/*int N, int iN,*/ long **matrix,long **tree, int *trpd, int **taxachange, int *steps, int notu, int ttlbr, int ind,int dep,int nstates,int ctype,int bias,int UNKNOWN,int INAP, int *deltas){int a, b;int br, ch, cl, sp, sp2, st, nodes;int flip, ev;int *available, *depvector, *indvectora;int **descnodes;depvector=ivector(notu);nodes=number_of_nodes(tree,notu);indvectora=ivector(nodes);descnodes=descendantnodes(tree,notu);/* identify nodal conditions for indendent character *//* indvectora now can be used to determine whether nodal branches can switch */for (a=0; a<steps[ind]; ++a)	{	sp=taxachange[ind][a];	if (sp>notu)	{		cl=sp-notu;		if (indvectora[cl]==0)	indvectora[cl]=1;		else					indvectora[cl]=0;		for (b=1; b<=descnodes[cl][0]; ++b)	{			sp2=descnodes[cl][b];			if (indvectora[sp2]==0)	indvectora[sp2]=1;			else					indvectora[sp2]=0;			}		}	}/* set dependent to inapplicable when the independent state is absent */for (sp=0; sp<notu; ++sp)	{	if (matrix[sp][ind]==UNKNOWN)	depvector[sp]=matrix[sp][dep]=UNKNOWN;	else if (matrix[sp][ind]==0)	depvector[sp]=matrix[sp][dep]=INAP;/*	else							depvector[sp]=matrix[sp][dep]=0;	*/	}	st=0;for (a=0; a<steps[ind]; ++a)	{	sp=taxachange[ind][a];	if (sp<notu)	{		if (matrix[sp][ind]==1)	{			if (st<nstates)	{				depvector[sp]=matrix[sp][dep]=st;				++st;				}			else	depvector[sp]=matrix[sp][dep]=ch=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates);			}		else if (matrix[sp][ind]==0)		depvector[sp]=matrix[sp][dep]=INAP;		else if (matrix[sp][ind]==UNKNOWN)	depvector[sp]=matrix[sp][dep]=UNKNOWN;		}	/* only do this for clades if the are gaining the independent */	if (sp>notu && indvectora[sp-notu]==1)	{		ev=0;		for (b=1; b<=tree[sp-notu][0]; ++b)	{			sp2=tree[sp-notu][b];			if (matrix[sp2][dep]!=UNKNOWN && matrix[sp2][dep]!=INAP)	{				depvector[sp2]=matrix[sp2][dep]=st;				ev=1;	/* register that a change is made - this won't happen if the clade lost the independent character */				}			}		if (ev==1)	++st;		}	}/* if we cannot derive all of the states just with the derivations of the independent, then we need some evolution *//* note that this cannot happen unless there is at least one clade for which the independent is a synapomorphy - we want only its descendants */if (st<nstates)	{	available=ivector(ttlbr);		/* first add all taxa that can have the dependent character to array available.  We will remove the ones that acquire the independent later */	/* first the clades */	br=0;	for (a=1; a<nodes; ++a)	{		sp=a+notu;		if (indvectora[a]==1)	{			for (b=br; b<br+trpd[sp]; ++b)	available[b]=sp;			br=br+trpd[sp];			}		}	/* second the species, omitting those with 0-length branches */	for (sp=0; sp<notu; ++sp)	{		if ((depvector[sp]>=0 & depvector[sp]<nstates) && trpd[sp]>0)	{			for (b=br; b<br+trpd[sp]; ++b)	available[b]=sp;			br=br+trpd[sp];			}		}		/* now remove those branches that acquired the independent state - they already have been done */	for (a=0; a<steps[ind]; ++a)	{		sp=taxachange[ind][a];		removefromivector(available,sp,&br);		}			/* At this point, we should have an array of otus and  htus where the dependent characters could change */	/* Now, draw at random until we have all of the states													*/		for (st=st; st<nstates && br>=0; st=st)	{		b=(int)((double)rand() / ((double)RAND_MAX + 1) * br);				sp=available[b];		if (sp<notu && (matrix[sp][dep]!=UNKNOWN && matrix[sp][dep]!=INAP))	{			if (ctype==1)	depvector[sp]=matrix[sp][dep]=st;			else	{				flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);				if (flip<bias)	flip=1;				else			flip=-1;				depvector[sp]=matrix[sp][dep]=matrix[sp][dep]+1;				}			/* we now have a change in the dependent character */			taxachange[dep][steps[dep]]=sp;			++*deltas;			++steps[dep];			/* if dependent state is ordered, then this change might not produce a new state */			if (matrix[sp][dep]==st)	++st;			}		else if (sp>notu)	{			ev=0;			if (ctype==0)	{				flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);				if (flip<bias)	flip=1;				else			flip=-1;				}			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (ctype==1)	{					if (matrix[sp2][dep]!=UNKNOWN && matrix[sp2][dep]!=INAP)	{						depvector[sp2]=matrix[sp2][dep]=st;						ev=1;						}					}				else if (ctype==0)	{					if (matrix[sp2][dep]!=UNKNOWN && matrix[sp2][dep]!=INAP)	{						depvector[sp2]=matrix[sp2][dep]=matrix[sp2][dep]+flip;						if (matrix[sp2][dep]==st)	++st;						ev=1;						}					}				}			if (ev==1)	{				if (ctype==1)	++st;				taxachange[dep][steps[dep]]=sp;				++*deltas;				++steps[dep];				}			}		removefromivector(available,sp,&br);		}	free_ivector(available);	}free_imatrix(descnodes,nodes,nodes);free_ivector(depvector);free_ivector(indvectora);}/* A recursive routine that codes nodes and descendants;/* Requires:	tree: a matrix giving members of each node, with daughter clades given as supraspecific numbers.	div: an array telling you the diversity of each clade (2 = bifurcation, 3+ = polytomy.	matrix: a species X character matrix.	node: the number of the particular node changing.	chr: the character being changed.	newst: the new state.	notu - the number of species (or analyzed taxa).  NOTE: 	clades (the number of clades) removed 29.04.2004*******************************************************************************************************************************************/void recursivechange(long **tree, long **matrix, int node, int chr, int newst, int notu){int	a, sp, clade;for (a=1; a<=tree[node][0]; ++a)	{	sp=tree[node][a];	matrix[sp][chr]=newst;		if (sp>notu)	{		clade=sp-notu;		recursivechange(tree, matrix, clade, chr, newst, notu);		}	}}/* Evolves a single change in a single character vector given a tree (tree) and information about a character (states, ordering, etc.)/* Returns a vector of length notu (number of taxa), with gaps and missing are kept in place.  This can be integrated back into a notu x nchar matrix.  /* Requires:	tree - a matrix containing members of each node (with ALL species belonging to the clade);		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[notu-1]) gives it for species;			the second line (tree[notu]) gives it for internal nodes;	branch - the branch on the tree that changes;	notu - number of taxa;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/long *evolvecharacteronemorestep(long **tree, int branch, int notu, long *chvector, int nstates, int ctype, int bias, int UNKNOWN, int INAP){int		a, b, c, st, sc;int		flip, sp;int		*unord, *undum;/* 2010-01-18: Removed so that you can do one step at a time, keeping track as you go		*//* Here after, remember to clear the vector prior to this routine							*//*for (a=0; a<notu; ++a)	if (chvector[a]!=UNKNOWN && chvector[a]!=INAP)	chvector[a]=0;	*//* allocate memory for branch lengths *//* allocate memory for arrays to be used for unordered multistates */if (nstates>2 && ctype==1)	{	unord=ivector(nstates);	undum=ivector(nstates);	}/* now, make changes *//* routine for binary characters */if (nstates==2)	{	/* routine for species scored for character */	if (branch<notu && (chvector[branch]!=UNKNOWN && chvector[branch]!=INAP))	{		chvector[branch]=swap(chvector[branch]);		}	/* end binary change for species */	/* routine for clade */	else if (branch>=notu)	{		for (sc=1; sc<=tree[branch-notu][0]; ++sc)	{			sp=tree[branch-notu][sc];			if (sp<notu && (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP))	{				chvector[sp]=swap(chvector[sp]);				}			}	/* end binary change for species within clade */		}	/* end binary change for clade */	}	/* end routine for binary characters */	/** routine for unordered multistate **/else if (ctype==1)	{	/* routine for species scored for character */	if (branch<notu && (chvector[branch]!=UNKNOWN && chvector[branch]!=INAP))	{		for (b=chvector[branch]; b==chvector[branch]; b=b)			b=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates);		chvector[branch]=b;		}	/* end unordered multistate change for species */	/* routine for clade */	else if (branch>=notu)	{		/* first create an array stating which states change to which 	*/		for (a=0; a<nstates; ++a)	undum[a]=a;		/* now come up with new transitions for this clade 				*/		for (a=0; a<nstates; ++a)	{			b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates-a));			unord[a]=undum[b];			/* do not let unord[a]==a */			while (unord[a]==a || a>=nstates)	{				b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates-a));				unord[a]=undum[b];				}			/* unord[0] cannot be a (otherwise we wouldn't have this problem */			/* therefore, flip-flop unord[0] and unord[a] */			if (unord[a]==a && a==(nstates-1))	{				unord[a]=unord[0];				unord[0]=a;				}							/* remove assigned state from possibilities */			for (c=b; c<nstates; ++c)				undum[c]=undum[c+1];			/* reboot if the final possible state matches original */			if (a==(nstates-2) && (a+1)==undum[0])	{				a=-1;	/* will increment to 0*/				for (b=0; b<nstates; ++b)	undum[b]=b;				}			}	/* end assignment of state changes */				/* now make changes */		for (sc=1; sc<=tree[branch-notu][0]; ++sc)	{			sp=tree[branch-notu][sc];			if (sp<notu && (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP))				chvector[sp]=unord[chvector[sp]];			}	/* end unordered multistate change for species within clade */		}	/* end unordered multistate change within clade */	}	/* end routine for unordered multistate characters */	/** routine for ordered multistate **/else if (ctype==0)	{	/* determine whether state increases or decreases */	for (flip=-1; flip<0 || flip>99; flip=flip)	{		flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);		}	if (flip<bias)	flip=1;	else				flip=-1;	/* routine for species */	if (branch<notu && (chvector[branch]!=UNKNOWN && chvector[branch]!=INAP))	{		chvector[branch]=chvector[branch]+flip;		}	/* end ordered multistate change for species */	/* routine for clade */	else if(branch>=notu)	{		/* now make changes */		for (sc=1; sc<=tree[branch-notu][0]; ++sc)	{			sp=tree[branch-notu][sc];			if (sp<notu && (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP))				chvector[sp]=chvector[sp]+flip;			}	/* end ordered multistate change for species within clade */		}	/* end ordered multistate change within clade */		/* Now, make sure that the lowest value is 0, not -1 or 1 */	st=nstates;	for (a=0; a<notu; ++a) {		if (chvector[a]<st)	st=chvector[a];		}	if (st!=0)	{		for (a=0; a<notu; ++a) {			chvector[a]=chvector[a]-st;			}		}	}	/* end routine for ordered multistate characters */if (nstates>2 && ctype==1)	{	free_ivector(unord);	free_ivector(undum);	}return chvector;}/* Finds the best simulation parameters given /* HEAVILY modified on 2011-11-07/* Returns a vector of length notu (number of taxa), with gaps and missing are kept in place.  This can be integrated back into a notu x nchar matrix.  /* Requires:	ranges - a taxon X 2 matrix with first and last appearance data;	notu - number of taxa;	RUNS - the number of runs to use;	debug - 0 = use clock, 1 = seed on run for debugging;	mode - speciation (0 for budding, 1 for bifurcating	/*******************************************************************************************************************************************/double *findbestrelativepreservationrate(long **ranges, int notu, int RUNS, int debug, int mode){int		a, b, c, r, s;int 	clades;int		obshist;int		match;long  	**sranges;long	**tree;double	x,y;double	dfrk, idfrk;double	pfrq[2], bfrq[2], ldfrk[3];double	*rich;double	*mbl;long	secs;obshist=1+(maxlmatrixcol(ranges,notu,0)-minlmatrixcol(ranges,notu,0));rich=dvector(obshist);rich[0]=1.0f;for (x=1.05; y<notu; x+=0.05)	{	y=1.0f;	for (a=1; a<obshist; ++a)	{		rich[a]=x*rich[a-1];		y+=rich[a];		}	}free_dvector(rich);y=Poisson(x,1,0);mbl=dvector(5);mbl[0]=1-y;mbl[1]=0.9*mbl[0];mbl[3]=1.0f;			/* fixed 2014-01-15	*/mbl[4]=mode;sranges=lmatrix(notu,2);time(&secs);srand((unsigned int) secs);for (a=0; a<2; ++a)	bfrq[a]=-1.0*MAXRAND;idfrk=dfrk=2.0f;for (mbl[2]=mbl[1]; dfrk>=1.01; mbl[2]/=dfrk)	{	match=0;	for (r=0; r<RUNS; ++r)	{		if (debug==1)	{			srand((unsigned int) (r+1)*(a+1));			}		tree=evolvetree(notu,mbl,1);		clades=cladecountbytaxa(tree,notu);		/* pull range data out of back of tree matrix	*/		for (s=0; s<notu; ++s)	{			sranges[s][0]=tree[notu+1][s];			sranges[s][1]=tree[notu+2][s];			}		cleancladerangedata(sranges,notu);				b=minlmatrixcol(sranges,notu,0);			/* oldest first appearance	*/		c=maxlmatrixcol(sranges,notu,0);			/* latest last appearance	*/		free_lmatrix(tree,clades+3,notu);				if ((1+(c-b))==obshist)	++match;		}	if ((double) match/((double) RUNS)>bfrq[1])	{		pfrq[0]=bfrq[0];							/* store prior best			*/		bfrq[0]=mbl[2];		bfrq[1]=((double) match)/((double) RUNS);		if (dfrk==idfrk || dfrk==(1/idfrk))	{			ldfrk[1]=ldfrk[0];			ldfrk[0]=dfrk;			}		}	else	{		mbl[2]*=dfrk;			/* restore to best preservation	*/		ldfrk[1]=ldfrk[0];		ldfrk[0]=dfrk;		dfrk=pow(dfrk,0.5);		/* use square root of dfrk		*/		}		}free_lmatrix(sranges,notu,2);return (mbl);}double *findbestmblparameters(long **ranges, int notu, int RUNS, int debug, int mode){int		a, r, s;int		tt=0, ttr=0;int 	clades;int		simhist, obshist;unsigned long	sumdev=0, bsumdev=0;int		match, under;int		peaked;							/* how many runs we are past the last peak					*/long  	**sranges;long	**tree;//double	x;double	ifrk, dfrk, idfrk;				/* initial freqrat, delta freqrat, initial delta freqrat	*/double	mnfrk=0.001f;double	pfrq[2], bfrq[2];double	*mbl;long	secs;//FILE	*output1;obshist=notu;/* 2011-11-07: estimate extinction based on average duration of 2+ stage taxa && 	estimate preservation based on how well it produces the sum of stratigraphic ranges	*/for (s=0; s<notu; ++s)	{	obshist+=(ranges[s][1]-ranges[s][0]);	if (ranges[s][1]>ranges[s][0])	{		++tt;		ttr+=1+(ranges[s][1]-ranges[s][0]);		}	}//mbl=dvector(5);if (debug!=1)	{	time(&secs);	srand((unsigned int) secs);	}/*	bfrq[0] = FreqRat					*//*	bfrq[1] = matches for best FreqRat	*/for (a=1; a<2; ++a)	bfrq[a]=-1.0*MAXRAND;peaked=-1;/* 2011-11-07: added a minimum and actual freqrat calculation	*//*output1=fopen("Debugging.xls","w");fclose(output1);	*/	ifrk=FreqRatMatrix(ranges,notu);if (ifrk>0.5)		ifrk=0.5;mnfrk=dmax((ifrk/4.0f),0.01);	/* move this below	*/	if (ifrk>0)	{//	mbl[1]=1-pow(e,(log(0.5)/(((double) ttr)/((double) tt))));  /* the 2nd term gives the probability of survival so that half the taxa last the average range	*/	mbl=dvector(5);	mbl[1]=1-pow(e,(log(0.5)/(((double) obshist)/((double) notu))));  /* the 2nd term gives the probability of survival so that half the taxa last the average range	*/	mbl[0]=5.5*mbl[1]/5.0;	mbl[3]=1.0f;	mbl[4]=mode;	bfrq[0]=ifrk;//	mnfrk=mbl[1]*0.02;	idfrk=dfrk=1.18920711500272f;	a=0;	sranges=lmatrix(notu,2);	for (mbl[2]=2*ifrk; (mbl[2]>mnfrk && peaked<5); mbl[2]/=dfrk)	{		under=sumdev=match=0;		for (r=0; r<RUNS; ++r)	{			if (debug==1)	{				srand((unsigned int) (r+1)*(a+1));				}			tree=evolvetree(notu,mbl,1);			clades=cladecountbytaxa(tree,notu);			/* pull range data out of back of tree matrix	*/			for (s=0; s<notu; ++s)	{				sranges[s][0]=tree[notu+1][s];				sranges[s][1]=tree[notu+2][s];				}			cleancladerangedata(sranges,notu);						simhist=notu;			for (s=0; s<notu; ++s)	simhist+=(sranges[s][1]-sranges[s][0]);			free_lmatrix(tree,clades+3,notu);			/*			output1=fopen("Debugging.xls","a");			fprintf(output1,"%6.5f\t%d\t%d\n",mbl[2],simhist,obshist);			fclose(output1);	*/			if (simhist==obshist)		++match;			else if (simhist<obshist)	++under;			sumdev+=abs(simhist-obshist);			}	/*	if ((double) match/((double) RUNS)>bfrq[1])	{	*/		if (sumdev<bsumdev || mbl[2]==2*ifrk)	{			pfrq[0]=bfrq[0];							/* store prior best			*/			bfrq[0]=mbl[2];			bfrq[1]=((double) match)/((double) RUNS);			peaked=0;			bsumdev=sumdev;								/* record new best sum of squared deviations	*/			}		else if (sumdev==bsumdev && ((double) match)/((double) RUNS)>bfrq[1])	{			pfrq[0]=bfrq[0];							/* store prior best			*/			bfrq[0]=mbl[2];			bfrq[1]=((double) match)/((double) RUNS);			peaked=0;			}		else if (mbl[2]<ifrk)	++peaked;				/* escape routine!	*/		if ((under + (match/2))> (RUNS/2))	peaked=5;		++a;		}	/* end search of preservation rates to find rate giving same sum of stratigraphic ranges	*/	mbl[2]=bfrq[0];	free_lmatrix(sranges,notu,2);	}	/* routine when there are taxa with ranges	*//* routine for a bunch of singletons	*/else	{	mbl=findbestrelativepreservationrate(ranges,notu,RUNS,debug,mode);	}	/* if no taxa have ranges, then just use the lowest FreqRat that we are willing to use	*/if (mbl[2]>mbl[1])	mbl[2]=mbl[1];		/* don't let preservation be greater than extinction!	*/return (mbl);}/**** 2011-03-28: GENERAL ISSUE: MAKE SURE THAT VENN TREES LOOK TO THE CORRECT ROWS FOR BRANCH LENGTHS!!!	****/// /* evolvetree - Evolves a paleontological tree, with notu taxa sampled over time/* Requires:	notu - # of sampled taxa/*				MBL - simulation parameters where	 				MBL[0] (lmbd) - Speciation rate/*					MBL[1] (mu) - Extinction rate/*					MBL[2] (fr) - Preservation rate/*					MBL[3] (vr) - Variance in preservation rate/*					MBL[4] (speciation) - (1) bifurcation (0) budding cladogenesis				FOSSILS - (1) fossils sampled, (0) no fossils sampled/* Major Rewrite of Sampled Tree Construction 02/2003/* Rewritten to use real numbers from a single array (MBL)/* Returns: tree where				tree[0][0]…tree[clades-1][0] gives number of descendants of a node;				tree[0][1…tree[0][0]]…tree[clades-1][1…tree[clades-1][0]] give desendants where					0…OTUs-1 are taxon numbers;					OTUs…OTUs+clades are HTU numbers (daughter clades);				tree[OTUs-1][0…OTUs-1] give branch lengths of sampled taxa;				tree[OTUS][0…clades-1] give branch lengths of unsampled taxa;				tree[OTUs+1][0…OTUs-1] give first appearances of sampled taxa;				tree[OTUs+2][0…OTUs-1] give last appearances of sampled taxa;******************************************************************************************************/long **evolvetreePois(int OTUs, double *MBL, int FOSSILS){long	attempts, base=100000, speciation;int		a, b, c, d, f, ee, charstandard, ch, mxdv, chucks;int		clade, otu, otu2, htu, sampled, cumulativediv, stage;int		species, anc, change, testnode, plesion, found0, oldfirst;int		reboot;int		sp, sp2, nodes, found;int		mxtaxa, stagemax=500;int		*f1, **forefathers, *ancestor;int		*observed, *obsbl, *commonanc, *bl;int		*fa, *la, *dbas, *occs, *samp, *standingdiv;int		**pdmat, **camat;long	**tree;double	lmbd, mu, fr, vr;double	speciate, extinct, find;double	*tor, *tex;//double	v, x, y, mod;double	stagefr[500], sampvar, *org;lmbd=MBL[0];mu=MBL[1];fr=MBL[2];vr=MBL[3];if (vr<1)	vr=MBL[3]=1.0f;speciation=MBL[4];//v=expectedpropsampled(MBL[1],MBL[2]);//v=1/v;mxtaxa=10*OTUs/expectedpropsampled(MBL[1],MBL[2]);/*if (FOSSILS=1)	mxstnd=2*OTUs;	*//*else			mxstnd=3*OTUs;		*///mxstnd=3*OTUs;if (vr==1)	cleardvector(stagefr,stagemax,fr);else	{	for (stage=0; stage<stagemax; ++stage)	{		/* add routine for variable preservation here!	*/		sampvar=randomnormal(0.001);		stagefr[stage]=fr*pow(vr,sampvar);		}	}/* arrays for observed taxa - set to OTUs*/observed=ivector(OTUs);		/* observed (sampled) taxa 					*/fa=ivector(OTUs);			/* first appearance of a taxon				*/la=ivector(OTUs);			/* last appearance of a taxon				*/obsbl=ivector(OTUs);		/* branch lengths of sampled taxa			*/commonanc=ivector(2*OTUs);	/* ancestors of a taxon						*/dbas=ivector(OTUs);			/* patristic distance from base to taxon	*/occs=ivector(OTUs);		/* finds per observed taxon					*/bl=ivector(2*OTUs);			/* array for all elements of the tree 		*//*extants = ivector(mxstnd+1);	/* array for standing taxa - set to mxstnd*/	/* arrays for sampled and unsampled taxa - set to mxtaxa */ancestor=ivector(mxtaxa);		/* ancestor of each taxon 					*/f1=ivector(mxtaxa);				/* number of descendants for each taxon 	*/tor=dvector(mxtaxa);			/* true origination - this is a real number */tex=dvector(mxtaxa);			/* true extinction - this is a real number 	*/samp=ivector(mxtaxa);			/* finds per observed taxon					*/standingdiv=ivector(stagemax);	/* standing diversity in any given stage	*/reboot=0;a=b=c=d=ee=anc=0;charstandard = 1; /*charbase/100;*/sp = ch = change = find = 0;clearivector(observed,OTUs,-1);clearivector(obsbl,OTUs,-1);clearivector(ancestor,mxtaxa,-1);//clearivector(extants,mxstnd+1,-1);attempts = cumulativediv = stage = sampled = 0;/* use this to calculate how long the species will live */extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);while (extinct<0 || extinct>1)	extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);tex[0]=(log(1-extinct)/log(1-mu));tor[0]=0.0f;		/*added 2014-01-13	*/org=dvector(8);org[0]=-1;/*species=0;		/* first species	*/for (species=0; sampled < OTUs; ++species)	{//	initdiv = standingdiv+1;	/********************************************/	/*			Does Lineage Speciate?			*/	/********************************************/	if (species<0 || species>mxtaxa)	{		printf("ERROR 7589: %d is the wrong number of species!\n", species);		exit(0);		}//	species = extants[species];		if (cumulativediv<mxtaxa)	speciate = (((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);	else						speciate = 0.0f;		if (species%2==1)	speciate=1-speciate;	/* arbitrarily set maximum descendants at 6	*/	f1[species]=PoissonRandOutcome(lmbd,(tex[species]-tor[species]),speciate,6);	if (f1[species]>0)	{		/* routine for budding	*/		if (speciation==0)	{			/* use 1…n instead of 0…(n-1) here!	*/			/* generate origination times; then sort them	*/			for (f=1; f<=f1[species]; ++f)	{				org[f]=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				while (org[f]<0 || org[f-1]>1)						org[f]=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				}			org=dshellsort_inc(org,f1[species]+1);			for (f=1; f<=f1[species]; ++f)	{				/* origin of f1 is origin of ancestor + (0…1) times range (extinction - origin)	*/				tor[cumulativediv+f]=tor[species]+org[f]*(tex[species]-tor[species]);				extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				while (extinct>1 || extinct<0)					extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				tex[cumulativediv+f]=tor[cumulativediv+f]+(log(1-extinct)/log(1-mu));				ancestor[cumulativediv+f]=species;				}	/* end assigning originations and extinctions to descendant taxa	*/			}	/* end case of budding cladogenesis	*/		/* routine for bifurcation	*/		else if (speciation==1)	{			f1[species]=2;			/* both daughters have the same origination time, and that is the new extinction time of the ancestor	*/			speciate = (((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);			while (speciate>1 || speciate<0)				speciate = (((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);			tor[cumulativediv+1]=tor[cumulativediv+2]=tor[species]+speciate*(tex[species]-tor[species]);			tex[species]= tor[cumulativediv+1];			for (f=1; f<=2; ++f)	{				extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				while (extinct>1 || extinct<0)					extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				tex[cumulativediv+f]=tor[cumulativediv+f]+(log(1-extinct)/log(1-mu));				ancestor[cumulativediv+f]=species;				}	/* end assignment of extinction times to daughters	*/			}	/* end routine for bifurcation	*/		cumulativediv+=f1[species];		}	/* end routine for establishing daughter taxa	*/		if (FOSSILS==1 && sampled<OTUs)	{		a=tor[species];				/* origin in stage form		*/		b=tex[species];				/* extinction in stage form	*/		/* if this is the end of the clade and it cannot be the final sampled species, then kill the routine	*/		if (species==cumulativediv && sampled<(OTUs-1))	b=a-1;		for (stage=a; stage<=b; ++stage)	{			find=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);			/* routine for middle of species duration	*/			if (stage!=a & stage!=b)	f=PoissonRandOutcome(fr,1.0,find,100);			/* routine for species existing in only one stage 	*/			else if (stage==a && stage==b)	{				f=PoissonRandOutcome(stagefr[stage],(tex[species]-tor[species]),find,100);				}	/* end only possible appearance	*/			/* routine for species' first stage 	*/			else if (stage==a)	{				f=PoissonRandOutcome(stagefr[stage],(((double) (a+1))-tor[species]),find,100);				}	/* end first possible appearance	*/			/* routine for species' last stage 	*/			else if (stage==b)	{				f=PoissonRandOutcome(stagefr[stage],(tex[species]-((double) b)),find,100);				}	/* end last possible appearance	*/			/* new find!	*/			if (f>0 && samp[species]==0)	{				observed[sampled]=species;			/* note original number of sampled species	*/				fa[sampled]=la[sampled]=stage;		/* record first & last appearance data		*/				occs[sampled]=samp[species]=f;		/* record number of finds					*/				++standingdiv[stage];				}	/* end first appearance	*/			/* later find!	*/			else if (f>0)	{				la[sampled]=stage;					/* increment last appearance for already sampled taxon	*/				occs[sampled]+=f;					/* increment finds for original species number			*/				samp[species]+=f;					/* increment finds for sampled species number			*/				++standingdiv[stage];				}	/* end extension of stratigraphic range	*/			}	/* end possible finds	*/		if (samp[species]>0)			++sampled;		}	/* end sampling routine	*/	else if (FOSSILS==0)	{		/* introduce routine here to find maximum standing diversity; if it is at OTUs, then that stage is the present	*/		}			/****** REBOOT ROUTINE ******/	if ((species==cumulativediv || cumulativediv>=mxtaxa) && sampled < OTUs)	{		/* clear vectors set to maxtaxa */		for (sp=0; sp<=cumulativediv; ++sp)			tex[sp]=tor[sp]=f1[sp]=samp[sp]=0;		/* clear vectors set to OTUs */		for (sp=0; sp<sampled; ++sp)			fa[sp]=la[sp]=occs[sp]=0;		clearivector(standingdiv, stagemax, 0);		clearivector(ancestor,cumulativediv+1,-1);		clearivector(observed,sampled,-1);				cumulativediv = sampled = stage = 0;		++attempts;		/* use this to calculate how long the species will live */		extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		while (extinct>1 || extinct<0)			extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		tex[0]=(log(1-extinct)/log(1-mu));		tor[0]=0.0f;		/*added 2014-01-13	*//*		if ((attempts%5)==0)	printf ("%2d tries and counting.\n",attempts); */		species=-1;		}				/** Reboot simulation **/	}mxdv=1+maxiarray(f1,cumulativediv);/* tree matrix - rows 0...(OTUs-1) rows are for possible nodes	*//*		row OTUs-1 is for species branch lengths				*//*		row OTUs   is for nodal branch lengths					*//*		row OTUs+1 is for species FAs							*//*		row OTUs+2 is for species LAs							*//*		the first cell of rows 0…(OTUs-1) give # branches		*//*			(i.e., 2 for bifurcation w. no sampled ancestor)	*/tree=lmatrix(OTUs+3,OTUs);clearlmatrix(tree,OTUs+3,OTUs,-1);for (a=cumulativediv+1; a<mxtaxa; ++a)	f1[a]=ancestor[a]=0;if (observed[0]==-1)	{	printf("Taxa lost by line 7720\a\n");	exit(0);	}/*********************************************************************************//*								Store True Phylogeny							 *//*********************************************************************************//**** LIST ANCESTORS OF EACH OBSERVED SPECIES ****/chucks=0;ancestor[0]=-1;/* find the distance from the base for each species */for (otu=0; otu<OTUs; ++otu)	{	sp=observed[otu];	anc=ancestor[sp];	if (anc>=0)		dbas[otu]=1;	for (a=1; anc>=0; ++a)	{		anc=ancestor[anc];		++dbas[otu];		}	}/* count the maximum number of ancestors */chucks=maxiarray(dbas,otu);/* list all of the ancestors for each species */forefathers=imatrix(OTUs,chucks+1);clearimatrix(forefathers,OTUs,chucks+1,-1);ancestor[0]=-1;for (otu=0; otu<OTUs; ++otu)	{	forefathers[otu][0]=sp=observed[otu];	anc=ancestor[sp];	for (a=1; anc>=0; ++a)	{		forefathers[otu][a]=anc;		anc=ancestor[anc];		}	}/* list the unsampled ancestors of each species *//* also, tally species with sampled descendants */free_ivector(f1);f1=ivector(OTUs);	/* 0: no sampled descendants; 1: 1+ sampled descendants */for (otu=0; otu<OTUs; ++otu)	{	obsbl[otu]=1;	found=0;	for (a=1; a<dbas[otu]; ++a)	{		anc=forefathers[otu][a];		for (b=otu-1; b>=0; --b)	{			if (observed[b]==anc)	{				found=1;				f1[b]=1;				/* end loops */				b=0;				a=dbas[otu];				}			}		if (found==0)	++obsbl[otu];		}	}/* create a matrix of branch distances between taxa *//* this gives distance to common ancestor, so the matrix is asymmetrical */pdmat=imatrix(otu,otu);camat=imatrix(otu,otu);for (otu=OTUs-1; otu>0; --otu)	{	for (otu2=otu-1; otu2>=0; --otu2)	{		for (a=0; a<=dbas[otu]; ++a)	{			sp=forefathers[otu][a];			for (b=0; b<=dbas[otu2]; ++b)	{				sp2=forefathers[otu2][b];				if (sp==sp2)	{					pdmat[otu][otu2]=a+1;					pdmat[otu2][otu]=b+1;					camat[otu][otu2]=camat[otu2][otu]=sp;					/* end loop */					b=dbas[otu2];					a=dbas[otu];					}				/* end loop if forefather[otu][a] cannot match forefather[otu2][any] */				else if (sp>sp2)	b=dbas[otu2];				}			}		}	}/* create a tree *//* keep track of common ancestors of each clade */nodes=found0=0;for (otu=OTUs-1; otu>0; --otu)	{	d=chucks;	for (otu2=otu-1; otu2>=0; --otu2)	{		if (pdmat[otu][otu2]<d)	{			d=pdmat[otu][otu2];			}		}	for (otu2=0; otu2<otu; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			anc=camat[otu][otu2];			found=-1;			for (a=0; a<nodes; ++a)	{				/* existing nodes found */				if (commonanc[a]==camat[otu][otu2])	{					found=0;					/* check to see if the species already is in the nodes */					for (b=1; b<=tree[a][0]; ++b)	{						if (otu2==tree[a][b])		found=1;						}					if (found==0)	{						for (b=1; b<=tree[a][0]; ++b)	{							if (otu==tree[a][b])	found=2;							}						}					/* if neither species already found */					if (found==0)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					/* if older species already found */					else if (found==1)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						}					/* if younger species already found */					else if (found==2)	{						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					a=nodes+1;					otu2=otu;					}				}	/* end search for previously found node */			/* new nodes found */			if (found==-1)	{				commonanc[nodes]=camat[otu][otu2];				tree[nodes][0]=2;				tree[nodes][1]=otu2;				tree[nodes][2]=otu;				++nodes;				if (otu2==0)	found0=1;				otu2=otu;				}	/* new node added */			}		}	}/* make sure that oldest species is included in the tree somewhere **/if (found0==0)	{	otu=0;	d=chucks;	for (otu2=1; otu<OTUs; ++otu2)	if (pdmat[otu][otu2]<d)		d=pdmat[otu][otu2];	for (otu2=1; otu<OTUs; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			tree[nodes][0]=2;			tree[nodes][1]=0;			tree[nodes][2]=otu2;			commonanc[nodes]=camat[0][otu2];			++nodes;			}		}	found0=1;	}	mxdv=2;for (a=0; a<nodes; ++a)	if (tree[a][0]>mxdv)	mxdv=tree[a][0];/*****  Sort Clades by Last Common Ancestor	*****/for (testnode=0; testnode<nodes; ++testnode)	{	d=commonanc[c=testnode];	for (clade=testnode+1; clade<nodes; ++clade)		if (commonanc[clade] <= d) d=commonanc[c=clade];	if (c != testnode)	{		commonanc[c]=commonanc[testnode];		commonanc[testnode]=d;		for (sp=0; sp<=mxdv; ++sp)	{			d=tree[testnode][sp];			tree[testnode][sp]=tree[c][sp];			tree[c][sp]=d;			}		}	}/**** WRITE OUT TREE ****/for (testnode=nodes-1; testnode>0; --testnode)	{	found=0;	sp=tree[testnode][1];	htu=testnode+OTUs;	for (plesion=testnode-1; found==0 && plesion>=0; --plesion)	{		for (a=1; a<=tree[plesion][0]; ++a)	{			sp2=tree[plesion][a];			/* ancestral node found */			if (sp2==sp)	{				if (sp<OTUs)	{					for (b=a+1; tree[plesion][b]<htu && b<=tree[plesion][0]; ++b)						tree[plesion][b-1]=tree[plesion][b];					tree[plesion][b-1]=htu;					}				/* different routine needed if clade */				else	{					oldfirst=tree[plesion][1];					for (b=a; tree[plesion][b-1]>htu; --b)	{						tree[plesion][b]=tree[plesion][b-1];						}					tree[plesion][b]=htu;					/* if first species was a clade but now is another clade */					/*   then the old must be replaced */					if (b==1 && oldfirst==tree[plesion][2])	{						sp=tree[plesion][2];						htu=tree[plesion][1];						}					}				/* if the first species was found, then it will be in lower clades 						*/				/* this means that the tree needs to be re-written or this node will never find a home  */				/*   So, swap the that species with the first species in tree[plesion] 					*/				/*     if a clade replaces a clade, htu remains unchanged */				if (a==1 || b==1)					htu=tree[plesion][1];				else					found=1;				a=tree[plesion][0];	/* end search */				}	/* end replacement of taxon within clade by node or new representative species */			}	/* end search of species within a lower node */		}	/* end search of nodes */	}		/************************  Determine Branch Lengths  ************************/for (a=0; a<OTUs; ++a)					bl[a] = obsbl[a];for (a=OTUs; a<(OTUs+nodes); ++a)		bl[a] = 0;/***    Replace Branch lengths from sampled Ancestors to Nodes    ***/ for (sp=0; sp<OTUs; ++sp)	{	if (f1[sp]>0)	{		for (b=0; b<nodes; ++b)	{			if (commonanc[b]==observed[sp])	{				bl[b+OTUs] = bl[sp];				bl[sp] = 0;				}			}		}	}/***   Nodes Subsume the Apomorphies of their Unsampled Immediate Ancestors   ***/ for (clade=nodes-1; clade>=0; --clade)	{	while (bl[clade+OTUs]>0 && clade>0)	--clade;	if (clade<0)	break;	found=0;	anc=commonanc[clade];	for (a=0; (found==0 && anc>-1); ++a)	{		++bl[clade+OTUs];		for (b=0; b<OTUs; ++b)	{			/* if ancestor is observed, prepare to stop the loop */			if (observed[b]==anc)	{				found=1;				b=OTUs;				}			/* once species are older than ancestor, abandon search to speed loop */			else if (observed[b]>anc)	b=OTUs;			}		anc=ancestor[anc];		}	}/* add branch lengths to tree  */for (a=0; a<OTUs; ++a)	tree[OTUs-1][a]=bl[a];for (b=0; b<nodes; ++b)	{	a=OTUs+b;	tree[OTUs][b]=bl[a];	}/* add first and last appearances to tree  */for (a=0; a<OTUs; ++a)	{	tree[OTUs+1][a]=fa[a];	tree[OTUs+2][a]=la[a];	}free_ivector(observed);free_ivector(commonanc);free_ivector(obsbl);free_ivector(fa);free_ivector(la);free_ivector(bl);free_ivector(ancestor);free_imatrix(forefathers,OTUs,chucks+1);free_ivector(f1);free_ivector(dbas);	free_dvector(tor);free_dvector(tex);free_imatrix(pdmat,otu,otu);free_imatrix(camat,otu,otu);return tree;}/**** 2014-01-31: REDONE based on original evolvetree, branch-length information removed	****/// /* evolvetreeprop - Evolves a paleontological tree, with notu taxa sampled over time/* Requires:	notu - # of sampled taxa/*				MBL - simulation parameters where	 				MBL[0] (lmbd) - Speciation rate/*					MBL[1] (mu) - Extinction rate/*					MBL[2] (fr) - Preservation rate/*					MBL[3] (vr) - Variance in preservation rate/*					MBL[4] (speciation) - (1) bifurcation (0) budding cladogenesis				FOSSILS - (1) fossils sampled, (0) no fossils sampled/* Major Rewrite of Sampled Tree Construction 02/2003/* Rewritten to use real numbers from a single array (MBL)/* Returns: proportion of evolved taxa required to sample notu (i.e., sampling intensity)******************************************************************************************************/double evolvetreeprop(int OTUs, double *MBL, int FOSSILS){long	attempts, base=100000, speciation;int		a, b, c, d, ee, charstandard, ch, latest, mxdv=6, brats;int		otu, sampled, initdiv, standingdiv, cumulativediv, stage, newby;int		species, anc, change;int		reboot;int		sp;int		mxtaxa, mxstnd;int		*f1, *ancestor;int		*extants, *observed, *commonanc, *bl;int		*fa, *la, *dbas;//int		*deleteme, cut, *obsbl;double	lmbd, mu, fr, vr, vfr, frp;double	speciate, extinct, find;double	*tor, *tex;double	v, x, y, mod;lmbd=MBL[0];mu=MBL[1];fr=MBL[2];vr=MBL[3];if (vr<1)	vr=MBL[3]=1.0f;speciation=MBL[4];v=expectedpropsampled(MBL[1],MBL[2]);v=1/v;mxtaxa=10*v*OTUs;if (mxtaxa>30000)	mxtaxa=30000;/*if (FOSSILS=1)	mxstnd=2*OTUs;	*//*else			mxstnd=3*OTUs;		*/mxstnd=3*OTUs;/* arrays for observed taxa - set to OTUs*/observed=ivector(OTUs);		/* observed (sampled) taxa 					*/fa=ivector(OTUs);			/* first appearance of a taxon				*/la=ivector(OTUs);			/* last appearance of a taxon				*//*obsbl=ivector(OTUs);		/* branch lengths of sampled taxa			*/commonanc=ivector(2*OTUs);	/* ancestors of a taxon						*/dbas=ivector(OTUs);			/* patristic distance from base to taxon	*/bl=ivector(2*OTUs);			/* array for all elements of the tree 		*/extants = ivector(mxstnd+1);	/* array for standing taxa - set to mxstnd*/	/* arrays for sampled and unsampled taxa - set to mxtaxa */ancestor=ivector(mxtaxa);	/* ancestor of each taxon 					*/f1=ivector(mxtaxa);			/* number of descendants for each taxon 	*/tor=dvector(mxtaxa);		/* true origination - this is a real number */tex=dvector(mxtaxa);		/* true extinction - this is a real number 	*/reboot=0;a=b=c=d=ee=anc=0;charstandard = 1; /*charbase/100;*/sp = ch = change = find = 0;clearivector(observed,OTUs,-1);//clearivector(obsbl,OTUs,-1);clearivector(ancestor,mxtaxa,-1);clearivector(extants,mxstnd+1,-1);latest = -1;attempts = initdiv = standingdiv = cumulativediv = stage = extants[0] = sampled = 0;/* use this to calculate how long the species will live */extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);while (extinct<=0)	extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);tex[0]=(log(1-extinct)/log(1-mu));tor[0]=0.0f;		/*added 2014-01-13	*/while (sampled < OTUs)	{	initdiv = standingdiv+1;	for (sp=0; (sp<=standingdiv && cumulativediv<mxtaxa); ++sp)	{	/********************************************/	/*			Does Lineage Speciate?			*/	/********************************************/		if (sp<0 || sp>mxstnd)	{			printf("ERROR 108: %d is the wrong number of species!\n", sp);			exit(0);			}		species = extants[sp];/*		mod=1.0f;	*//*		if (tor[species]>stage)	*//*			mod=(stage+1)-tor[species];	/* mod reflects shortened time for extinction and speciation *//*		/*		v=1-pow((1-mu),mod);	/* this will equal mu if it survives the whole interval *//*		/* if v is still less than extinction rate, then the species dies this interval *//*		if (extinct<v)	{*//*			/* now randomly generate a number to show when it dies *//*			x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);*//*			/* if it existed at the beginning		*//*			if (tor[species]<=stage)	tex[species]+=x;*//*			/* if it originated durign this stage	*/ /*			else						tex[species]+=x*(((double) (stage+1))-tor[species]);*//*			}*//*		/* if it survies, then bump the extinction to the next interval	*//*		else							tex[species]=stage+1;	*/				if (f1[species]<mxdv)	speciate = (((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		else					speciate = 1.0f;				/* do this to shake up random number generator */		if (sp%2==0)			speciate=1-speciate;		v=lmbd;		if (tex[species]<(stage+1) || tor[species]>stage)	{			if (tex[species]<(stage+1) && tor[species]>stage)											mod=tex[species]-tor[species];			else if (tor[species]<stage)	mod=tex[species]-stage;			else if (tex[species]>stage+1)	mod=((double) (stage+1))-tor[species];			v=1-pow((1-lmbd),mod);	/* this will equal lmbd if it survives the whole interval */									/* (1-lmbd) is prob. of not speciating; 										(1-lmbd)^mod = prob of not speciating over mod										1-([1-lmbd]^mod) = prob. of speciating over mod	*/			}	/* end case for taxa present during only part of "stage"	*/		if (speciation==1)	ee=2;		else				ee=1;		if (speciate <= v && (standingdiv<(mxstnd-ee)))		{			brats=1;			/* if bifurcation, then two descendants when ancestor disappears		*/			if (speciation==1)	brats=2;			/* if budding, then allow for multiple descendants at different times 	*/			else	{				if (tor[species]>stage)	v=(stage+1)-tor[species];				else					v=1;				x=Poisson(lmbd, v, 2);				if (v<x)				brats=2;				}			/* go through each descendant */			for (a=0; a<brats; ++a)	{				++standingdiv;				++cumulativediv;				extants[standingdiv] = cumulativediv;				if (cumulativediv > mxtaxa)	{					printf("ERROR Evolve 187 - In replication XXX");					printf(", more than %3d species were generated.  \n",mxtaxa);					sampled=OTUs;					exit(0);						}				if (standingdiv<0 || standingdiv>mxstnd)	{					printf("ERROR 193:  Standing diversity too high at %2d\n",standingdiv);					sampled=OTUs;					exit(0);						}							if (cumulativediv<0 || cumulativediv>=mxtaxa || species<0 || species>=mxtaxa)	{					printf("ERROR 198 - ancestor index out of range at %d and %d\n",species,cumulativediv);					sampled=OTUs;					exit(0);						}				ancestor[cumulativediv] = species;				anc = species;				++f1[anc];						/*******************************************************************************/		/* Ancestors become pseudo-extinct at bifurcation if that is what is happening */		/*******************************************************************************/				if (speciation==0 || (speciation==1 && a==0))	{					y=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					/* if ancestor originated during stage and extends into the next	*/					if (tex[anc]>stage+1 && tor[anc]>stage)						tor[cumulativediv]=tor[anc]+(y*((stage+1)-tor[anc]));					/* if ancestor goes extinct during stage and originated before it	*/					else if (tex[anc]<(stage+1) && tor[anc]<stage)						tor[cumulativediv]=stage+(y*(tex[anc]-stage));					/* if ancestor both originates and goes extinct during stage		*/					else if (tex[anc]<(stage+1) && tor[anc]>stage)						tor[cumulativediv]=tor[anc]+(y*(tex[anc]-tor[anc]));					else						tor[cumulativediv]=y+ ((double) stage);										/* if we are dealing with the first species of a bifurcation, give it ancestral extinction time.	*/					/* 		Ancestor disappears when descendants arise													*/ 					if (speciation==1)	{						tex[cumulativediv]=tex[anc];						tex[anc]=tor[cumulativediv];						}					}				/* second species of a bifurcation */				else if (a==1)	tor[cumulativediv]=tex[anc];								/* establish extinction if the species becomes extinct */				if (speciation==0 || (speciation ==1 && a==1))	{					/* if we are dealing with the second species, then give it its own extinction time but the same origination time */					extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					tex[cumulativediv]=tor[cumulativediv]+(log(1-extinct)/log(1-mu));					}				}			}		if (FOSSILS==0 && standingdiv>=OTUs-1)	sp = initdiv;	/* quit if enough taxa are alive */		}	/****  End Speciation Round ****/ 				if (FOSSILS==1)	{		/********************************************/		/*				 Do Sampling				*/		/*  Separated from Speciation Loop 1/3/97   */		/********************************************/		if (sampled < OTUs)	{			for (sp=0; sp<=standingdiv; ++sp)	{				species = extants[sp];								/* Raw Species Number *//*				find = (((unsigned int) rand())%base)+1;	*//*				if (f1[species]>=3 || cumulativediv>=(3*mxstnd))	find = 0;	*/				find=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				/* do this to shake up the random number generator */				if (sp%2==0)	find=1-find;								/* insert lognormal part here	*/				x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				y=normsinv(x);				vfr=pow(vr,y);				v=fr*vfr;				frp=log(1-(fr*vfr));				/* 2012-01-10: Poisson expectation so that P[0 | 1 stage, fr] = 1=fr	*/											/* keep this here so that we can handle variable sampling				*/				if (tex[species]<(stage+1) || tor[species]>stage)	{					/* if species originates and disappears in this interval 			*/					if (tex[species]<(stage+1) && tor[species]>stage)														mod=tex[species]-tor[species];					/* if species originated earlier but goes extinct in this interval	*/					else if (tex[species]<(stage+1))	mod=tex[species]-stage;					/* if species goes extinct later but originates in this interval	*/					else if (tex[species]>(stage+1))	mod=((double) (stage+1))-tor[species];					v=1-pow(1-(fr*vfr),mod);	/* this will equal fr*vfr if it survives the whole interval */												/*	(1-[fr*vfr]) = prob. of missing over whole interval													(1-[fr*vfr])^mod = prob. of missing over mod.  	*/					}						if (find <= v)	{					newby = 0;					/** First sampled species goes straight into the array **/					if (sampled==0)	{						observed[sampled]=species;						fa[sampled]=la[sampled]=stage;						++sampled;						}					/** Test whether a sampled species had gone unsampled **/					else	{						for (otu = 0; otu < sampled;  ++otu)	{							if (observed[otu] == species)	{								newby = 1;		/* species is not new */								la[otu]=stage;								otu = sampled;								}							}						if (newby == 0 && sampled < OTUs)	{							/* sort species as you go */							a=sampled-1;							while (observed[a]>species && a>=0)	{								observed[a+1]=observed[a];								fa[a+1]=fa[a];								la[a+1]=la[a];								--a;								}							observed[a+1] = species;							fa[a+1]=la[a+1]=stage;							++sampled;							if (sampled<0 || sampled>OTUs)	{								printf("ERROR 189: You somehow sampled %d\n",sampled);								exit(0);								}							if (sampled==OTUs)		sp = standingdiv;							}						}					latest = observed[sampled-1];					}	/* End Tallying of Sampled Horizon	*/				}	/*  End Sampling for Each Horizon	*/			}	/* only do test while we need to sampled taxa */		}	/* only sample if we are including fossils	*/			else {		sampled = standingdiv;		/* if there are no fossils, "present" is when									   OTUs taxa evolve */		if (sampled==OTUs-1)	for (sp=0; sp<OTUs; ++sp)	observed[sp]=extants[sp];		}	if (sampled>=OTUs)	break;	/* don't bother with the rest if done */			/* cull species that went extinct */	for (a=0; a<=standingdiv; ++a)	{		sp=extants[a];		if (tex[sp]<(stage+1))	{			for (b=a+1; b<=standingdiv; ++b)	extants[b-1]=extants[b];			extants[standingdiv]=-1;			--standingdiv;			--a;			}		}		initdiv=standingdiv;				/****** REBOOT ROUTINE ******/	if (standingdiv < 0 || (cumulativediv>=mxtaxa && sampled < OTUs))	{		latest = -1;		/* clear vectors set to maxtaxa */		for (sp=0; sp<cumulativediv; ++sp)	{			ancestor[sp]=tex[sp]=tor[sp]=-1;			f1[sp]=0;		/* altered 2014-01-13	*/			}		/* clear vectors set to OTUs */		for (sp=0; sp<sampled; ++sp)			fa[sp]=la[sp]=observed[sp]=-1;				standingdiv = initdiv = cumulativediv = extants[0] = sampled = 0;		stage = 0;		++attempts;		/* use this to calculate how long the species will live */		extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		tex[0]=(log(1-extinct)/log(1-mu));		tor[0]=0.0f;		/*added 2014-01-13	*//*		if ((attempts%5)==0)	printf ("%2d tries and counting.\n",attempts); */		}				/** Reboot simulation **/	else	{		if (sampled < OTUs)	++stage;		/*  All OTUs species found	*/		else if (FOSSILS==0 && cumulativediv==((2*OTUs)-2))	{			for (sp=0; sp<=standingdiv; ++sp)		observed[sp] = extants[sp];			sampled = OTUs;			reboot=1;			}		/* if species index is out of range, then reboot the whole thing */		}	}free_ivector(observed);free_ivector(fa);free_ivector(la);free_ivector(bl);free_ivector(extants);free_ivector(ancestor);free_ivector(f1);free_dvector(tor);free_dvector(tex);	return ((double) (OTUs-1))/((double) latest-1);}long **evolvetreematchrecord(int OTUs, double *MBL, long **ranges){long	attempts, base=100000, speciation;int		a, b, c, d, ee, charstandard, ch, latest, mxdv=6, chucks, brats;int		clade, otu, otu2, htu, sampled, initdiv, standingdiv, cumulativediv, stage, newby;int		species, anc, change, testnode, plesion, found0, oldfirst;int		reboot;int		sp, sp2, nodes, found;int		mxtaxa, mxstnd;int		*f1, **forefathers, *ancestor;int		*extants, *observed, *obsbl, *commonanc, *bl;int		*fa, *la, *dbas;int		**pdmat, **camat;int 	FOSSILS=1;long	**tree;double	lmbd, mu, fr, vr, vfr, frp;double	speciate, extinct, find;double	*tor, *tex;double	v, x, y, mod;lmbd=MBL[0];mu=MBL[1];fr=MBL[2];vr=MBL[3];if (vr<1)	vr=MBL[3]=1.0f;speciation=MBL[4];v=expectedpropsampled(MBL[1],MBL[2]);v=1/v;a=ranges[0][0];mxtaxa=10*v*OTUs;if (mxtaxa>30000)	mxtaxa=30000;/*if (FOSSILS=1)	mxstnd=2*OTUs;	*//*else			mxstnd=3*OTUs;		*/mxstnd=3*OTUs;/* arrays for observed taxa - set to OTUs*/observed=ivector(OTUs);		/* observed (sampled) taxa 					*/fa=ivector(OTUs);			/* first appearance of a taxon				*/la=ivector(OTUs);			/* last appearance of a taxon				*/obsbl=ivector(OTUs);		/* branch lengths of sampled taxa			*/commonanc=ivector(2*OTUs);	/* ancestors of a taxon						*/dbas=ivector(OTUs);			/* patristic distance from base to taxon	*/bl=ivector(2*OTUs);			/* array for all elements of the tree 		*/extants = ivector(mxstnd+1);	/* array for standing taxa - set to mxstnd*/	/* arrays for sampled and unsampled taxa - set to mxtaxa */ancestor=ivector(mxtaxa);	/* ancestor of each taxon 					*/f1=ivector(mxtaxa);			/* number of descendants for each taxon 	*/tor=dvector(mxtaxa);		/* true origination - this is a real number */tex=dvector(mxtaxa);		/* true extinction - this is a real number 	*/reboot=0;a=b=c=d=ee=anc=0;charstandard = 1; /*charbase/100;*/sp = ch = change = find = 0;clearivector(observed,OTUs,-1);clearivector(obsbl,OTUs,-1);clearivector(ancestor,mxtaxa,-1);clearivector(extants,mxstnd+1,-1);latest = -1;attempts = initdiv = standingdiv = cumulativediv = stage = extants[0] = sampled = 0;/* use this to calculate how long the species will live */extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);tex[0]=(log(1-extinct)/log(1-mu));tor[0]=0.0f;			/* added 2014-01-13	*/while (sampled < OTUs)	{	initdiv = standingdiv+1;	for (sp=0; (sp<=standingdiv && cumulativediv<mxtaxa); ++sp)	{	/********************************************/	/*			Does Lineage Speciate?			*/	/********************************************/		if (sp<0 || sp>mxstnd)	{			printf("ERROR 108: %d is the wrong number of species!\n", sp);			exit(0);			}		species = extants[sp];/*		mod=1.0f;	*//*		if (tor[species]>stage)	*//*			mod=(stage+1)-tor[species];	/* mod reflects shortened time for extinction and speciation *//*		/*		v=1-pow((1-mu),mod);	/* this will equal mu if it survives the whole interval *//*		/* if v is still less than extinction rate, then the species dies this interval *//*		if (extinct<v)	{*//*			/* now randomly generate a number to show when it dies *//*			x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);*//*			/* if it existed at the beginning		*//*			if (tor[species]<=stage)	tex[species]+=x;*//*			/* if it originated durign this stage	*/ /*			else						tex[species]+=x*(((double) (stage+1))-tor[species]);*//*			}*//*		/* if it survies, then bump the extinction to the next interval	*//*		else							tex[species]=stage+1;	*/				if (f1[species]<mxdv)	speciate = (((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		else					speciate = 1.0f;				/* do this to shake up random number generator */		if (sp%2==0)			speciate=1-speciate;		v=lmbd;		if (tex[species]<(stage+1) || tor[species]>stage)	{			if (tex[species]<(stage+1) && tor[species]>stage)											mod=tex[species]-tor[species];			else if (tor[species]<stage)	mod=tex[species]-stage;			else if (tex[species]>stage+1)	mod=((double) (stage+1))-tor[species];			v=1-pow((1-lmbd),mod);	/* this will equal lmbd if it survives the whole interval */			}		if (speciation==1)	ee=2;		else				ee=1;		if (speciate <= v && (standingdiv<(mxstnd-ee)))		{			brats=1;			/* if bifurcation, then two descendants when ancestor disappears		*/			if (speciation==1)	brats=2;			/* if budding, then allow for multiple descendants at different times 	*/			else	{				if (tor[species]>stage)	v=(stage+1)-tor[species];				else					v=1;				x=Poisson(lmbd, v, 2);				if (v<x)				brats=2;				}			/* go through each descendant */			for (a=0; a<brats; ++a)	{				++standingdiv;				++cumulativediv;				extants[standingdiv] = cumulativediv;				if (cumulativediv > mxtaxa)	{					printf("ERROR Evolve 180 - In replication XXX");					printf(", more than %3d species were generated.  \n",mxtaxa);					sampled=OTUs;					exit(0);						}				if (standingdiv<0 || standingdiv>mxstnd)	{					printf("ERROR 186:  Standing diversity too high at %2d\n",standingdiv);					sampled=OTUs;					exit(0);						}							if (cumulativediv<0 || cumulativediv>=mxtaxa || species<0 || species>=mxtaxa)	{					printf("ERROR 191 - ancestor index out of range at %d and %d\n",species,cumulativediv);					sampled=OTUs;					exit(0);						}				ancestor[cumulativediv] = species;				anc = species;				++f1[anc];						/*******************************************************************************/		/* Ancestors become pseudo-extinct at bifurcation if that is what is happening */		/*******************************************************************************/				if (speciation==0 || (speciation==1 && a==0))	{					y=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					/* if ancestor originated during stage and extends into the next	*/					if (tex[anc]>stage+1 && tor[anc]>stage)						tor[cumulativediv]=tor[anc]+(y*((stage+1)-tor[anc]));					/* if ancestor goes extinct during stage and originated before it	*/					else if (tex[anc]<(stage+1) && tor[anc]<stage)						tor[cumulativediv]=stage+(y*(tex[anc]-stage));					/* if ancestor both originates and goes extinct during stage		*/					else if (tex[anc]<(stage+1) && tor[anc]>stage)						tor[cumulativediv]=tor[anc]+(y*(tex[anc]-tor[anc]));					else						tor[cumulativediv]=y+ ((double) stage);										/* if we are dealing with the first species of a bifurcation, give it ancestral extinction time.	*/					/* 		Ancestor disappears when descendants arise													*/ 					if (speciation==1)	{						tex[cumulativediv]=tex[anc];						tex[anc]=tor[cumulativediv];						}					}				/* second species of a bifurcation */				else if (a==1)	tor[cumulativediv]=tex[anc];								/* establish extinction if the species becomes extinct */				if (speciation==0 || (speciation ==1 && a==1))	{					/* if we are dealing with the second species, then give it its own extinction time but the same origination time */					extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					tex[cumulativediv]=tor[cumulativediv]+(log(1-extinct)/log(1-mu));					}				}			}		if (FOSSILS==0 && standingdiv>=OTUs-1)	sp = initdiv;	/* quit if enough taxa are alive */		}	/****  End Speciation Round ****/ 				if (FOSSILS==1)	{		/********************************************/		/*				 Do Sampling				*/		/*  Separated from Speciation Loop 1/3/97   */		/********************************************/		if (sampled < OTUs)	{			for (sp=0; sp<=standingdiv; ++sp)	{				species = extants[sp];								/* Raw Species Number *//*				find = (((unsigned int) rand())%base)+1;	*//*				if (f1[species]>=3 || cumulativediv>=(3*mxstnd))	find = 0;	*/				find=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				/* do this to shake up the random number generator */				if (sp%2==0)	find=1-find;								/* insert lognormal part here	*/				x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				y=normsinv(x);				vfr=pow(vr,y);				v=fr*vfr;				frp=log(1-(fr*vfr));				/* 2012-01-10: Poisson expectation so that P[0 | 1 stage, fr] = 1=fr	*/											/* keep this here so that we can handle variable sampling				*/				if (tex[species]<(stage+1) || tor[species]>stage)	{					/* if species originates and disappears in this interval 			*/					if (tex[species]<(stage+1) && tor[species]>stage)														mod=tex[species]-tor[species];					/* if species originated earlier but goes extinct in this interval	*/					else if (tex[species]<(stage+1))	mod=tex[species]-stage;					/* if species goes extinct later but originates in this interval	*/					else if (tex[species]>(stage+1))	mod=((double) (stage+1))-tor[species];					v=1-pow(1-(fr*vfr),mod);/*					v=1-pow((fr*vfr),mod);	/* this will equal lmbd if it survives the whole interval */					}						if (find <= v)	{					newby = 0;					/** First sampled species goes straight into the array **/					if (sampled==0)	{						observed[sampled]=species;						fa[sampled]=la[sampled]=stage;						++sampled;						}					/** Test whether a sampled species had gone unsampled **/					else	{						for (otu = 0; otu < sampled;  ++otu)	{							if (observed[otu] == species)	{								newby = 1;		/* species is not new */								la[otu]=stage;								otu = sampled;								}							}						if (newby == 0 && sampled < OTUs)	{							/* sort species as you go */							a=sampled-1;							while (observed[a]>species && a>=0)	{								observed[a+1]=observed[a];								fa[a+1]=fa[a];								la[a+1]=la[a];								--a;								}							observed[a+1] = species;							fa[a+1]=la[a+1]=stage;							++sampled;							if (sampled<0 || sampled>OTUs)	{								printf("ERROR 189: You somehow sampled %d\n",sampled);								exit(0);								}							if (sampled==OTUs)		sp = standingdiv;							}						}					latest = observed[sampled-1];					}	/* End Tallying of Sampled Horizon	*/				}	/*  End Sampling for Each Horizon	*/			}	/* only do test while we need to sampled taxa */		}	/* only sample if we are including fossils	*/			else {		sampled = standingdiv;		/* if there are no fossils, "present" is when									   OTUs taxa evolve */		if (sampled==OTUs-1)	for (sp=0; sp<OTUs; ++sp)	observed[sp]=extants[sp];		}	if (sampled>=OTUs)	break;	/* don't bother with the rest if done */			/* cull species that went extinct */	for (a=0; a<=standingdiv; ++a)	{		sp=extants[a];		if (tex[sp]<(stage+1))	{			for (b=a+1; b<=standingdiv; ++b)	extants[b-1]=extants[b];			extants[standingdiv]=-1;			--standingdiv;			--a;			}		}		initdiv=standingdiv;				/****** REBOOT ROUTINE ******/	if (standingdiv < 0 || (cumulativediv>=mxtaxa && sampled < OTUs))	{		latest = -1;		/* clear vectors set to maxtaxa */		for (sp=0; sp<cumulativediv; ++sp)			ancestor[sp]=tex[sp]=tor[sp]=f1[sp]=-1;		/* clear vectors set to OTUs */		for (sp=0; sp<sampled; ++sp)			fa[sp]=la[sp]=observed[sp]=-1;				standingdiv = initdiv = cumulativediv = extants[0] = sampled = 0;		stage = 0;		++attempts;		/* use this to calculate how long the species will live */		extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		tex[0]=(log(1-extinct)/log(1-mu));		tor[0]=0.0f;			/* added 2014-01-13	*//*		if ((attempts%5)==0)	printf ("%2d tries and counting.\n",attempts); */		}				/** Reboot simulation **/	else	{		if (sampled < OTUs)	++stage;		/*  All OTUs species found	*/		else if (FOSSILS==0 && cumulativediv==((2*OTUs)-2))	{			for (sp=0; sp<=standingdiv; ++sp)		observed[sp] = extants[sp];			sampled = OTUs;			reboot=1;			}		/* if species index is out of range, then reboot the whole thing */		}	}mxdv=1+maxiarray(f1,cumulativediv);/* tree matrix - rows 0...(OTUs-1) rows are for possible nodes	*//*		row OTUs-1 is for species branch lengths				*//*		row OTUs   is for nodal branch lengths					*//*		row OTUs+1 is for species FAs							*//*		row OTUs+2 is for species LAs							*//*		the first cell of rows 0…(OTUs-1) give # branches		*//*			(i.e., 2 for bifurcation w. no sampled ancestor)	*/tree=lmatrix(OTUs+3,OTUs);clearlmatrix(tree,OTUs+3,OTUs,-1);for (a=cumulativediv+1; a<mxtaxa; ++a)	f1[a]=ancestor[a]=0;if (observed[0]==-1)	{	printf("Taxa lost by line 377\a\n");	exit(0);	}/*********************************************************************************//*								Store True Phylogeny							 *//*********************************************************************************//**** LIST ANCESTORS OF EACH OBSERVED SPECIES ****/chucks=0;ancestor[0]=-1;/* find the distance from the base for each species */for (otu=0; otu<OTUs; ++otu)	{	sp=observed[otu];	anc=ancestor[sp];	if (anc>=0)		dbas[otu]=1;	for (a=1; anc>=0; ++a)	{		anc=ancestor[anc];		++dbas[otu];		}	}/* count the maximum number of ancestors */chucks=maxiarray(dbas,otu);/* list all of the ancestors for each species */forefathers=imatrix(OTUs,chucks+1);clearimatrix(forefathers,OTUs,chucks+1,-1);ancestor[0]=-1;for (otu=0; otu<OTUs; ++otu)	{	forefathers[otu][0]=sp=observed[otu];	anc=ancestor[sp];	for (a=1; anc>=0; ++a)	{		forefathers[otu][a]=anc;		anc=ancestor[anc];		}	}/* list the unsampled ancestors of each species *//* also, tally species with sampled descendants */free_ivector(f1);f1=ivector(OTUs);	/* 0: no sampled descendants; 1: 1+ sampled descendants */for (otu=0; otu<OTUs; ++otu)	{	obsbl[otu]=1;	found=0;	for (a=1; a<dbas[otu]; ++a)	{		anc=forefathers[otu][a];		for (b=otu-1; b>=0; --b)	{			if (observed[b]==anc)	{				found=1;				f1[b]=1;				/* end loops */				b=0;				a=dbas[otu];				}			}		if (found==0)	++obsbl[otu];		}	}/* create a matrix of branch distances between taxa *//* this gives distance to common ancestor, so the matrix is asymmetrical */pdmat=imatrix(otu,otu);camat=imatrix(otu,otu);for (otu=OTUs-1; otu>0; --otu)	{	for (otu2=otu-1; otu2>=0; --otu2)	{		for (a=0; a<=dbas[otu]; ++a)	{			sp=forefathers[otu][a];			for (b=0; b<=dbas[otu2]; ++b)	{				sp2=forefathers[otu2][b];				if (sp==sp2)	{					pdmat[otu][otu2]=a+1;					pdmat[otu2][otu]=b+1;					camat[otu][otu2]=camat[otu2][otu]=sp;					/* end loop */					b=dbas[otu2];					a=dbas[otu];					}				/* end loop if forefather[otu][a] cannot match forefather[otu2][any] */				else if (sp>sp2)	b=dbas[otu2];				}			}		}	}/* create a tree *//* keep track of common ancestors of each clade */nodes=found0=0;for (otu=OTUs-1; otu>0; --otu)	{	d=chucks;	for (otu2=otu-1; otu2>=0; --otu2)	{		if (pdmat[otu][otu2]<d)	{			d=pdmat[otu][otu2];			}		}	for (otu2=0; otu2<otu; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			anc=camat[otu][otu2];			found=-1;			for (a=0; a<nodes; ++a)	{				/* existing nodes found */				if (commonanc[a]==camat[otu][otu2])	{					found=0;					/* check to see if the species already is in the nodes */					for (b=1; b<=tree[a][0]; ++b)	{						if (otu2==tree[a][b])		found=1;						}					if (found==0)	{						for (b=1; b<=tree[a][0]; ++b)	{							if (otu==tree[a][b])	found=2;							}						}					/* if neither species already found */					if (found==0)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					/* if older species already found */					else if (found==1)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						}					/* if younger species already found */					else if (found==2)	{						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					a=nodes+1;					otu2=otu;					}				}	/* end search for previously found node */			/* new nodes found */			if (found==-1)	{				commonanc[nodes]=camat[otu][otu2];				tree[nodes][0]=2;				tree[nodes][1]=otu2;				tree[nodes][2]=otu;				++nodes;				if (otu2==0)	found0=1;				otu2=otu;				}	/* new node added */			}		}	}/* make sure that oldest species is included in the tree somewhere **/if (found0==0)	{	otu=0;	d=chucks;	for (otu2=1; otu<OTUs; ++otu2)	if (pdmat[otu][otu2]<d)		d=pdmat[otu][otu2];	for (otu2=1; otu<OTUs; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			tree[nodes][0]=2;			tree[nodes][1]=0;			tree[nodes][2]=otu2;			commonanc[nodes]=camat[0][otu2];			++nodes;			}		}	found0=1;	}	mxdv=2;for (a=0; a<nodes; ++a)	if (tree[a][0]>mxdv)	mxdv=tree[a][0];/*****  Sort Clades by Last Common Ancestor	*****/for (testnode=0; testnode<nodes; ++testnode)	{	d=commonanc[c=testnode];	for (clade=testnode+1; clade<nodes; ++clade)		if (commonanc[clade] <= d) d=commonanc[c=clade];	if (c != testnode)	{		commonanc[c]=commonanc[testnode];		commonanc[testnode]=d;		for (sp=0; sp<=mxdv; ++sp)	{			d=tree[testnode][sp];			tree[testnode][sp]=tree[c][sp];			tree[c][sp]=d;			}		}	}/**** WRITE OUT TREE ****/for (testnode=nodes-1; testnode>0; --testnode)	{	found=0;	sp=tree[testnode][1];	htu=testnode+OTUs;	for (plesion=testnode-1; found==0 && plesion>=0; --plesion)	{		for (a=1; a<=tree[plesion][0]; ++a)	{			sp2=tree[plesion][a];			/* ancestral node found */			if (sp2==sp)	{				if (sp<OTUs)	{					for (b=a+1; tree[plesion][b]<htu && b<=tree[plesion][0]; ++b)						tree[plesion][b-1]=tree[plesion][b];					tree[plesion][b-1]=htu;					}				/* different routine needed if clade */				else	{					oldfirst=tree[plesion][1];					for (b=a; tree[plesion][b-1]>htu; --b)	{						tree[plesion][b]=tree[plesion][b-1];						}					tree[plesion][b]=htu;					/* if first species was a clade but now is another clade */					/*   then the old must be replaced */					if (b==1 && oldfirst==tree[plesion][2])	{						sp=tree[plesion][2];						htu=tree[plesion][1];						}					}				/* if the first species was found, then it will be in lower clades 						*/				/* this means that the tree needs to be re-written or this node will never find a home  */				/*   So, swap the that species with the first species in tree[plesion] 					*/				/*     if a clade replaces a clade, htu remains unchanged */				if (a==1 || b==1)					htu=tree[plesion][1];				else					found=1;				a=tree[plesion][0];	/* end search */				}	/* end replacement of taxon within clade by node or new representative species */			}	/* end search of species within a lower node */		}	/* end search of nodes */	}		/************************  Determine Branch Lengths  ************************/for (a=0; a<OTUs; ++a)					bl[a] = obsbl[a];for (a=OTUs; a<(OTUs+nodes); ++a)		bl[a] = 0;/***    Replace Branch lengths from sampled Ancestors to Nodes    ***/ for (sp=0; sp<OTUs; ++sp)	{	if (f1[sp]>0)	{		for (b=0; b<nodes; ++b)	{			if (commonanc[b]==observed[sp])	{				bl[b+OTUs] = bl[sp];				bl[sp] = 0;				}			}		}	}/***   Nodes Subsume the Apomorphies of their Unsampled Immediate Ancestors   ***/ for (clade=nodes-1; clade>=0; --clade)	{	while (bl[clade+OTUs]>0 && clade>0)	--clade;	if (clade<0)	break;	found=0;	anc=commonanc[clade];	for (a=0; (found==0 && anc>-1); ++a)	{		++bl[clade+OTUs];		for (b=0; b<OTUs; ++b)	{			/* if ancestor is observed, prepare to stop the loop */			if (observed[b]==anc)	{				found=1;				b=OTUs;				}			/* once species are older than ancestor, abandon search to speed loop */			else if (observed[b]>anc)	b=OTUs;			}		anc=ancestor[anc];		}	}/* add branch lengths to tree  */for (a=0; a<OTUs; ++a)	tree[OTUs-1][a]=bl[a];for (b=0; b<nodes; ++b)	{	a=OTUs+b;	tree[OTUs][b]=bl[a];	}/* add first and last appearances to tree  */for (a=0; a<OTUs; ++a)	{	tree[OTUs+1][a]=fa[a];	tree[OTUs+2][a]=la[a];	}free_ivector(observed);free_ivector(commonanc);free_ivector(obsbl);free_ivector(fa);free_ivector(la);free_ivector(bl);free_ivector(extants);free_ivector(ancestor);free_imatrix(forefathers,OTUs,chucks+1);free_ivector(f1);free_ivector(dbas);	free_dvector(tor);free_dvector(tex);free_imatrix(pdmat,otu,otu);free_imatrix(camat,otu,otu);return tree;}/* evolvetoposmutualcompat - evolves a matrix until it reaches a particular compatibility.  Gaps and missing are kept in place *//* Requires:   tree - a matrix containing every observed descendant of each node		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[nodes]) gives it for species;			the second line (tree[nodes+1]) gives it for internal nodes;	tpmcomp - true possible mutual compatibility that must be evolved (usually based on observed compatibility);	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	maxch - the maximum number of changes for each character;	depend - array giving character dependency (if depend[a]=a then it is independent);	comptype - 0 for normal compatibility, 1 for hierarchical compatibility;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;/* Returns:	simcompat - a compatibility matrix with possible mutual compatibilities = tpmcomp;*******************************************************************************************************************************************/unsigned long **evolvetopossmutualcompat(long **tree, int tpmcomp, int notu, int nodes, long **chmatrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int *depend, int comptype, int UNKNOWN, int INAP){int		a, b, c, d, br, ch, sc, ev, flip, sp, sp2, spmcomp;int		avnodes, deltas, mxdel, ttlbr, ttltx=0, mxdp=1, avch, avbr;int		reboot, trial, trying=0, maxtrial=5;int		lch[1000];int		*availablech, *availablebr, *branches, *steps, *trpd, *mpd, *sychos;/*int		*missing;	*/int		**taxachange, **sychomat;/*, *der, **descnodes, *aptaxa;	/* for debugging */long	**invchmatrix;unsigned long *simcharcomps;unsigned long **simcompat;/* find the number of nodes and their diversities *//*nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}	nodes=cladecountbytaxa(tree,notu);*/mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character */trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */mpd=ivector(nodes+notu);					/* morphologic changes along each branch 						*/steps=ivector(nchars);						/* number of times each character changes 						*//*der=ivector(nchars);						/* number of taxa with derived condition for each character 	*/sychos=ivector(nchars);						/* number of dependendent characters attached to a character 	*//*missing=ivector(nchars);					/* 2011-03-31: # missing or inapplicable taxa for a character	*//* 2011-03-31: tally whether there are missing data for this character	for (ch=0; ch<nchars; ++ch)	{	missing[ch]=0;	for (sp=0; sp<notu && missing[ch]==0; ++sp)	if (chmatrix[sp][ch]==UNKNOWN || chmatrix[sp][ch]==INAP)	missing[ch]=1;	}	*/ for (ch=0; ch<nchars; ++ch)	++sychos[depend[ch]];	/* sychos[x] gives the number of characters dependent on x; if 0 then character is dependent */mxdp=maxiarray(sychos,nchars);						/* b will be the maximum number of dependent characters for any character */if (mxdp>1)	{	sychomat=imatrix(nchars,mxdp);	clearivector(sychos,nchars,0);	for (ch=0; ch<nchars; ++ch)	{		sychomat[depend[ch]][sychos[depend[ch]]]=ch;		++sychos[depend[ch]];		}	}/*descnodes=descendantnodes(tree,notu);	*//*nodestates=lmatrix(nodes,nchars);	*/trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[nodes][sp];		/* array tree[nodes] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	if (trpd[sp]>0)	++ttltx;	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[nodes+1][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	if (trpd[sp+notu]>0)	++ttltx;	}	ttlbr=sumivector(trpd,notu+nodes);	if (ttlbr<mxdel)	mxdel=ttlbr;if (ttltx<mxdel)	mxdel=ttltx;	/* 2014-03-21: we allow only as many changes as there are taxa that have changes	*//* allocate memory for arrays containing branches needing changes */availablech=ivector(nchars);				/* lists each character available to a branch									*/availablebr=ivector(ttlbr);					/* lists each otu & htu once for every branch length; ancestors therefore lost	*/branches=ivector(ttlbr);					/* lists each htu & non-ancestral otu that is scored for a character			*/taxachange=imatrix(10*nchars, 10*mxdel);	/* gives taxa that change for character */invchmatrix=lmatrix(nchars, notu);simcompat=ulmatrix(nchars,nchars);simcharcomps=ulvector(nchars);/*aptaxa=applicabletaxa(chmatrix, nchars, notu, INAP);	*//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********//******* MORE REWRITING 3/31/11: Man, I'm on a road to nowhere!!!		*********/	reboot=0;while (reboot==0)	{	/* determine appropriate branches for changes - all nodes & species without sampled descendants */	/* we'll ignore the basal node, assuming that it is all 0's */	avnodes=b=0;	++trying;							/* 2011-02-07 DEBUGGING	*/	for (a=1; a<nodes; ++a)	{		avnodes=avnodes+trpd[a+notu];		for (c=0; c<trpd[a+notu]; ++c)	{			availablebr[b]=a+notu;			++b;			}		}	for (a=0; a<notu; ++a)	{		for (c=0; c<trpd[a]; ++c)	{			availablebr[b]=a;			++b;			}		}	/* clear chmatrix */	for (ch=0; ch<nchars; ++ch)	{		for (a=0; a<notu; ++a)	{			if (chmatrix[a][ch]!=INAP && chmatrix[a][ch]!=UNKNOWN)	{				chmatrix[a][ch]=0;				}			invchmatrix[ch][a]=chmatrix[a][ch];	/* for debugging */			}		}	clearivector(steps,nchars,0);	clearivector(mpd,notu+nodes,0);		/* 2014-03-19: mpd gives branch length in changes: this must be zero at the outset	*/	clearimatrix(taxachange,nchars,mxdel,0);	deltas=0;	/* Step #2: make sure that each apomorphic species has a derivation */	ensure_apomorphies(chmatrix, invchmatrix, taxachange, nstates, ctype, maxch, steps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);	deltas=sumivector(steps,nchars);		/* Step 1: Make sure each state is derived for each character */	ensure_charstates(chmatrix, invchmatrix, taxachange, nstates, ctype, maxch, steps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);	deltas=sumivector(steps,nchars);	/* Step #3: DO ADDITIONAL STEPS NOW */	trial=0;	makecompatibilitymatrix(simcompat,nstates,notu,chmatrix,ctype,nchars,comptype,0,UNKNOWN,INAP);	for (ch=0; ch<nchars; ++ch)	simcharcomps[ch]=simcompat[ch][ch];//	cmp=nu_comp(nstates, notu, chmatrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);	spmcomp=possiblemutualcompatibilities(simcompat, simcharcomps, nchars);		if (spmcomp>tpmcomp)	{//	if (cmp>tcomp)	{		avch=0;		/* all characters that still can change go into availablech	*/		for (ch=0; ch<nchars; ++ch)	{			if ((ctype[ch]==1 && steps[ch]<maxch[ch]) || (ctype==0 && steps[ch]>(notu/2)))	{				availablech[avch]=ch;				++avch;				}			}		/* 2011-02-07: was trial < 3	*/		for (deltas=deltas; trial < maxtrial && spmcomp!=tpmcomp; deltas=deltas)	{			/* first choose a character */			c=(int)((double)rand() / ((double)RAND_MAX + 1) * avch);			ch=availablech[c];			while (steps[ch]>=ttltx)	{				c=(int)((double)rand() / ((double)RAND_MAX + 1) * avch);				ch=availablech[c];				}						for (sp=0; sp<notu; ++sp)	lch[sp]=chmatrix[sp][ch];		/* record chmatrix as it was	*/			/**************************************************************************/			for (br=0; br<ttlbr; ++br) branches[br]=availablebr[br];			avbr=ttlbr;						/* remove branches where there already has been change	*/			for (a=0; a<steps[ch]; ++a)	{				sp=taxachange[ch][a];				removefromivector(branches,sp,&avbr);				}						br=(int)((double)rand() / ((double)RAND_MAX +1) * avbr);			sp=branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=avbr)	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * avbr);				sp = branches[br];				}			ev=0;			if (nstates[ch]==2)	{				/* routine for binary characters */				if (sp<notu && (chmatrix[sp][ch]!=UNKNOWN && chmatrix[sp][ch]!=INAP))	{					invchmatrix[ch][sp]=chmatrix[sp][ch]=swap(chmatrix[sp][ch]);					ev=1;					}				/* routine for clade */				else if (sp>=notu)	{					evolvebinaryinclade(tree[sp-notu],chmatrix,ch);					for (a=1; a<=tree[sp-notu][0]; ++a)	{						sp2=tree[sp-notu][a];						if (invchmatrix[ch][sp2]!=chmatrix[sp2][ch])	ev=1;						invchmatrix[ch][sp2]=chmatrix[sp2][ch];						}						}	/* end routine for clade */				}			/* Ordered Multistates */			else if (ctype[ch]==0)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])						flip=1;				else									flip=-1;								/* routine for species */				if (sp<notu && (chmatrix[sp][ch]!=UNKNOWN && chmatrix[sp][ch]!=INAP))	{					invchmatrix[ch][sp]=chmatrix[sp][ch]=chmatrix[sp][ch]+flip;					if (chmatrix[sp][ch]>=nstates[ch])		invchmatrix[ch][sp]=chmatrix[sp][ch]=nstates[ch]-2;					else if (chmatrix[sp][ch]<0)			invchmatrix[ch][sp]=chmatrix[sp][ch]=1;					ev=1;					}				/* routine for clade */				else if (sp>=notu)	{					/* make sure that not all descendants have already changed! */					d=0;					for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{						sp2=tree[sp-notu][sc];						if (chmatrix[sp2][ch]==UNKNOWN || chmatrix[sp2][ch]==INAP)	++d;						else	{							for (c=0; c<steps[ch]; ++c)	{								if (taxachange[ch][c]==sp2)	{									++d;									c=steps[ch];									}	/* end test of whether particular change matches species */								}	/* end search through each step */							}	/* end search for unchanged taxa */						}					if (d<tree[sp-notu][0])	{						evolveorderedinclade(tree[sp-notu],chmatrix,ch,flip,INAP,UNKNOWN);						multistatevett(chmatrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					/* now make sure that there was change */					for (c=0; c<notu; ++c)	{						if (invchmatrix[ch][c]!=chmatrix[c][ch])	ev=1;						invchmatrix[ch][c]=chmatrix[c][ch];						}					}	/* end routine for clade */				}	/** END ROUTINE FOR ORDERED MULTISTATES **/			/* Unordered Multistate Characters */			else if (ctype[ch]==1)	{				if (sp<notu && (chmatrix[sp][ch]!=UNKNOWN && chmatrix[sp][ch]!=INAP))	{					invchmatrix[ch][sp]=chmatrix[sp][ch]=mswap(chmatrix[sp][ch],nstates[ch]);					ev=1;					}									else if (sp>notu)	{					evolveunorderedinclade(tree[sp-notu],chmatrix,ch,nstates[ch],INAP,UNKNOWN);					/* make sure that there is change */					for (a=1; a<=tree[sp-notu][0]; ++a)	{						sp2=tree[sp-notu][a];						if (chmatrix[sp2][ch]!=INAP && chmatrix[sp2][ch]!=UNKNOWN)	{							if (invchmatrix[ch][sp2]!=chmatrix[sp2][ch])	{								invchmatrix[ch][sp2]=chmatrix[sp2][ch];								ev=1;								}							}						}					}	/* end unordered change for a clade */					/* if change is made, tally */				}	/* end unordered change */			/* if ev = 1, then there has been a change.  Tally it */			if (ev==1)	{				/* retally simcompat for that character only	*/				makecompatibilitymatrix(simcompat,nstates,notu,chmatrix,ctype,nchars,comptype,0,UNKNOWN,INAP);				for (c=0; c<nchars; ++c)	simcharcomps[c]=simcompat[c][c];				spmcomp=possiblemutualcompatibilities(simcompat, simcharcomps, nchars);//				cmp=nu_comp(nstates, notu, matrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);				if (spmcomp<tpmcomp)	{					++trial;/*					printf("Try %d, trial %d\n",trying,trial);	/* DEBUGGING CODE 2011-02-02	*/					for (sp=0; sp<notu; ++sp)	invchmatrix[ch][sp]=chmatrix[sp][ch]=lch[sp];//					--deltas;					}				/* register change, etc., only if we are keeping it	*/				else	{/*					trial=0;	*/					++deltas;					taxachange[ch][steps[ch]]=sp;					if (ch<0 || ch>=nchars)						printf("out of bounds at %d steps with character %d\n",deltas,ch);					if (steps[ch]<0 || steps[ch]>=mxdel)						printf("out of bounds at %d steps for character %d\n",steps[ch],ch);					++steps[ch];					if (steps[ch]==mxdel)	removefromivector(availablech,ch,&avch);					++mpd[sp];					}				}			/* if we are three steps removed from the the right compatibility, reboot */			if (trial==maxtrial)	{/*				printf("Try %d\n",trying);	/* DEBUGGING CODE 2011-02-07	*/				reboot = 0;				clearivector(mpd,nodes+notu,0);				clearivector(steps,nchars,0);/*				clearivector(der,nchars,0);	*/				}			if (spmcomp==tpmcomp)	reboot=1;			}	/* end additional steps */		}	}	/* end search for chmatrix with compatibility tcmp */free_ivector(mpd);										/* free vector recording branch lengths in changes		*/free_ivector(trpd);										/* free vector recording branch lengths	in ancestors	*/free_ivector(steps);									/* free vector recording steps per character			*/free_ivector(availablech);								/* free vector recording characters that can change		*/free_ivector(availablebr);								/* free vector recording branches that can change		*/free_ivector(branches);									/* free vector recording branches						*/free_ivector(sychos);									/* free vector recording dependent characters			*/if (mxdp>1)	free_imatrix(sychomat,nchars,nchars);	/* START HERE	*/free_imatrix(taxachange,10*nchars, 10*mxdel);			/* free matrix tallying changes */free_lmatrix(invchmatrix,nchars, notu);free_ulvector(simcharcomps);return simcompat;}/* evolveobservedcompatibility - evolves a compatibility matrix until it reaches a particular compatibility.  Gaps and missing are kept in place *//* Requires:   tree - a matrix containing every observed descendant of each node		the first entry is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[nodes]) gives it for species;			the second line (tree[nodes+1]) gives it for internal nodes;	tcomp - total compatibility;	tpmcomp - true possibly mutual compatibility that must be evolved (usually based on observed compatibility);	notu - number of taxa;	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	maxch - the maximum number of changes for each character;	depend - array giving character dependency (if depend[a]=a then it is independent);	comptype - 0 for normal compatibility, 1 for hierarchical compatibility;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;/* Returns:	matrix - a matrix with compatibility = tcomp;*******************************************************************************************************************************************/unsigned long **evolveobservedcompatibility(long **tree, int tcomp, int notu, int nodes, long **chmatrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int *depend, int comptype, int UNKNOWN, int INAP){int		a, b, c, d, br, ch, sc, ev, flip, sp, sp2, scomp;int		avnodes, deltas, mxdel, ttlbr, ttltx=0, mxdp=1, avch, avbr;int		reboot, trial, trying=0, maxtrial=5;int		lch[1000];int		*availablech, *availablebr, *branches, *steps, *trpd, *mpd, *sychos;/*int		*missing;	*/int		**taxachange, **sychomat;/*, *der, **descnodes, *aptaxa;	/* for debugging */long	**invchmatrix;unsigned long *simcharcomps;unsigned long **simcompat;/* find the number of nodes and their diversities *//*nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}	nodes=cladecountbytaxa(tree,notu);*/mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character */trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */mpd=ivector(nodes+notu);					/* morphologic changes along each branch 						*/steps=ivector(nchars);						/* number of times each character changes 						*//*der=ivector(nchars);						/* number of taxa with derived condition for each character 	*/sychos=ivector(nchars);						/* number of dependendent characters attached to a character 	*//*missing=ivector(nchars);					/* 2011-03-31: # missing or inapplicable taxa for a character	*//* 2011-03-31: tally whether there are missing data for this character	for (ch=0; ch<nchars; ++ch)	{	missing[ch]=0;	for (sp=0; sp<notu && missing[ch]==0; ++sp)	if (chmatrix[sp][ch]==UNKNOWN || chmatrix[sp][ch]==INAP)	missing[ch]=1;	}	*/ for (ch=0; ch<nchars; ++ch)	++sychos[depend[ch]];	/* sychos[x] gives the number of characters dependent on x; if 0 then character is dependent */mxdp=maxiarray(sychos,nchars);						/* b will be the maximum number of dependent characters for any character */if (mxdp>1)	{	sychomat=imatrix(nchars,mxdp);	clearivector(sychos,nchars,0);	for (ch=0; ch<nchars; ++ch)	{		sychomat[depend[ch]][sychos[depend[ch]]]=ch;		++sychos[depend[ch]];		}	}/*descnodes=descendantnodes(tree,notu);	*//*nodestates=lmatrix(nodes,nchars);	*/trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[nodes][sp];		/* array tree[nodes] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	if (trpd[sp]>0)	++ttltx;	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[nodes+1][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	if (trpd[sp+notu]>0)	++ttltx;	}	ttlbr=sumivector(trpd,notu+nodes);	if (ttlbr<mxdel)	mxdel=ttlbr;if (ttltx<mxdel)	mxdel=ttltx;	/* 2014-03-21: we allow only as many changes as there are taxa that have changes	*//* allocate memory for arrays containing branches needing changes */availablech=ivector(nchars);				/* lists each character available to a branch									*/availablebr=ivector(ttlbr);					/* lists each otu & htu once for every branch length; ancestors therefore lost	*/branches=ivector(ttlbr);					/* lists each htu & non-ancestral otu that is scored for a character			*/taxachange=imatrix(10*nchars, 10*mxdel);	/* gives taxa that change for character */invchmatrix=lmatrix(nchars, notu);simcompat=ulmatrix(nchars,nchars);simcharcomps=ulvector(nchars);/*aptaxa=applicabletaxa(chmatrix, nchars, notu, INAP);	*//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********//******* MORE REWRITING 3/31/11: Man, I'm on a road to nowhere!!!		*********/	reboot=0;while (reboot==0)	{	/* determine appropriate branches for changes - all nodes & species without sampled descendants */	/* we'll ignore the basal node, assuming that it is all 0's */	avnodes=b=0;	++trying;							/* 2011-02-07 DEBUGGING	*/	for (a=1; a<nodes; ++a)	{		avnodes=avnodes+trpd[a+notu];		for (c=0; c<trpd[a+notu]; ++c)	{			availablebr[b]=a+notu;			++b;			}		}	for (a=0; a<notu; ++a)	{		for (c=0; c<trpd[a]; ++c)	{			availablebr[b]=a;			++b;			}		}	/* clear chmatrix */	for (ch=0; ch<nchars; ++ch)	{		for (a=0; a<notu; ++a)	{			if (chmatrix[a][ch]!=INAP && chmatrix[a][ch]!=UNKNOWN)	{				chmatrix[a][ch]=0;				}			invchmatrix[ch][a]=chmatrix[a][ch];	/* for debugging */			}		}	clearivector(steps,nchars,0);	clearivector(mpd,notu+nodes,0);		/* 2014-03-19: mpd gives branch length in changes: this must be zero at the outset	*/	clearimatrix(taxachange,nchars,mxdel,0);	deltas=0;	/* Step #2: make sure that each apomorphic species has a derivation */	ensure_apomorphies(chmatrix, invchmatrix, taxachange, nstates, ctype, maxch, steps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);	deltas=sumivector(steps,nchars);		/* Step 1: Make sure each state is derived for each character */	ensure_charstates(chmatrix, invchmatrix, taxachange, nstates, ctype, maxch, steps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);	deltas=sumivector(steps,nchars);	/* Step #3: DO ADDITIONAL STEPS NOW */	trial=0;	makecompatibilitymatrix(simcompat,nstates,notu,chmatrix,ctype,nchars,comptype,0,UNKNOWN,INAP);	for (ch=0; ch<nchars; ++ch)	simcharcomps[ch]=simcompat[ch][ch];	scomp=sumulvector(simcharcomps, nchars)/2;//	scomp=nu_comp(nstates, notu, chmatrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);//	spmcomp=possiblemutualcompatibilities(simcompat, simcharcomps, nchars);	//	if (spmcomp>tpmcomp)	{	if (scomp>tcomp)	{		avch=0;		/* all characters that still can change go into availablech	*/		for (ch=0; ch<nchars; ++ch)	{			if ((ctype[ch]==1 && steps[ch]<maxch[ch]) || (ctype==0 && steps[ch]>(notu/2)))	{				availablech[avch]=ch;				++avch;				}			}		/* 2011-02-07: was trial < 3	*/		for (deltas=deltas; trial < maxtrial && scomp!=tcomp; deltas=deltas)	{			/* first choose a character */			c=(int)((double)rand() / ((double)RAND_MAX + 1) * avch);			ch=availablech[c];			while (steps[ch]>=ttltx)	{				c=(int)((double)rand() / ((double)RAND_MAX + 1) * avch);				ch=availablech[c];				}						for (sp=0; sp<notu; ++sp)	lch[sp]=chmatrix[sp][ch];		/* record chmatrix as it was	*/			/**************************************************************************/			for (br=0; br<ttlbr; ++br) branches[br]=availablebr[br];			avbr=ttlbr;						/* remove branches where there already has been change	*/			for (a=0; a<steps[ch]; ++a)	{				sp=taxachange[ch][a];				removefromivector(branches,sp,&avbr);				}						br=(int)((double)rand() / ((double)RAND_MAX +1) * avbr);			sp=branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=avbr)	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * avbr);				sp = branches[br];				}			ev=0;			if (nstates[ch]==2)	{				/* routine for binary characters */				if (sp<notu && (chmatrix[sp][ch]!=UNKNOWN && chmatrix[sp][ch]!=INAP))	{					invchmatrix[ch][sp]=chmatrix[sp][ch]=swap(chmatrix[sp][ch]);					ev=1;					}				/* routine for clade */				else if (sp>=notu)	{					evolvebinaryinclade(tree[sp-notu],chmatrix,ch);					for (a=1; a<=tree[sp-notu][0]; ++a)	{						sp2=tree[sp-notu][a];						if (invchmatrix[ch][sp2]!=chmatrix[sp2][ch])	ev=1;						invchmatrix[ch][sp2]=chmatrix[sp2][ch];						}						}	/* end routine for clade */				}			/* Ordered Multistates */			else if (ctype[ch]==0)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])						flip=1;				else									flip=-1;								/* routine for species */				if (sp<notu && (chmatrix[sp][ch]!=UNKNOWN && chmatrix[sp][ch]!=INAP))	{					invchmatrix[ch][sp]=chmatrix[sp][ch]=chmatrix[sp][ch]+flip;					if (chmatrix[sp][ch]>=nstates[ch])		invchmatrix[ch][sp]=chmatrix[sp][ch]=nstates[ch]-2;					else if (chmatrix[sp][ch]<0)			invchmatrix[ch][sp]=chmatrix[sp][ch]=1;					ev=1;					}				/* routine for clade */				else if (sp>=notu)	{					/* make sure that not all descendants have already changed! */					d=0;					for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{						sp2=tree[sp-notu][sc];						if (chmatrix[sp2][ch]==UNKNOWN || chmatrix[sp2][ch]==INAP)	++d;						else	{							for (c=0; c<steps[ch]; ++c)	{								if (taxachange[ch][c]==sp2)	{									++d;									c=steps[ch];									}	/* end test of whether particular change matches species */								}	/* end search through each step */							}	/* end search for unchanged taxa */						}					if (d<tree[sp-notu][0])	{						evolveorderedinclade(tree[sp-notu],chmatrix,ch,flip,INAP,UNKNOWN);						multistatevett(chmatrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					/* now make sure that there was change */					for (c=0; c<notu; ++c)	{						if (invchmatrix[ch][c]!=chmatrix[c][ch])	ev=1;						invchmatrix[ch][c]=chmatrix[c][ch];						}					}	/* end routine for clade */				}	/** END ROUTINE FOR ORDERED MULTISTATES **/			/* Unordered Multistate Characters */			else if (ctype[ch]==1)	{				if (sp<notu && (chmatrix[sp][ch]!=UNKNOWN && chmatrix[sp][ch]!=INAP))	{					invchmatrix[ch][sp]=chmatrix[sp][ch]=mswap(chmatrix[sp][ch],nstates[ch]);					ev=1;					}									else if (sp>notu)	{					evolveunorderedinclade(tree[sp-notu],chmatrix,ch,nstates[ch],INAP,UNKNOWN);					/* make sure that there is change */					for (a=1; a<=tree[sp-notu][0]; ++a)	{						sp2=tree[sp-notu][a];						if (chmatrix[sp2][ch]!=INAP && chmatrix[sp2][ch]!=UNKNOWN)	{							if (invchmatrix[ch][sp2]!=chmatrix[sp2][ch])	{								invchmatrix[ch][sp2]=chmatrix[sp2][ch];								ev=1;								}							}						}					}	/* end unordered change for a clade */					/* if change is made, tally */				}	/* end unordered change */			/* if ev = 1, then there has been a change.  Tally it */			if (ev==1)	{				/* retally simcompat for that character only	*/				makecompatibilitymatrix(simcompat,nstates,notu,chmatrix,ctype,nchars,comptype,0,UNKNOWN,INAP);				for (c=0; c<nchars; ++c)	simcharcomps[c]=simcompat[c][c];				scomp=sumulvector(simcharcomps,nchars);				scomp/=2;//				spmcomp=possiblemutualcompatibilities(simcompat, simcharcomps, nchars);//				scomp=nu_comp(nstates, notu, chmatrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);//				scomp=countcomp(simcompat, nchars);				if (scomp<tcomp)	{					++trial;/*					printf("Try %d, trial %d\n",trying,trial);	/* DEBUGGING CODE 2011-02-02	*/					for (sp=0; sp<notu; ++sp)	invchmatrix[ch][sp]=chmatrix[sp][ch]=lch[sp];//					--deltas;					}				/* register change, etc., only if we are keeping it	*/				else	{/*					trial=0;	*/					++deltas;					taxachange[ch][steps[ch]]=sp;					if (ch<0 || ch>=nchars)						printf("out of bounds at %d steps with character %d\n",deltas,ch);					if (steps[ch]<0 || steps[ch]>=mxdel)						printf("out of bounds at %d steps for character %d\n",steps[ch],ch);					++steps[ch];					if (steps[ch]==mxdel)	removefromivector(availablech,ch,&avch);					++mpd[sp];					}				}			/* if we are three steps removed from the the right compatibility, reboot */			if (trial==maxtrial)	{/*				printf("Try %d\n",trying);	/* DEBUGGING CODE 2011-02-07	*/				reboot = 0;				clearivector(mpd,nodes+notu,0);				clearivector(steps,nchars,0);/*				clearivector(der,nchars,0);	*/				}			if (scomp==tcomp)	reboot=1;			}	/* end additional steps */		}	}	/* end search for chmatrix with compatibility tcmp */free_ivector(mpd);										/* free vector recording branch lengths in changes		*/free_ivector(trpd);										/* free vector recording branch lengths	in ancestors	*/free_ivector(steps);									/* free vector recording steps per character			*/free_ivector(availablech);								/* free vector recording characters that can change		*/free_ivector(availablebr);								/* free vector recording branches that can change		*/free_ivector(branches);									/* free vector recording branches						*/free_ivector(sychos);									/* free vector recording dependent characters			*/if (mxdp>1)	free_imatrix(sychomat,nchars,nchars);	/* START HERE	*/free_imatrix(taxachange,10*nchars, 10*mxdel);			/* free chmatrix tallying changes */free_lmatrix(invchmatrix,nchars, notu);free_ulvector(simcharcomps);return simcompat;}/* Returns a matrix for OTUs taxa with nchars characters.  Gaps and missing are kept in place *//* Requires:   tree - a VennTree where:   		tree[0][0]…tree[nodes][0] give the CUMULATIVE descendants of each node;   		tree[0][1…tree[0][0]]…tree[nodes][1…tree[nodes][0]] give the OTUS that (immediately or ultimately) evolved within this node	notu - number of taxa;	nodes - number of clades;		ADDED 2011-02-03!!!!!!	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	TTLSTP - the number of changes for the matrix;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/void evolvematrix_rateshift(long **tree, int notu, int nodes, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, long **branchdates, double *shiftinfo, int ttlstp, int UNKNOWN, int INAP){int		a, b, c, d, br, ch, sc, ev, flip, sp, sp2;int		st, u, clse, best;int		avnodes, used, deltas, mxdel, ttlbr=0;int		cut, early, unit=1;int		*available, *branches, *steps, *trpd, *mpd, *der, *aptaxa, *fa;int		**taxachange;/*, **descnodes;	/* for debugging */long	**invmatrix;/* find the number of nodes and their diversities 	nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}										/* 2011-02-03: somehow, someway, I need a safeguard against fully bifurcating trees.... *//*nodes=cladecountbytaxa(tree,notu);		/* number of clades in tree									*/mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character 				*/mpd=ivector(nodes+notu);					/* morphologic changes along each branch 					*/trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */steps=ivector(nchars);						/* number of times each character changes 					*/der=ivector(nchars);						/* number of taxa with derived condition for each character */fa=ivector(nodes+notu);						/* first appearance times for each branch */cut=shiftinfo[1]*notu;						/* cut to get first part of clade	*//* changed to 10 entries for "unit" branch length, to allow fractional rate differences	*/if (shiftinfo[0]<1)			unit=10;else if (shiftinfo[0]==1)	unit=1;else if (shiftinfo[0]>1)	unit=6;early=((int) (shiftinfo[0]*unit));if (((shiftinfo[0]*unit)-early)>=0.5)	++early;if (early<(shiftinfo[0]*unit))	++early;for (sp=0; sp<notu; ++sp)	{	if (branchdates[sp][0]>=branchdates[cut][0])		trpd[sp]=unit*tree[nodes][sp];	/* should this be nodes or notu?!?!?		*/	else												trpd[sp]=early*tree[nodes][sp];	/* confirmed: nodes; vtree does this change	*/	ttlbr+=trpd[sp];	}for (sp=1; sp<nodes; ++sp)	{	if (branchdates[sp+notu][0]>=branchdates[cut][0])	trpd[sp+notu]=unit*tree[nodes+1][sp];	/* array tree[nodes+1] gives branch lengths of ancestors */	else												trpd[sp+notu]=early*tree[nodes+1][sp];	/* array tree[nodes+1] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	}/* get branch lengths for observed species	for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[nodes][sp];	fa[sp]=-1;	}trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[nodes][sp];		/* array tree[notu-1] gives branch lengths of species 	ttlbr=ttlbr+trpd[sp];	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[nodes+1][sp];	/* array tree[notu] gives branch lengths of ancestors 	ttlbr=ttlbr+trpd[sp+notu];	}	*/	if (ttlbr<mxdel)	mxdel=ttlbr;/*if (ttltx<mxdel)	mxdel=ttltx;	/* 2014-03-21: we allow only as many changes as there are taxa that have changes	*//* allocate memory for arrays containing branches needing changes */available=ivector(ttlbr);branches=ivector(ttlbr);taxachange=imatrix(nchars, mxdel);	/* gives taxa that change for character */invmatrix=lmatrix(nchars, notu);aptaxa=applicabletaxa(matrix, nchars, notu, INAP);/* BEGIN HERE 5/18/01 describe each clade in terms of all species within it *//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********/	/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */avnodes=b=0;for (a=1; a<nodes; ++a)	{	avnodes=avnodes+trpd[a+notu];	for (c=0; c<trpd[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		available[b]=a;		++b;		}	}/* clear matrix */for (ch=0; ch<nchars; ++ch)	{	for (a=0; a<notu; ++a)	{		if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{			matrix[a][ch]=0;			}		invmatrix[ch][a]=matrix[a][ch];	/* for debugging */		}	}deltas=0;/* Step 1: Make sure each state is derived for each character *//*derive_each_char(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, aptaxa, mpd, trpd, notu, nchars, maxstp, mxdel, UNKNOWN, INAP, tree, branches, available, nodes, ttlbr);	*/for (ch=0; (ch<nchars && deltas<ttlstp); ++ch)	{	while (maxch[ch]==0 && ch<nchars)	++ch;	if (ch>=nchars)			break;	steps[ch]=st=0;	clearivector(taxachange[ch],mxdel,-1);	ev=0;			/* make sure that inapplicable characters have at least one taxon that can be changed */	if (aptaxa[ch]<notu)	{		/* count unknowns - these will be put back in later */		u=0;		for (a=0; a<notu; ++a)	if (matrix[a][ch]==UNKNOWN)	++u;		/* now find a node that has similar diversity */		clse=RAND_MAX;				/* start from the bottom if most taxa are scored */		if (aptaxa[ch]>(notu/2))	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==(notu-aptaxa[ch]))	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs((notu-aptaxa[ch])-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}		/* start from the top otherwise */		else	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==aptaxa[ch])	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs(aptaxa[ch]-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}				for (sp=0; sp<notu; ++sp)	{			if (aptaxa[ch]>(notu/2))	matrix[sp][ch]=0;			else						matrix[sp][ch]=INAP;			}		for (a=1; a<tree[best][0]; ++a)	{			sp=tree[best][a];			matrix[sp][a]=0;			}		}	/* end initial creation of inapplicable character */		/* make autapomorphic characters change on one species only */	/* invariants do not change at all */	for (ch=ch; maxch[ch]<=1; ++ch)	{		/* skip invariants and make autapomorphies autapomorphic */		if	(maxch[ch]==1)	{			c=0;			/* we will sample only from otus here - so do not include clades in branches array! */			/* this part rewritten with Cubs winning 7-0 against the Marlins in Game 4 */			for (sp=0; sp<notu; ++sp)				if ((matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP) && trpd[sp]>0)	++c;			if (c>0)	{				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || (trpd[sp]==0 || sp>=notu))					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=1;				taxachange[ch][0]=sp;				}			/* if only cells belong to species with 0 length branches */			if (c==0)	{				/* flip-flop an unknown apomorphic species with a known plesiomorphic one - give plesiomorphic species a ? and the other a 1 */				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || sp2>=notu)					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);								sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while (trpd[sp2]==0 || sp2>=notu)					sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp2][ch];				invmatrix[ch][sp2]=matrix[sp2][ch]=1;				taxachange[ch][0]=sp2;				}	/* end routine if all scored species were unknown */			ev=1;			++deltas;			++steps[ch];			++mpd[ch];			}		}	/* this should leave us with a character that needs to be changed OR out of characters */	if (ch>=nchars)	break;			used=0;	/* this tells how many branches are discarded; used > steps IF there are absents */	/* branch length is taken into account by trpd */	equalivector(branches,available,ttlbr);	/* Binary && unordered multistate is Easy */	/* for normal character, have it change until all X states are realized */	if (nstates[ch]==2 || ctype[ch]==1)	{		/* changed 10/14/2003 so that non-apomorphic characters	diagnose 2+ species 		*/		/* altered 03/18/2014 so that you stop this if used branches matches total branches	*//*		for (st=0; (st<nstates[ch]-1 || der[ch]<=1); st=st)	{	*/		for (st=0; ((st<nstates[ch]-1 && used<ttlbr) || der[ch]<=1); st=st)	{			/* There are ttlbr-used branches that could change */			ev=0;				/* fixed 2014-02-26	*/			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			/* have binary characters change on branches - if they are not autapomorphic, then they need to diagnose multiple species THIS WAS REMOVED 10/14/2003			else				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (avnodes-used));*/			sp = branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				ev=1;				if (nstates[ch]==2)	invmatrix[ch][sp]=matrix[sp][ch]=1;				else					invmatrix[ch][sp]=matrix[sp][ch]=st+1;				++der[ch];				/* add one to the number of species showing derived condition(s) */				}			else if (sp>notu)	{				/* use st+1 instead of nstates[ch] here - we want only 0…st+1 not 0…nstates    */				/*		(remember, st has not yet been incremented, so we need st+1) 		   */				/* This section modified 10/14/2003 to make sure characters are not apomorphic */				/* if multistate, then we need at least two iterations */				if (nstates[ch]>2)	{					/* if we have not yet derived all of the states, do it this way 			*/					/* if deriving first state (i.e., st=0), then it is the same as binary		*/					if (st<nstates[ch] && st==0)						evolvebinaryinclade(tree[sp-notu],matrix,ch);					/* if deriving subsequent states, then used change unmodified species to st+1 		*/					else if (st<(nstates[ch]-1) && st>=1)	{						for (c=1; c<=tree[sp-notu][0]; ++c)	{							sp2=tree[sp-notu][c];							if (matrix[sp2][ch]==0)	matrix[sp2][ch]=st+1;							}						}/*						evolveunorderedinclade(tree[sp-notu],matrix,ch,st+2,UNKNOWN,INAP);	*/					/* if we have an essentially apomorphic states, then just do it like any other time */					else						evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],UNKNOWN,INAP);					}				else		evolvebinaryinclade(tree[sp-notu],matrix,ch);				for (c=1; c<=tree[sp-notu][0]; ++c)	{					sp2=tree[sp-notu][c];					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					if (invmatrix[ch][sp2]!=0 && (invmatrix[ch][sp2]!=UNKNOWN && invmatrix[ch][sp2]!=INAP))						++der[ch];					else if (invmatrix[ch][sp2]==0)						--der[ch];					/* this will happen only if there are reversals */					}				/* if there was a change, then tally it */				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1) || der[ch]<=1)				removefromivector(branches,sp,&a);							if (used<steps[ch])	{				printf("ERROR LINE 10292 - there are more changes than deleted branches for Ch%d…\n",ch+1);				}			/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				++st;	/* we increment this only if we have made a change */				}			}	/*end derivation of state */		}	/* end loop for binary / unordered characters */		/* Ordered Multistates are tougher */	else if (nstates[ch]>2 && ctype[ch]==0)	{		used=0;		for (st=0; (st<nstates[ch]-1 && (steps[ch]<mxdel && steps[ch]<maxch[ch])); st=st)	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			sp=branches[br];			/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				/* in this case all taxa must be examined just in case the matrix has been recentered due to a negative number */				for (sp2=0; sp2<notu; ++sp2)	{					if (ev==0 && invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					}				ev=1;				}							else if (sp>notu)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])	flip=1;				else				flip=-1;				evolveorderedinclade(tree[sp-notu],matrix,ch,flip, INAP, UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				/* in this case all taxa must be modified just in case the matrix has been recentered due to a negative number */				for (sp2=0; sp2<notu; ++sp2)	{					if (ev==0 && invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					}				}							/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				/* note - do not increment st here - that is done only if a new state is derived */				}			/* check if all states have been derived */			/* note: this is needed only for ordered multistates */			if (steps[ch]>=nstates[ch]-1)	{				for(a=0; a<notu; ++a)	{					if (matrix[a][ch]>st && (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN))						st=matrix[a][ch];					}				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1))				removefromivector(branches,sp,&a);			if (used<steps[ch])				printf("ERROR LINE 10369 - there are more changes than deleted branches for Ch%d…\n",ch+1);						/* emergency reboot procedure! - clear everything and start over again */			if (used==ttlbr)	{				for (a=0; a<steps[ch]; ++a)	{					sp=taxachange[ch][a];					--mpd[sp];					taxachange[ch][a]=0;					}				deltas=deltas-steps[ch];				st=steps[ch]=used=0;				for (sp=0; sp<notu; ++sp)					if (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN)						invmatrix[ch][sp]=matrix[sp][ch]=0;				for (sp=0; sp<ttlbr; ++sp)	branches[sp]=available[sp];				}			}		/* if there are many states and few taxa, then you do not want to mess with this anymore.  Any changes will either eliminate extreme states,		or simply shift the state up or down one (resulting in no observable change once standardized.  So, if steps >= half the taxa, then shut it down */				}	/* end loop for ordered multistates */	}	/* end derivation of all character states *//* Step #2: make sure that each apomorphic species has a derivation */for (sp=0; (sp<notu+nodes && deltas<ttlstp); ++sp)	{	if (mpd[sp]==0 && trpd[sp]>0)	{		while (mpd[sp]==0)	{			ev=0;			ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));			while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))				ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));						if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				if (nstates[ch]==2)						invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);				else if (ctype[ch]==1)					invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);				else if (ctype[ch]==0)	{					invmatrix[ch][sp]=matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);					/* make sure no negative numbers are kept! */					multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);					}				ev=1;	/* this means that there was a change */				}						else if (sp>notu)	{				d=0;				/* make sure that there are taxa with scorable conditions for this character 		*/				/* and also that not all the descendants have changed already for this character 	*/				/* (the latter can be omitted as evolution cannot know this - but it makes the 		*/				/* output easier to compare to empirical studies.)									*/						for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;					else	{						for (c=0; c<steps[ch]; ++c)	{							if (taxachange[ch][c]==sp2)	{								++d;								c=steps[ch];								}							}						}		/* if any taxa have not yet changed, then d < clade diversity */					}	/* end search for scored taxa */					/* if d is less than clade diversity, then proceed with change */				if (d<tree[sp-notu][0])	{					/* if character is an unordered multistate, then we need an array	*/					/* that tells how each state changed withing the clade				*/					if (ctype[ch]==1)	{						/* routine for unordered multistates */						if (nstates[ch]>2)	{							evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);							}						/* routine for binaries */						else	{							evolvebinaryinclade(tree[sp-notu],matrix,ch);							}						}	/* end routine for unordered / binary characters */					/* routine for ordered multistate */					else {						/* flip is used only for multistates */						flip = ((int) (100 * rand() / RAND_MAX));						if (flip<bias[ch])	flip=1;						else				flip=-1;						evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					/* now make sure that there was change */					for (c=0; c<notu; ++c)	{						if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;						invmatrix[ch][c]=matrix[c][ch];						}					}	/* end conditional loop */				}	/* end routine for clade */			/* if there was a change, then ev = 1.  Now tally the information */			if (ev==1)	{				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++mpd[sp];				++deltas;				}	/* add changes if there actually was a change */			}	/* routine is repeated until an apomorphy is acquired */					}	/* end derivation of apomorphy for this branch */	}	/* end derivation for each apomorphic branch *//* Step #3: DO ADDITIONAL STEPS NOW *//* this is when we use the rate shift	*/	for (deltas=deltas; deltas < ttlstp; deltas=deltas)	{	/* first choose a character */	ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))		ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	/**************************************************************************/	/* do not change the character on a branch where it already has changed */	for (br=0; br<ttlbr; ++br)	branches[br]=available[br];		used=0;	/* used will tally the number of deleted branches */	for (d=0; d<steps[ch]; ++d)	{		for (c=0; c<(ttlbr-used); ++c)	{			/* if branch with change is found, delete it from possible changes */			if (branches[c]==taxachange[ch][d])	{				for (a=c; a<ttlbr-1; ++a)	branches[a]=branches[a+1];				/* some taxa will be in 2+ times - step back to delete them all */				--c;				branches[ttlbr-(used+1)]=-1;				++used;				}			}		}	/* choose a branch from one available */	/* used will be equal to or greater than steps[ch] (due to long branches) */	br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));	sp = branches[br];	/* this shouldn't be necessary, but occassionaly the random number generator */	/* produces a number outside of the proscribed limits */	while (trpd[sp]==0 || br>=(ttlbr-used))	{		br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));		sp = branches[br];		}	ev=0;	if (nstates[ch]==2)	{		/* routine for binary characters */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);			ev=1;			}		/* routine for clade */		else if (sp>=notu)	{			evolvebinaryinclade(tree[sp-notu],matrix,ch);			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;				invmatrix[ch][sp2]=matrix[sp2][ch];				}				}	/* end routine for clade */		}	/* Ordered Multistates */	else if (ctype[ch]==0)	{		flip = ((int) (100 * rand() / RAND_MAX));		if (flip<bias[ch])						flip=1;		else									flip=-1;				/* routine for species */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;			if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;			else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;			ev=1;			}		/* routine for clade */		else if (sp>=notu)	{			/* make sure that not all descendants have already changed! */			d=0;			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;				else	{					for (c=0; c<steps[ch]; ++c)	{						if (taxachange[ch][c]==sp2)	{							++d;							c=steps[ch];							}	/* end test of whether particular change matches species */						}	/* end search through each step */					}	/* end search for unchanged taxa */				}			if (d<tree[sp-notu][0])	{				evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				}			/* now make sure that there was change */			for (c=0; c<notu; ++c)	{				if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;				invmatrix[ch][c]=matrix[c][ch];				}			}	/* end routine for clade */		}	/** END ROUTINE FOR ORDERED MULTISTATES **/	/* Unordered Multistate Characters */	else if (ctype[ch]==1)	{		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);			ev=1;			}					else if (sp>notu)	{			evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);			/* make sure that there is change */			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	{						invmatrix[ch][sp2]=matrix[sp2][ch];						ev=1;						}					}				}			}	/* end unordered change for a clade */			/* if change is made, tally */		}	/* end unordered change */	/* if ev = 1, then there has been a change.  Tally it */	if (ev==1)	{		++deltas;		taxachange[ch][steps[ch]]=sp;		++steps[ch];		++mpd[sp];		}		}	/* end additional steps */free_ivector(der);free_ivector(mpd);free_ivector(trpd);free_ivector(steps);free_ivector(available);free_ivector(branches);free_ivector(aptaxa);free_imatrix(taxachange,nchars,mxdel);free_lmatrix(invmatrix,nchars, notu);//return ();}void evolveXsteps(long **tree, int notu, int nodes, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int *depend, int ttlstps, int UNKNOWN, int INAP){int		a, b, c, d, br, ch, sc, ev, flip, sp, sp2;int		avnodes, deltas, mxdel, ttlbr, ttltx=0, mxdp=1, avch, avbr;int		reboot, trying=0, maxtrial=5;int		lch[1000];int		*availablech, *availablebr, *branches, *steps, *trpd, *mpd, *sychos;/*int		*missing;	*/int		**taxachange, **sychomat;/*, *der, **descnodes, *aptaxa;	/* for debugging */long	**invmatrix;/* find the number of nodes and their diversities *//*nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}	nodes=cladecountbytaxa(tree,notu);*/mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character */trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */mpd=ivector(nodes+notu);					/* morphologic changes along each branch 						*/steps=ivector(nchars);						/* number of times each character changes 						*//*der=ivector(nchars);						/* number of taxa with derived condition for each character 	*/sychos=ivector(nchars);						/* number of dependendent characters attached to a character 	*//*missing=ivector(nchars);					/* 2011-03-31: # missing or inapplicable taxa for a character	*//* 2011-03-31: tally whether there are missing data for this character	for (ch=0; ch<nchars; ++ch)	{	missing[ch]=0;	for (sp=0; sp<notu && missing[ch]==0; ++sp)	if (matrix[sp][ch]==UNKNOWN || matrix[sp][ch]==INAP)	missing[ch]=1;	}	*/ for (ch=0; ch<nchars; ++ch)	++sychos[depend[ch]];	/* sychos[x] gives the number of characters dependent on x; if 0 then character is dependent */mxdp=maxiarray(sychos,nchars);						/* b will be the maximum number of dependent characters for any character */if (mxdp>1)	{	sychomat=imatrix(nchars,mxdp);	clearivector(sychos,nchars,0);	for (ch=0; ch<nchars; ++ch)	{		sychomat[depend[ch]][sychos[depend[ch]]]=ch;		++sychos[depend[ch]];		}	}/*descnodes=descendantnodes(tree,notu);	*//*nodestates=lmatrix(nodes,nchars);	*/trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[nodes][sp];		/* array tree[nodes] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	if (trpd[sp]>0)	++ttltx;	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[nodes+1][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	if (trpd[sp+notu]>0)	++ttltx;	}	ttlbr=sumivector(trpd,notu+nodes);	if (ttlbr<mxdel)	mxdel=ttlbr;if (ttltx<mxdel)	mxdel=ttltx;	/* 2014-03-21: we allow only as many changes as there are taxa that have changes	*//* allocate memory for arrays containing branches needing changes */availablech=ivector(nchars);				/* lists each character available to a branch									*/availablebr=ivector(ttlbr);					/* lists each otu & htu once for every branch length; ancestors therefore lost	*/branches=ivector(ttlbr);					/* lists each htu & non-ancestral otu that is scored for a character			*/taxachange=imatrix(10*nchars, 10*mxdel);	/* gives taxa that change for character */invmatrix=lmatrix(nchars, notu);/*aptaxa=applicabletaxa(matrix, nchars, notu, INAP);	*//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********//******* MORE REWRITING 3/31/11: Man, I'm on a road to nowhere!!!		*********/	reboot=0;/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */avnodes=b=0;++trying;							/* 2011-02-07 DEBUGGING	*/for (a=1; a<nodes; ++a)	{	avnodes=avnodes+trpd[a+notu];	for (c=0; c<trpd[a+notu]; ++c)	{		availablebr[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		availablebr[b]=a;		++b;		}	}/* clear matrix */for (ch=0; ch<nchars; ++ch)	{	for (a=0; a<notu; ++a)	{		if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{			matrix[a][ch]=0;			}		invmatrix[ch][a]=matrix[a][ch];	/* for debugging */		}	}clearivector(steps,nchars,0);clearimatrix(taxachange,nchars,mxdel,0);deltas=0;/* Step #2: make sure that each apomorphic species has a derivation */ensure_apomorphies(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);deltas=sumivector(steps,nchars);/* Step 1: Make sure each state is derived for each character */ensure_charstates(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);deltas=sumivector(steps,nchars);/* Step #3: DO ADDITIONAL STEPS NOW */avch=0;/* all characters that still can change go into availablech	*/for (ch=0; ch<nchars; ++ch)	{	if ((ctype[ch]==1 && steps[ch]<maxch[ch]) || (ctype==0 && steps[ch]>(notu/2)))	{		availablech[avch]=ch;		++avch;		}	}/* 2011-02-07: was trial < 3	*/while (deltas<ttlstps)	{		/* first choose a character */	c=(int)((double)rand() / ((double)RAND_MAX + 1) * avch);	ch=availablech[c];	while (steps[ch]>=ttltx)	{		c=(int)((double)rand() / ((double)RAND_MAX + 1) * avch);		ch=availablech[c];		}		for (sp=0; sp<notu; ++sp)	lch[sp]=matrix[sp][ch];		/* record matrix as it was	*/	/**************************************************************************/	for (br=0; br<ttlbr; ++br) branches[br]=availablebr[br];	avbr=ttlbr;	/* remove branches where there already has been change	*/	for (a=0; a<steps[ch]; ++a)	{		sp=taxachange[ch][a];		removefromivector(branches,sp,&avbr);		}		br=(int)((double)rand() / ((double)RAND_MAX +1) * avbr);	sp=branches[br];		/* this shouldn't be necessary, but occassionaly the random number generator */	/* produces a number outside of the proscribed limits */	while (trpd[sp]==0 || br>=avbr)	{		br=(int)((double)rand() / ((double)RAND_MAX + 1) * avbr);		sp = branches[br];		}	ev=0;	/*shift to 1 if there is a change	*/	if (nstates[ch]==2)	{		/* routine for binary characters */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);			ev=1;			}		/* routine for clade */		else if (sp>=notu)	{			evolvebinaryinclade(tree[sp-notu],matrix,ch);			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;				invmatrix[ch][sp2]=matrix[sp2][ch];				}				}	/* end routine for clade */		}	/* Ordered Multistates */	else if (ctype[ch]==0)	{		flip = ((int) (100 * rand() / RAND_MAX));		if (flip<bias[ch])						flip=1;		else									flip=-1;				/* routine for species */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;			if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;			else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;			ev=1;			}		/* routine for clade */		else if (sp>=notu)	{			/* make sure that not all descendants have already changed! */			d=0;			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;				else	{					for (c=0; c<steps[ch]; ++c)	{						if (taxachange[ch][c]==sp2)	{							++d;							c=steps[ch];							}	/* end test of whether particular change matches species */						}	/* end search through each step */					}	/* end search for unchanged taxa */				}			if (d<tree[sp-notu][0])	{				evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				}			/* now make sure that there was change */			for (c=0; c<notu; ++c)	{				if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;				invmatrix[ch][c]=matrix[c][ch];				}			}	/* end routine for clade */		}	/** END ROUTINE FOR ORDERED MULTISTATES **/	/* Unordered Multistate Characters */	else if (ctype[ch]==1)	{		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);			ev=1;			}					else if (sp>notu)	{			evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);			/* make sure that there is change */			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	{						invmatrix[ch][sp2]=matrix[sp2][ch];						ev=1;						}					}				}			}	/* end unordered change for a clade */			/* if change is made, tally */		}	/* end unordered change */	/* if ev = 1, then there has been a change.  Tally it */	if (ev==1)	{		/* register change, etc., only if we are keeping it	*/		++deltas;		taxachange[ch][steps[ch]]=sp;		if (ch<0 || ch>=nchars)			printf("out of bounds at %d steps with character %d\n",deltas,ch);		if (steps[ch]<0 || steps[ch]>=mxdel)			printf("out of bounds at %d steps for character %d\n",steps[ch],ch);		++steps[ch];		if (steps[ch]==mxdel)	removefromivector(availablech,ch,&avch);		++mpd[sp];		}	}	/* end additional steps *//* 2011-02-10: found an error for Ordovician Echinoids that is revealed here: something gets overwritten!	*///free_ivector(der);//free_ivector(aptaxa);free_ivector(mpd);										/* free vector recording branch lengths in changes		*/free_ivector(trpd);										/* free vector recording branch lengths	in ancestors	*/free_ivector(steps);									/* free vector recording steps per character			*/free_ivector(availablech);								/* free vector recording characters that can change		*/free_ivector(availablebr);								/* free vector recording branches that can change		*/free_ivector(branches);									/* free vector recording branches						*/free_ivector(sychos);									/* free vector recording dependent characters			*//*free_ivector(missing);									/* 2011-03-31: # missing or inapplicable taxa for a character	*/if (mxdp>1)	free_imatrix(sychomat,nchars,nchars);	/* START HERE	*/free_imatrix(taxachange,10*nchars, 10*mxdel);			/* free matrix tallying changes */free_lmatrix(invmatrix,nchars, notu);//return matrix;}long evolvetocompatdeltalite(long **tree, int tcomp, int notu, int nodes, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int comptype, int UNKNOWN, int INAP){int		a, b, c, d, br, ch, sc, ev, flip, sp, sp2, cmp;int		avnodes, deltas=0, mxdel, ttlbr, ttltx=0, mxdp=1, avch, avbr;int		trying=0, lstcmp, bstcmp=-1*RAND_MAX, bstdelt=-1*RAND_MAX;int		reboot, mxttld=0;int		*availablech, *availablebr, *branches, *steps, *trpd, *mpd;/*int		*missing, *sychos;	*/int		**taxachange;/*, **sychomat;, *der, **descnodes, *aptaxa;	/* for debugging */long	**invmatrix;mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character */trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */mpd=ivector(nodes+notu);					/* morphologic changes along each branch 						*/steps=ivector(nchars);						/* number of times each character changes 						*//*der=ivector(nchars);						/* number of taxa with derived condition for each character 	*//*sychos=ivector(nchars);						/* number of dependendent characters attached to a character 	*//*missing=ivector(nchars);					/* 2011-03-31: # missing or inapplicable taxa for a character	*//*for (ch=0; ch<nchars; ++ch)	++sychos[depend[ch]];	/* sychos[x] gives the number of characters dependent on x; if 0 then character is dependent *//*mxdp=maxiarray(sychos,nchars);						/* b will be the maximum number of dependent characters for any character *//*if (mxdp>1)	{	sychomat=imatrix(nchars,mxdp);	clearivector(sychos,nchars,0);	for (ch=0; ch<nchars; ++ch)	{		sychomat[depend[ch]][sychos[depend[ch]]]=ch;		++sychos[depend[ch]];		}	}		*//*descnodes=descendantnodes(tree,notu);	*//*nodestates=lmatrix(nodes,nchars);	*/trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[nodes][sp];		/* array tree[nodes] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	if (trpd[sp]>0)	++ttltx;		/* total taxa for which change can happen	*/	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[nodes+1][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	if (trpd[sp+notu]>0)	++ttltx;	}	ttlbr=sumivector(trpd,notu+nodes);	if (ttlbr<mxdel)	mxdel=ttlbr;if (ttltx<mxdel)	mxdel=ttltx;	/* 2014-03-21: we allow only as many changes as there are taxa that have changes	*//* 2014-03-18: find the maximum total possible changes		*//* we will use this to escape trees with very few branches that don't yield compatibility we need	*/for (c=0; c<nchars; ++c)	{/* changed 2014-03-20: now sets it to total taxa as maximum;	This is relevant if the oldest taxon sampled is ancestral to others.	We now have N-1 possible taxa for changing, not N!					*//*	if (maxch[c]<=ttlbr)	mxttld+=maxch[c];	else					mxttld+=ttlbr;		*/	if (maxch[c]<=ttltx)	mxttld+=maxch[c];	else					mxttld+=ttltx;	}/* allocate memory for arrays containing branches needing changes */availablech=ivector(nchars);				/* lists each character available to a branch									*/availablebr=ivector(ttlbr);					/* lists each otu & htu once for every branch length; ancestors therefore lost	*/branches=ivector(ttlbr);					/* lists each htu & non-ancestral otu that is scored for a character			*/taxachange=imatrix(10*nchars, 10*mxdel);	/* gives taxa that change for character */invmatrix=lmatrix(nchars, notu);/*aptaxa=applicabletaxa(matrix, nchars, notu, INAP);	*//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********//******* MORE REWRITING 3/31/11: Man, I'm on a road to nowhere!!!		*********/	/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */reboot=0;while (reboot==0)	{	avnodes=b=0;	++trying;							/* 2011-02-07 DEBUGGING	*/	for (a=1; a<nodes; ++a)	{		avnodes=avnodes+trpd[a+notu];		for (c=0; c<trpd[a+notu]; ++c)	{			availablebr[b]=a+notu;			++b;			}		}	for (a=0; a<notu; ++a)	{		for (c=0; c<trpd[a]; ++c)	{			availablebr[b]=a;			++b;			}		}	/* clear matrix */	for (ch=0; ch<nchars; ++ch)	{		for (a=0; a<notu; ++a)	{			if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{				matrix[a][ch]=0;				}			invmatrix[ch][a]=matrix[a][ch];	/* for debugging */			}		}	clearivector(steps,nchars,0);	clearivector(mpd,notu+nodes,0);		/* 2014-03-19: mpd gives branch length in changes: this must be zero at the outset	*/										/* note: other routines had done this in a reboot loop	*/		clearimatrix(taxachange,nchars,mxdel,0);	deltas=0;	/* Step #2: make sure that each apomorphic species has a derivation */	ensure_apomorphies(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);	deltas=sumivector(steps,nchars);	/* Step 1: Make sure each state is derived for each character */	ensure_charstates(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, mpd, trpd, notu, nchars, UNKNOWN, INAP, tree, nodes/*, &deltas*/);	deltas=sumivector(steps,nchars);	/* Step #3: DO ADDITIONAL STEPS NOW */	//trial=0;	cmp=nu_comp(nstates, notu, matrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);	if (cmp==tcomp)	reboot=1;	else if (cmp>tcomp)	{		avch=0;		/* all characters that still can change go into availablech	*/		for (ch=0; ch<nchars; ++ch)	{			if ((ctype[ch]==1 && steps[ch]<maxch[ch]) || (ctype==0 && steps[ch]>(notu/2)))	{				availablech[avch]=ch;				++avch;				}			}		/* 2011-02-07: was trial < 3	*/		for (deltas=deltas; cmp>tcomp && deltas<mxttld; ++deltas)	{			/* first choose a character */			c=(int)((double)rand() / ((double)RAND_MAX + 1) * avch);			ch=availablech[c];			while (steps[ch]>=ttltx)	{				c=(int)((double)rand() / ((double)RAND_MAX + 1) * avch);				ch=availablech[c];				}				/*			for (sp=0; sp<notu; ++sp)	lch[sp]=matrix[sp][ch];		/* record matrix as it was	*/			/**************************************************************************/			for (br=0; br<ttlbr; ++br) branches[br]=availablebr[br];			avbr=ttlbr;									/* remove branches where there already has been change	*/			for (a=0; a<steps[ch]; ++a)	{				sp=taxachange[ch][a];				removefromivector(branches,sp,&avbr);				}						br=(int)((double)rand() / ((double)RAND_MAX +1) * avbr);			sp=branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=avbr)	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * avbr);				sp = branches[br];				}			ev=0;			if (nstates[ch]==2)	{				/* routine for binary characters */				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);					ev=1;					}				/* routine for clade */				else if (sp>=notu)	{					evolvebinaryinclade(tree[sp-notu],matrix,ch);					for (a=1; a<=tree[sp-notu][0]; ++a)	{						sp2=tree[sp-notu][a];						if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;						invmatrix[ch][sp2]=matrix[sp2][ch];						}						}	/* end routine for clade */				}			/* Ordered Multistates */			else if (ctype[ch]==0)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])						flip=1;				else									flip=-1;								/* routine for species */				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;					if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;					else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;					ev=1;					}				/* routine for clade */				else if (sp>=notu)	{					/* make sure that not all descendants have already changed! */					d=0;					for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{						sp2=tree[sp-notu][sc];						if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;						else	{							for (c=0; c<steps[ch]; ++c)	{								if (taxachange[ch][c]==sp2)	{									++d;									c=steps[ch];									}	/* end test of whether particular change matches species */								}	/* end search through each step */							}	/* end search for unchanged taxa */						}					if (d<tree[sp-notu][0])	{						evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					/* now make sure that there was change */					for (c=0; c<notu; ++c)	{						if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;						invmatrix[ch][c]=matrix[c][ch];						}					}	/* end routine for clade */				}	/** END ROUTINE FOR ORDERED MULTISTATES **/			/* Unordered Multistate Characters */			else if (ctype[ch]==1)	{				if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{					invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);					ev=1;					}									else if (sp>notu)	{					evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);					/* make sure that there is change */					for (a=1; a<=tree[sp-notu][0]; ++a)	{						sp2=tree[sp-notu][a];						if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{							if (invmatrix[ch][sp2]!=matrix[sp2][ch])	{								invmatrix[ch][sp2]=matrix[sp2][ch];								ev=1;								}							}						}					}	/* end unordered change for a clade */					/* if change is made, tally */				}	/* end unordered change */			/* if ev = 1, then there has been a change.  Tally it */			if (ev==1)	{				cmp=nu_comp(nstates, notu, matrix, ctype, nchars, comptype, 0, UNKNOWN, INAP);				if (cmp<=tcomp)	{					if ((tcomp-cmp)>(lstcmp-tcomp))	--deltas;					reboot=1;		/* this is to escape completely	*/					}				/* register change, etc., only if we are keeping it	*/				else	{	/*					trial=0;	*/					taxachange[ch][steps[ch]]=sp;					if (ch<0 || ch>=nchars)						printf("out of bounds at %d steps with character %d\n",deltas,ch);					if (steps[ch]<0 || steps[ch]>=mxdel)						printf("out of bounds at %d steps for character %d\n",steps[ch],ch);					++steps[ch];					if (steps[ch]==mxdel)	removefromivector(availablech,ch,&avch);					++mpd[sp];					lstcmp=cmp;				/* keep track of last compatiblity	*/					}				if (deltas==mxttld)	{					reboot=0;					}				}			}	/* end additional steps */		}	/* end search for matrix with compatibility tcmp */	/* 2013-03-19: added escape routines	*/	else if (cmp<tcomp && cmp>bstcmp)	{		bstcmp=cmp;		bstdelt=deltas;		}			if (trying>25)	{		deltas=bstdelt;			/* if it takes more than 10 tries, just take the best found	*/		reboot=1;						}	}free_ivector(mpd);										/* free vector recording branch lengths in changes		*/free_ivector(trpd);										/* free vector recording branch lengths	in ancestors	*/free_ivector(steps);									/* free vector recording steps per character			*/free_ivector(availablech);								/* free vector recording characters that can change		*/free_ivector(availablebr);								/* free vector recording branches that can change		*/free_ivector(branches);									/* free vector recording branches						*//*if (mxdp>1)	free_imatrix(sychomat,nchars,nchars);	/* START HERE	*/free_imatrix(taxachange,10*nchars, 10*mxdel);			/* free matrix tallying changes */free_lmatrix(invmatrix,nchars, notu);return deltas;}/**** 2011-03-28: GENERAL ISSUE: MAKE SURE THAT VENN TREES LOOK TO THE CORRECT ROWS FOR BRANCH LENGTHS!!!	****/// /* evolvetree - Evolves a paleontological tree, with notu taxa sampled over time/* Requires:	notu - # of sampled taxa/*				MBL - simulation parameters where	 				MBL[0] (lmbd) - Speciation rate/*					MBL[1] (mu) - Extinction rate/*					MBL[2] (fr) - Preservation rate/*					MBL[3] (vr) - Variance in preservation rate/*					MBL[4] (speciation) - (1) bifurcation (0) budding cladogenesis/*					MBL[5] (model) - (0) exponential (1) logistic (2) hierarchical/*					MBL[6] (for logistic & hierarchical) - value for k				FOSSILS - (1) fossils sampled, (0) no fossils sampled/* Major Rewrite of Sampled Tree Construction 02/2003/* Rewritten to use real numbers from a single array (MBL)/* Returns: tree where				tree[0][0]…tree[clades-1][0] gives number of descendants of a node;				tree[0][1…tree[0][0]]…tree[clades-1][1…tree[clades-1][0]] give desendants where					0…OTUs-1 are taxon numbers;					OTUs…OTUs+clades are HTU numbers (daughter clades);				tree[OTUs-1][0…OTUs-1] give branch lengths of sampled taxa;				tree[OTUS][0…clades-1] give branch lengths of unsampled taxa;				tree[OTUs+1][0…OTUs-1] give first appearances of sampled taxa;				tree[OTUs+2][0…OTUs-1] give last appearances of sampled taxa;******************************************************************************************************/long **evolvetreelogistic(int OTUs, double *MBL, int FOSSILS){long	attempts, base=100000, speciation;int		a, b, c, d, ee, charstandard, ch, latest, mxdv=6, chucks, brats;int		clade, otu, otu2, htu, sampled, initdiv, standingdiv, cumulativediv, stage, newby;int		species, anc, change, testnode, plesion, found0, oldfirst;int		reboot;int		sp, sp2, nodes, found;int		mxtaxa, mxstnd;int		*f1, **forefathers, *ancestor;int		*extants, *observed, *commonanc, *bl;int		*fa, *la, *dbas;int		**pdmat, **camat;//int		*deleteme, cut, *obsbl;long	**tree;double	lmbd, mu, fr, vr, vfr, frp;double	speciate, extinct, find;double	*tor, *tex, *clutch;double	v, x, y, mod, loginc;int	cladmodel, ddk, S10th[10], ons, end;lmbd=MBL[0];mu=MBL[1];fr=MBL[2];vr=MBL[3];if (vr<1)	vr=MBL[3]=1.0f;speciation=MBL[4];cladmodel=MBL[5];		/* cladogenetic model		*/ddk=MBL[6];				/* diversity dependent k	*/v=expectedpropsampled(MBL[1],MBL[2]);v=1/v;mxtaxa=10*v*OTUs;if (mxtaxa>30000)	mxtaxa=30000;/*if (FOSSILS=1)	mxstnd=2*OTUs;	*//*else			mxstnd=3*OTUs;		*/mxstnd=2*ddk;/* arrays for observed taxa - set to OTUs*/observed=ivector(OTUs);		/* observed (sampled) taxa 					*/fa=ivector(OTUs);			/* first appearance of a taxon				*/la=ivector(OTUs);			/* last appearance of a taxon				*//*obsbl=ivector(OTUs);		/* branch lengths of sampled taxa			*/commonanc=ivector(2*OTUs);	/* ancestors of a taxon						*/dbas=ivector(OTUs);			/* patristic distance from base to taxon	*/bl=ivector(2*OTUs);			/* array for all elements of the tree 		*/extants = ivector(mxstnd+2);	/* array for standing taxa - set to mxstnd*/	/* arrays for sampled and unsampled taxa - set to mxtaxa */ancestor=ivector(mxtaxa);	/* ancestor of each taxon 					*/f1=ivector(mxtaxa);			/* number of descendants for each taxon 	*/clutch=dvector(mxtaxa);		/* birth times of descendants in one stage	*/tor=dvector(mxtaxa);		/* true origination - this is a real number */tex=dvector(mxtaxa);		/* true extinction - this is a real number 	*/reboot=0;a=b=c=d=ee=anc=0;charstandard = 1; /*charbase/100;*/sp = ch = change = find = 0;clearivector(observed,OTUs,-1);//clearivector(obsbl,OTUs,-1);clearivector(ancestor,mxtaxa,-1);clearivector(extants,mxstnd+1,-1);latest = -1;attempts = initdiv = standingdiv = cumulativediv = stage = extants[0] = sampled = 0;/* use this to calculate how long the species will live */extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);while (extinct<=0)	extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);tex[0]=(log(1-extinct)/log(1-mu));tor[0]=0.0f;		/*added 2014-01-13	*//* a different approachgenerate random number from 0…1estimate how many descendants that is from PoissonRandOutcomesum durations of existing species	modify this as you go to add in new species	if a lineage is present for half the stage and the sum of durations is 5 stages, then it is 10% of the sum	it will have a 10% chance of being ancestral to the next species*******************************************/while (sampled < OTUs)	{	initdiv = standingdiv+1;	//	if (cladmodel==1)	lmbd=(MBL[0]*initdiv*(1-(((double) initdiv)/((double) ddk))))/((double) initdiv);//	if (lmbd<0)			lmbd=0.0f;	for (sp=0; (sp<=standingdiv && cumulativediv<mxtaxa); ++sp)	{	/********************************************/	/*			Does Lineage Speciate?			*/	/********************************************/		/* put modifier for lmbd in here	*/		for (a=0; a<10; ++a)	S10th[a]=0;		for (sp2=0; sp2<=cumulativediv; ++sp2)	{			if (tex[sp2]>stage)	{				if (tor[sp2]<stage)	ons=0;				else				ons=10*(tor[sp2]-stage);							if (tex[sp2]>(stage+1))	end=9;				else				end=10*(tex[sp2]-stage);							for (a=ons; a<=end; ++a)	++S10th[a];				}	/* end case of extant species	*/			}	/* end reconstruction of richness patterns within stage	*/							/* find dN/dt when species originates: we will use that	*/		if (tor[sp]<=stage)	ons=0;		else				ons=10*(tor[sp]-stage);				loginc=logisticincrease(MBL[0],ddk,S10th[ons]);		//		lmbd=(MBL[0]*S10th[ons]*(1-(((double) S10th[ons])/((double) ddk))))/((double) S10th[ons]);		lmbd=mu+log(loginc+S10th[ons])-log(S10th[ons]);		/* modified from Raup 1985 eq. 1	*/				if (sp<0 || sp>mxstnd)	{			printf("ERROR 11357: %d is the wrong number of species!\n", sp);			exit(0);			}		species = extants[sp];/*		mod=1.0f;	*//*		if (tor[species]>stage)	*//*			mod=(stage+1)-tor[species];	/* mod reflects shortened time for extinction and speciation *//*		/*		v=1-pow((1-mu),mod);	/* this will equal mu if it survives the whole interval *//*		/* if v is still less than extinction rate, then the species dies this interval *//*		if (extinct<v)	{*//*			/* now randomly generate a number to show when it dies *//*			x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);*//*			/* if it existed at the beginning		*//*			if (tor[species]<=stage)	tex[species]+=x;*//*			/* if it originated durign this stage	*/ /*			else						tex[species]+=x*(((double) (stage+1))-tor[species]);*//*			}*//*		/* if it survies, then bump the extinction to the next interval	*//*		else							tex[species]=stage+1;	*/				if (f1[species]<mxdv)	{			speciate = (((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);			if (sp%2==0)			speciate=1-speciate;			/* do this to shake up random number generator */			}		else					speciate = 0.0f;				mod=dmin(tex[species],stage+1)-dmax(tor[species],stage);//		if (tex[species]<(stage+1) || tor[species]>stage)	{//			if (tex[species]<(stage+1) && tor[species]>stage)//											mod=tex[species]-tor[species];//			else if (tor[species]<stage)	mod=tex[species]-stage;//			else if (tex[species]>stage+1)	mod=((double) (stage+1))-tor[species];//			}	/* end case for taxa present during only part of "stage"	*/		brats=PoissonRandOutcome(lmbd,mod,speciate,20);	/* number of offspring given randomly generated p-value	*/				if (brats>0)	{			anc = species;			if (speciation==1)	{				brats=2;				y=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				if (tex[anc]>stage+1 && tor[anc]>stage)					clutch[0]=clutch[1]=tor[anc]+(y*((stage+1)-tor[anc]));				/* if ancestor goes extinct during stage and originated before it	*/				else if (tex[anc]<(stage+1) && tor[anc]<stage)					clutch[0]=clutch[1]=stage+(y*(tex[anc]-stage));				/* if ancestor both originates and goes extinct during stage		*/				else if (tex[anc]<(stage+1) && tor[anc]>stage)					clutch[0]=clutch[1]=tor[anc]+(y*(tex[anc]-tor[anc]));				else					clutch[0]=clutch[1]=y+((double) stage);				}			else	{				/* get origination times for descendants; then sort these so that oldest descendants come first	*/				if ((standingdiv+brats)>mxstnd)	brats=mxstnd-standingdiv;				for (a=0; a<brats; ++a)	{					y=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					if (tex[anc]>stage+1 && tor[anc]>stage)						clutch[a]=tor[anc]+(y*((stage+1)-tor[anc]));					/* if ancestor goes extinct during stage and originated before it	*/					else if (tex[anc]<(stage+1) && tor[anc]<stage)						clutch[a]=stage+(y*(tex[anc]-stage));					/* if ancestor both originates and goes extinct during stage		*/					else if (tex[anc]<(stage+1) && tor[anc]>stage)						clutch[a]=tor[anc]+(y*(tex[anc]-tor[anc]));					else						clutch[a]=y+((double) stage);					}				dshellsort_inc_command(clutch,brats);	/* oldest numbers will appear first	*/				}			/* if budding, then allow for multiple descendants at different times 	*/						/* go through each descendant */			for (a=0; a<brats; ++a)	{				++standingdiv;				++cumulativediv;				extants[standingdiv] = cumulativediv;				tor[cumulativediv]=clutch[a];				if (cumulativediv > mxtaxa)	{					printf("ERROR Evolve 187 - In replication XXX");					printf(", more than %3d species were generated.  \n",mxtaxa);					sampled=OTUs;					exit(0);						}				if (standingdiv<0 || standingdiv>mxstnd)	{					printf("ERROR 193:  Standing diversity too high at %2d\n",standingdiv);					sampled=OTUs;					exit(0);						}							if (cumulativediv<0 || cumulativediv>=mxtaxa || species<0 || species>=mxtaxa)	{					printf("ERROR 199 - ancestor index out of range at %d and %d\n",species,cumulativediv);					sampled=OTUs;					exit(0);						}				ancestor[cumulativediv] = species;				anc = species;				++f1[anc];						/*******************************************************************************/		/* Ancestors become pseudo-extinct at bifurcation if that is what is happening */		/*******************************************************************************/				if (speciation==0 || (speciation==1 && a==0))	{//					y=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					/* if ancestor originated during stage and extends into the next	*///					if (tex[anc]>stage+1 && tor[anc]>stage)//						tor[cumulativediv]=tor[anc]+(y*((stage+1)-tor[anc]));					/* if ancestor goes extinct during stage and originated before it	*///					else if (tex[anc]<(stage+1) && tor[anc]<stage)//						tor[cumulativediv]=stage+(y*(tex[anc]-stage));					/* if ancestor both originates and goes extinct during stage		*///					else if (tex[anc]<(stage+1) && tor[anc]>stage)//						tor[cumulativediv]=tor[anc]+(y*(tex[anc]-tor[anc]));//					else//						tor[cumulativediv]=y+ ((double) stage);										/* if we are dealing with the first species of a bifurcation, give it ancestral extinction time.	*/					/* 		Ancestor disappears when descendants arise													*/ 					if (speciation==1)	{						tex[cumulativediv]=tex[anc];						tex[anc]=tor[cumulativediv];						}					}				/* second species of a bifurcation */				else if (a==1)	tor[cumulativediv]=tex[anc];								/* establish extinction if the species becomes extinct */				if (speciation==0 || (speciation ==1 && a==1))	{					/* if we are dealing with the second species, then give it its own extinction time but the same origination time */					extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);					tex[cumulativediv]=tor[cumulativediv]+(log(1-extinct)/log(1-mu));					}				}			}		if (FOSSILS==0 && standingdiv>=OTUs-1)	sp = initdiv;	/* quit if enough taxa are alive */		}	/****  End Speciation Round ****/ 				if (FOSSILS==1)	{		/********************************************/		/*				 Do Sampling				*/		/*  Separated from Speciation Loop 1/3/97   */		/********************************************/		if (sampled < OTUs)	{			for (sp=0; sp<=standingdiv; ++sp)	{				species = extants[sp];								/* Raw Species Number *//*				find = (((unsigned int) rand())%base)+1;	*//*				if (f1[species]>=3 || cumulativediv>=(3*mxstnd))	find = 0;	*/				find=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				/* do this to shake up the random number generator */				if (sp%2==0)	find=1-find;								/* insert lognormal part here	*/				x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);				y=normsinv(x);				vfr=pow(vr,y);				v=fr*vfr;				frp=log(1-(fr*vfr));				/* 2012-01-10: Poisson expectation so that P[0 | 1 stage, fr] = 1=fr	*/											/* keep this here so that we can handle variable sampling				*/				if (tex[species]<(stage+1) || tor[species]>stage)	{					/* if species originates and disappears in this interval 			*/					if (tex[species]<(stage+1) && tor[species]>stage)														mod=tex[species]-tor[species];					/* if species originated earlier but goes extinct in this interval	*/					else if (tex[species]<(stage+1))	mod=tex[species]-stage;					/* if species goes extinct later but originates in this interval	*/					else if (tex[species]>(stage+1))	mod=((double) (stage+1))-tor[species];					v=1-pow(1-(fr*vfr),mod);	/* this will equal fr*vfr if it survives the whole interval */												/*	(1-[fr*vfr]) = prob. of missing over whole interval													(1-[fr*vfr])^mod = prob. of missing over mod.  	*/					}						if (find <= v)	{					newby = 0;					/** First sampled species goes straight into the array **/					if (sampled==0)	{						observed[sampled]=species;						fa[sampled]=la[sampled]=stage;						++sampled;						}					/** Test whether a sampled species had gone unsampled **/					else	{						for (otu = 0; otu < sampled;  ++otu)	{							if (observed[otu] == species)	{								newby = 1;		/* species is not new */								la[otu]=stage;								otu = sampled;								}							}						if (newby == 0 && sampled < OTUs)	{							/* sort species as you go */							a=sampled-1;							while (observed[a]>species && a>=0)	{								observed[a+1]=observed[a];								fa[a+1]=fa[a];								la[a+1]=la[a];								--a;								}							observed[a+1] = species;							fa[a+1]=la[a+1]=stage;							++sampled;							if (sampled<0 || sampled>OTUs)	{								printf("ERROR 189: You somehow sampled %d\n",sampled);								exit(0);								}							if (sampled==OTUs)		sp = standingdiv;							}						}					latest = observed[sampled-1];					}	/* End Tallying of Sampled Horizon	*/				}	/*  End Sampling for Each Horizon	*/			}	/* only do test while we need to sampled taxa */		}	/* only sample if we are including fossils	*/			else {		sampled = standingdiv;		/* if there are no fossils, "present" is when									   OTUs taxa evolve */		if (sampled==OTUs-1)	for (sp=0; sp<OTUs; ++sp)	observed[sp]=extants[sp];		}	if (sampled>=OTUs)	break;	/* don't bother with the rest if done */			/* cull species that went extinct */	for (a=0; a<=standingdiv; ++a)	{		sp=extants[a];		if (tex[sp]<(stage+1))	{			for (b=a+1; b<=standingdiv; ++b)	extants[b-1]=extants[b];			extants[standingdiv]=-1;			--standingdiv;			--a;			}		}		initdiv=standingdiv;				/****** REBOOT ROUTINE ******/	if (standingdiv < 0 || (cumulativediv>=mxtaxa && sampled < OTUs))	{		latest = -1;		/* clear vectors set to maxtaxa */		for (sp=0; sp<cumulativediv; ++sp)	{			ancestor[sp]=tex[sp]=tor[sp]=-1;			f1[sp]=0;		/* altered 2014-01-13	*/			}		/* clear vectors set to OTUs */		for (sp=0; sp<sampled; ++sp)			fa[sp]=la[sp]=observed[sp]=-1;				standingdiv = initdiv = cumulativediv = extants[0] = sampled = 0;		stage = 0;		++attempts;		/* use this to calculate how long the species will live */		extinct=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);		tex[0]=(log(1-extinct)/log(1-mu));		tor[0]=0.0f;		/*added 2014-01-13	*//*		if ((attempts%5)==0)	printf ("%2d tries and counting.\n",attempts); */		}				/** Reboot simulation **/	else	{		if (sampled < OTUs)	++stage;		/*  All OTUs species found	*/		else if (FOSSILS==0 && cumulativediv==((2*OTUs)-2))	{			for (sp=0; sp<=standingdiv; ++sp)		observed[sp] = extants[sp];			sampled = OTUs;			reboot=1;			}		/* if species index is out of range, then reboot the whole thing */		}	}mxdv=1+maxiarray(f1,cumulativediv);/* redone 2014-01-13	a=observed[OTUs-1];tree=lmatrix(nodes=(1+ancestor[a]),mxdv+1);for (sp=1; sp<observed[OTUs-1]; ++sp)	tree[ancestor[sp]][0]=1;for (sp=1; sp<observed[OTUs-1]; ++sp)	{	++tree[ancestor[sp]][0];	tree[ancestor[sp]][1]=ancestor[sp];	a=tree[ancestor[sp]][0];	tree[ancestor[sp]][a]=sp;	}	deleteme=ivector(cut=(observed[OTUs-1]-OTUs));ee=c=0;for (a=0; a<observed[OTUs-1]; ++a)	{	for (b=ee; b<(OTUs-1); ++b)	{		if (a==observed[b])	b=OTUs;		else if (a>observed[b] && a<observed[b+1])	{			deleteme[c]=a;			++c;			ee=b;			b=OTUs;			}	/* this species was not sampled			}	/* end search of observed taxa to find match		}for (c=0; c<cut; ++c)	{	for (a=0; a<nodes; ++a)	{		for (b=1; b<=tree[a][0]; ++b)	{			if (deleteme[c]==tree[a][b])	{				tree[a][b]=-1;				--tree[a][0];				b=tree[a][0]+1;				a=nodes;				}	/* delete taxon and decrement diversity				}		}	}/* tree matrix - rows 0...(OTUs-1) rows are for possible nodes	*//*		row OTUs-1 is for species branch lengths				*//*		row OTUs   is for nodal branch lengths					*//*		row OTUs+1 is for species FAs							*//*		row OTUs+2 is for species LAs							*//*		the first cell of rows 0…(OTUs-1) give # branches		*//*			(i.e., 2 for bifurcation w. no sampled ancestor)	*/tree=lmatrix(OTUs+3,OTUs);clearlmatrix(tree,OTUs+3,OTUs,-1);for (a=cumulativediv+1; a<mxtaxa; ++a)	f1[a]=ancestor[a]=0;if (observed[0]==-1)	{	printf("Taxa lost by line 377\a\n");	exit(0);	}/*********************************************************************************//*								Store True Phylogeny							 *//*********************************************************************************//**** LIST ANCESTORS OF EACH OBSERVED SPECIES ****/chucks=0;ancestor[0]=-1;/* find the distance from the base for each species */for (otu=0; otu<OTUs; ++otu)	{	sp=observed[otu];	anc=ancestor[sp];	if (anc>=0)		dbas[otu]=1;	for (a=1; anc>=0; ++a)	{		anc=ancestor[anc];		++dbas[otu];		}	}/* count the maximum number of ancestors */chucks=maxiarray(dbas,otu);/* list all of the ancestors for each species */forefathers=imatrix(OTUs,chucks+1);clearimatrix(forefathers,OTUs,chucks+1,-1);ancestor[0]=-1;for (otu=0; otu<OTUs; ++otu)	{	forefathers[otu][0]=sp=observed[otu];	anc=ancestor[sp];	for (a=1; anc>=0; ++a)	{		forefathers[otu][a]=anc;		anc=ancestor[anc];		}	}/* list the unsampled ancestors of each species *//* also, tally species with sampled descendants */free_ivector(f1);f1=ivector(OTUs);	/* 0: no sampled descendants; 1: 1+ sampled descendants *//* written out 2014-01-13	*/for (otu=0; otu<OTUs; ++otu)	{	/* rewrite this to count down until a common forefather		/* also, check to make sure that taxon is not ancestral; if it is, then make obsbl=0	*/	/* have it work down until it finds a number shared with another taxon;			keep the shortest one		*///	obsbl[otu]=1;	found=0;	for (a=1; a<dbas[otu]; ++a)	{		anc=forefathers[otu][a];		for (b=otu-1; b>=0; --b)	{			if (observed[b]==anc)	{				found=1;				f1[b]=1;				/* end loops 	*/				b=0;				a=dbas[otu];				}			}//		if (found==0)	++obsbl[otu];	/* this gives length to observed ancestor or base of tree	*/		}	}	/* create a matrix of branch distances between taxa *//* this gives distance to common ancestor, so the matrix is asymmetrical */pdmat=imatrix(otu,otu);camat=imatrix(otu,otu);for (otu=OTUs-1; otu>0; --otu)	{	for (otu2=otu-1; otu2>=0; --otu2)	{		for (a=0; a<=dbas[otu]; ++a)	{			sp=forefathers[otu][a];			for (b=0; b<=dbas[otu2]; ++b)	{				sp2=forefathers[otu2][b];				if (sp==sp2)	{					pdmat[otu][otu2]=a+1;					pdmat[otu2][otu]=b+1;					camat[otu][otu2]=camat[otu2][otu]=sp;					/* end loop */					b=dbas[otu2];					a=dbas[otu];					}				/* end loop if forefather[otu][a] cannot match forefather[otu2][any] */				else if (sp>sp2)	b=dbas[otu2];				}			}		}	}/* create a tree *//* keep track of common ancestors of each clade */nodes=found0=0;for (otu=OTUs-1; otu>0; --otu)	{	d=chucks;	for (otu2=otu-1; otu2>=0; --otu2)	{		if (pdmat[otu][otu2]<d)	{			d=pdmat[otu][otu2];			}		}	for (otu2=0; otu2<otu; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			anc=camat[otu][otu2];			found=-1;			for (a=0; a<nodes; ++a)	{				/* existing nodes found */				if (commonanc[a]==camat[otu][otu2])	{					found=0;					/* check to see if the species already is in the nodes */					for (b=1; b<=tree[a][0]; ++b)	{						if (otu2==tree[a][b])		found=1;						}					if (found==0)	{						for (b=1; b<=tree[a][0]; ++b)	{							if (otu==tree[a][b])	found=2;							}						}					/* if neither species already found */					if (found==0)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					/* if older species already found */					else if (found==1)	{						for (b=tree[a][0]; otu<tree[a][b]; --b)		tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu;						++tree[a][0];						}					/* if younger species already found */					else if (found==2)	{						for (b=tree[a][0]; otu2<tree[a][b]; --b)	tree[a][b+1]=tree[a][b];						tree[a][b+1]=otu2;						++tree[a][0];						}					a=nodes+1;					otu2=otu;					}				}	/* end search for previously found node */			/* new nodes found */			if (found==-1)	{				commonanc[nodes]=camat[otu][otu2];				tree[nodes][0]=2;				tree[nodes][1]=otu2;				tree[nodes][2]=otu;				++nodes;				if (otu2==0)	found0=1;				otu2=otu;				}	/* new node added */			}		}	}/* make sure that oldest species is included in the tree somewhere **/if (found0==0)	{	otu=0;	d=chucks;	for (otu2=1; otu<OTUs; ++otu2)	if (pdmat[otu][otu2]<d)		d=pdmat[otu][otu2];	for (otu2=1; otu<OTUs; ++otu2)	{		if (pdmat[otu][otu2]==d)	{			tree[nodes][0]=2;			tree[nodes][1]=0;			tree[nodes][2]=otu2;			commonanc[nodes]=camat[0][otu2];			++nodes;			}		}	found0=1;	}	mxdv=2;for (a=0; a<nodes; ++a)	if (tree[a][0]>mxdv)	mxdv=tree[a][0];/*****  Sort Clades by Last Common Ancestor	*****/for (testnode=0; testnode<nodes; ++testnode)	{	d=commonanc[c=testnode];	for (clade=testnode+1; clade<nodes; ++clade)		if (commonanc[clade] <= d) d=commonanc[c=clade];	if (c != testnode)	{		commonanc[c]=commonanc[testnode];		commonanc[testnode]=d;		for (sp=0; sp<=mxdv; ++sp)	{			d=tree[testnode][sp];			tree[testnode][sp]=tree[c][sp];			tree[c][sp]=d;			}		}	}/**** WRITE OUT TREE ****/for (testnode=nodes-1; testnode>0; --testnode)	{	found=0;	sp=tree[testnode][1];	htu=testnode+OTUs;	for (plesion=testnode-1; found==0 && plesion>=0; --plesion)	{		for (a=1; a<=tree[plesion][0]; ++a)	{			sp2=tree[plesion][a];			/* ancestral node found */			if (sp2==sp)	{				if (sp<OTUs)	{					for (b=a+1; tree[plesion][b]<htu && b<=tree[plesion][0]; ++b)						tree[plesion][b-1]=tree[plesion][b];					tree[plesion][b-1]=htu;					}				/* different routine needed if clade */				else	{					oldfirst=tree[plesion][1];					for (b=a; tree[plesion][b-1]>htu; --b)	{						tree[plesion][b]=tree[plesion][b-1];						}					tree[plesion][b]=htu;					/* if first species was a clade but now is another clade */					/*   then the old must be replaced */					if (b==1 && oldfirst==tree[plesion][2])	{						sp=tree[plesion][2];						htu=tree[plesion][1];						}					}				/* if the first species was found, then it will be in lower clades 						*/				/* this means that the tree needs to be re-written or this node will never find a home  */				/*   So, swap the that species with the first species in tree[plesion] 					*/				/*     if a clade replaces a clade, htu remains unchanged */				if (a==1 || b==1)					htu=tree[plesion][1];				else					found=1;				a=tree[plesion][0];	/* end search */				}	/* end replacement of taxon within clade by node or new representative species */			}	/* end search of species within a lower node */		}	/* end search of nodes */	}		/************************  Determine Branch Lengths  ************************/for (sp=0; sp<OTUs; ++sp)	{	for (b=0; b<chucks; ++b)	{		for (c=(nodes-1); c>=0; --c)	{			if (forefathers[sp][b]==commonanc[c])	{				bl[sp]=b;				c=0;				b=chucks;				}			}		}	}//for (a=0; a<OTUs; ++a)					bl[a] = obsbl[a];for (a=OTUs; a<(OTUs+nodes); ++a)		bl[a] = 0;/***    Replace Branch lengths from sampled Ancestors to Nodes    ***/ for (sp=0; sp<OTUs; ++sp)	{	if (f1[sp]>0)	{		for (b=0; b<nodes; ++b)	{			if (commonanc[b]==observed[sp])	{				bl[b+OTUs] = bl[sp];				bl[sp] = 0;				}			}		}	}/* read back troufor (clade=(nodes-1); clade>=0; --clade)	{	a=clade;	d=0;	bl[OTUs+clade]=1;	while (d==0)	{		anc=ancestor[a];		for (c=(clade-1); c>=0; --c)	{			if (commonanc[c]==anc)	{				}			}		}		for (c=(clade-1)	}/***   Nodes Subsume the Apomorphies of their Unsampled Immediate Ancestors   ***/ for (clade=nodes-1; clade>=0; --clade)	{//	while (bl[clade+OTUs]>0 && clade>0)	--clade;//	if (clade<0)	break;	htu=commonanc[clade];			/* fixed 2014-01-14	*/	anc=ancestor[htu];				/* fixed 2014-01-14	*/	if (anc>=0)		found=0;		/* fixed 2014-01-14	*/	while (found==0)	{		++bl[clade+OTUs];			/* fixed 2014-01-14	*/		for (c=(clade-1); c>=0 && found==0; --c)	{			if (anc==commonanc[c])	{				found=1;			/* fixed 2014-01-14	*/				c=0;				/* fixed 2014-01-14	*/				}	/* examine common ancestors for ancestor of node	*/			if (commonanc[c]<anc)	c=0;	/* no more hope!  escape	*/			}		anc=ancestor[anc];			/* fixed 2014-01-14	*/		if (anc<0)	found=-1;		/* fixed 2014-01-14	*/		}	/* search through common ancestors to see if tis ancestor is found	*//*	for (a=0; (found==0 && anc>-1); ++a)	{		++bl[clade+OTUs];		for (b=0; b<OTUs; ++b)	{			/* if ancestor is observed, prepare to stop the loop *//*			if (observed[b]==anc)	{				found=1;				b=OTUs;				}			/* once species are older than ancestor, abandon search to speed loop *//*			else if (observed[b]>anc)	b=OTUs;			}		anc=ancestor[anc];		}	*/	}	/* count down all clades	*//* add branch lengths to tree  */for (a=0; a<OTUs; ++a)	tree[OTUs-1][a]=bl[a];for (b=0; b<nodes; ++b)	{	a=OTUs+b;	tree[OTUs][b]=bl[a];	}/* add first and last appearances to tree  */for (a=0; a<OTUs; ++a)	{	tree[OTUs+1][a]=fa[a];	tree[OTUs+2][a]=la[a];	}free_ivector(observed);free_ivector(commonanc);//free_ivector(obsbl);free_dvector(clutch);free_ivector(fa);free_ivector(la);free_ivector(bl);free_ivector(extants);free_ivector(ancestor);free_imatrix(forefathers,OTUs,chucks+1);free_ivector(f1);free_ivector(dbas);	free_dvector(tor);free_dvector(tex);free_imatrix(pdmat,otu,otu);free_imatrix(camat,otu,otu);return tree;}void evolvematrix_corr_sets(long **tree, int notu, int nodes, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, double *setinfo, int ttlstp, int UNKNOWN, int INAP){int		a, b, c, d, f, br, ch, ch2, sc, ev, flip, sp, sp2;int		st, u, clse, best;int		avnodes, used, deltas, mxdel, ttlbr=0;int		ttlintegr, dch, cset;int		*available, *branches, *steps, *trpd, *mpd, *der, *aptaxa, *set, *indch;int		**taxachange, **integrated;/*, **descnodes;	/* for debugging */long	**invmatrix;double 	x;/* add something for independent change in each character, too	*//* find the number of nodes and their diversities 	nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}										/* 2011-02-03: somehow, someway, I need a safeguard against fully bifurcating trees.... *//*nodes=cladecountbytaxa(tree,notu);		/* number of clades in tree									*/integrated=imatrix(a=setinfo[0],b=setinfo[1]);set=ivector(b);ttlintegr=0;for (a=0; a<setinfo[0]; ++a)	{	for (b=0; b<setinfo[1]; ++b)	{		integrated[a][b]=ttlintegr;		++ttlintegr;		}	}indch=ivector(nchars);mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character 				*/mpd=ivector(nodes+notu);					/* morphologic changes along each branch 					*/trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */steps=ivector(nchars);						/* number of times each character changes 					*/der=ivector(nchars);						/* number of taxa with derived condition for each character *//*fa=ivector(nodes+notu);						/* first appearance times for each branch */trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[nodes][sp];		/* array tree[notu-1] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[nodes+1][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	}	/**/	if (ttlbr<mxdel)	mxdel=ttlbr;/*if (ttltx<mxdel)	mxdel=ttltx;	/* 2014-03-21: we allow only as many changes as there are taxa that have changes	*//* allocate memory for arrays containing branches needing changes */available=ivector(ttlbr);branches=ivector(ttlbr);taxachange=imatrix(nchars, mxdel);	/* gives taxa that change for character */invmatrix=lmatrix(nchars, notu);aptaxa=applicabletaxa(matrix, nchars, notu, INAP);/* BEGIN HERE 5/18/01 describe each clade in terms of all species within it *//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********/	/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */avnodes=b=0;for (a=1; a<nodes; ++a)	{	avnodes=avnodes+trpd[a+notu];	for (c=0; c<trpd[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		available[b]=a;		++b;		}	}/* clear matrix */for (ch=0; ch<nchars; ++ch)	{	for (a=0; a<notu; ++a)	{		if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{			matrix[a][ch]=0;			}		invmatrix[ch][a]=matrix[a][ch];	/* for debugging */		}	}deltas=0;/* Step 1: Make sure each state is derived for each character *//*derive_each_char(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, aptaxa, mpd, trpd, notu, nchars, maxstp, mxdel, UNKNOWN, INAP, tree, branches, available, nodes, ttlbr);	*/for (ch=0; (ch<nchars && deltas<ttlstp); ++ch)	{	while ((maxch[ch]==0 && steps[ch]>0) && ch<nchars)	++ch;	/* skip integrated characters that already have changed	*/	if (ch>=nchars)			break;	steps[ch]=st=0;	clearivector(taxachange[ch],mxdel,-1);	ev=0;		if (ch<ttlintegr && (ch%(b=setinfo[1]))==0)	{		cset=ch/(b=setinfo[1]);		/* 0…4 go to cset = 0 if there are 5 per set	*/		for (b=0; b<(dch=setinfo[1]); ++b)	set[b]=integrated[cset][b];		}//	dch=1;//	if (ch<ttlintegr)	{//		x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);	/* see if whole set or just character changes	*///		}//	if (x>=setinfo[2])	{//		cset=ch/(b=setinfo[1]);		/* 0…4 go to cset = 0 if there are 5 per set	*///		for (b=0; b<(dch=setinfo[1]); ++b)	set[b]=integrated[cset][b];//		}	/* coordinated shift in characters	*/	else	{		set[0]=ch;		dch=1;		}	/* make sure that inapplicable characters have at least one taxon that can be changed */	if (aptaxa[ch]<notu)	{		/* count unknowns - these will be put back in later */		u=0;		for (a=0; a<notu; ++a)	if (matrix[a][ch]==UNKNOWN)	++u;		/* now find a node that has similar diversity */		clse=RAND_MAX;				/* start from the bottom if most taxa are scored */		if (aptaxa[ch]>(notu/2))	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==(notu-aptaxa[ch]))	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs((notu-aptaxa[ch])-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}		/* start from the top otherwise */		else	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==aptaxa[ch])	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs(aptaxa[ch]-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}				for (sp=0; sp<notu; ++sp)	{			if (aptaxa[ch]>(notu/2))	matrix[sp][ch]=0;			else						matrix[sp][ch]=INAP;			}		for (a=1; a<tree[best][0]; ++a)	{			sp=tree[best][a];			matrix[sp][a]=0;			}		}	/* end initial creation of inapplicable character */		/* make autapomorphic characters change on one species only */	/* invariants do not change at all */	for (ch=ch; maxch[ch]<=1; ++ch)	{		/* skip invariants and make autapomorphies autapomorphic */		if	(maxch[ch]==1)	{			c=0;			/* we will sample only from otus here - so do not include clades in branches array! */			/* this part rewritten with Cubs winning 7-0 against the Marlins in Game 4 */			for (sp=0; sp<notu; ++sp)				if ((matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP) && trpd[sp]>0)	++c;			if (c>0)	{				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || (trpd[sp]==0 || sp>=notu))					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=1;				taxachange[ch][0]=sp;				}			/* if only cells belong to species with 0 length branches */			if (c==0)	{				/* flip-flop an unknown apomorphic species with a known plesiomorphic one - give plesiomorphic species a ? and the other a 1 */				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || sp2>=notu)					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);								sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while (trpd[sp2]==0 || sp2>=notu)					sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp2][ch];				invmatrix[ch][sp2]=matrix[sp2][ch]=1;				taxachange[ch][0]=sp2;				}	/* end routine if all scored species were unknown */			ev=1;			++deltas;			++steps[ch];			++mpd[ch];			}		}	/* this should leave us with a character that needs to be changed OR out of characters */	if (ch>=nchars)	break;			used=0;	/* this tells how many branches are discarded; used > steps IF there are absents */	/* branch length is taken into account by trpd */	equalivector(branches,available,ttlbr);		/* moved 2014-04-07 to allow for correlated change more easily	*/	ev=0;				/* fixed 2014-02-26	*/	sp=0;	if (ch<ttlintegr && dch==1)	{		br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));		/* have binary characters change on branches - if they are not autapomorphic, then they need to diagnose multiple species THIS WAS REMOVED 10/14/2003		else				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (avnodes-used));*/		sp = branches[br];			/* this shouldn't be necessary, but occassionaly the random number generator */		/* produces a number outside of the proscribed limits */		while (trpd[sp]==0 || br>=(ttlbr-used))	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			sp = branches[br];			}		}	else	{		while (sp<(notu-1))	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			/* have binary characters change on branches - if they are not autapomorphic, then they need to diagnose multiple species THIS WAS REMOVED 10/14/2003			else				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (avnodes-used));*/			sp = branches[br];					/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			}	/* to avoid apomorphies, make all of these changes on nodes	*/		}	for (f=0; f<dch; ++f)	{		ch2=set[f];	/* Binary && unordered multistate is Easy */	/* for normal character, have it change until all X states are realized */		if (nstates[ch2]==2 || ctype[ch2]==1)	{			/* changed 10/14/2003 so that non-apomorphic characters	diagnose 2+ species 		*/			/* altered 03/18/2014 so that you stop this if used branches matches total branches	*/	/*		for (st=0; (st<nstates[ch2]-1 || der[ch2]<=1); st=st)	{	*//*			for (st=0; ((st<(nstates[ch2]-1) && used<ttlbr) || der[ch2]<=1); st=st)	{	*/			for (st=0; (st<(nstates[ch2]-1) && used<ttlbr); st=st)	{				/* There are ttlbr-used branches that could change */				if (sp<notu && (matrix[sp][ch2]!=INAP && matrix[sp][ch2]!=UNKNOWN))	{					ev=1;					if (nstates[ch2]==2)	invmatrix[ch2][sp]=matrix[sp][ch2]=1;					else					invmatrix[ch2][sp]=matrix[sp][ch2]=st+1;					++der[ch2];				/* add one to the number of species showing derived condition(s) */					}				else if (sp>notu)	{					/* use st+1 instead of nstates[ch2] here - we want only 0…st+1 not 0…nstates    */					/*		(remember, st has not yet been incremented, so we need st+1) 		   */					/* This section modified 10/14/2003 to make sure characters are not apomorphic */					/* if multistate, then we need at least two iterations */					if (nstates[ch2]>2)	{						/* if we have not yet derived all of the states, do it this way 			*/						/* if deriving first state (i.e., st=0), then it is the same as binary		*/						if (st<nstates[ch2] && st==0)							evolvebinaryinclade(tree[sp-notu],matrix,ch2);						/* if deriving subsequent states, then used change unmodified species to st+1 		*/						else if (st<(nstates[ch2]-1) && st>=1)	{							for (c=1; c<=tree[sp-notu][0]; ++c)	{								sp2=tree[sp-notu][c];								if (matrix[sp2][ch2]==0)	matrix[sp2][ch2]=st+1;								}							}	/*						evolveunorderedinclade(tree[sp-notu],matrix,ch2,st+2,UNKNOWN,INAP);	*/						/* if we have an essentially apomorphic states, then just do it like any other time */						else							evolveunorderedinclade(tree[sp-notu],matrix,ch2,nstates[ch2],UNKNOWN,INAP);						}					else		evolvebinaryinclade(tree[sp-notu],matrix,ch2);					for (c=1; c<=tree[sp-notu][0]; ++c)	{						sp2=tree[sp-notu][c];						if (invmatrix[ch2][sp2]!=matrix[sp2][ch2])	ev=1;						invmatrix[ch2][sp2]=matrix[sp2][ch2];						if (invmatrix[ch2][sp2]!=0 && (invmatrix[ch2][sp2]!=UNKNOWN && invmatrix[ch2][sp2]!=INAP))							++der[ch2];						else if (invmatrix[ch2][sp2]==0)							--der[ch2];					/* this will happen only if there are reversals */						}					/* if there was a change, then tally it */					}				a=ttlbr-used;				used=used+trpd[sp];				/* remove branches from possible change list (but only if more changes must be made)	*/				if (st<(nstates[ch2]-1) || der[ch2]<1)	/* check elsewhere where this is der[ch2]<=1	*/					removefromivector(branches,sp,&a);									if (used<steps[ch2])	{					printf("ERROR LINE 12350 - there are more changes than deleted branches for Ch%d…\n",ch2+1);					}				/* if ev=1 then the state has been derived */				if (ev==1)	{					++mpd[sp];					taxachange[ch2][steps[ch2]]=sp;					++steps[ch2];					if (dch==1)	++indch[ch2];					++deltas;					++st;	/* we increment this only if we have made a change */					}				}	/*end derivation of state */			}	/* end loop for binary / unordered characters */			/* Ordered Multistates are tougher */		else if (nstates[ch2]>2 && ctype[ch2]==0)	{			used=0;			for (st=0; (st<nstates[ch2]-1 && (steps[ch2]<mxdel && steps[ch2]<maxch[ch2])); st=st)	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp=branches[br];				/* this shouldn't be necessary, but occassionaly the random number generator */				/* produces a number outside of the proscribed limits */				while (trpd[sp]==0 || br>=(ttlbr-used))	{					br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));					sp = branches[br];					}				if (sp<notu && (matrix[sp][ch2]!=INAP && matrix[sp][ch2]!=UNKNOWN))	{					matrix[sp][ch2]=multi(matrix[sp][ch2],bias[ch2]);					multistatevett(matrix, ch2, nstates[ch2], notu, INAP, UNKNOWN);					/* in this case all taxa must be examined just in case the matrix has been recentered due to a negative number */					for (sp2=0; sp2<notu; ++sp2)	{						if (ev==0 && invmatrix[ch2][sp2]!=matrix[sp2][ch2])	ev=1;						invmatrix[ch2][sp2]=matrix[sp2][ch2];						}					ev=1;					}									else if (sp>notu)	{					flip = ((int) (100 * rand() / RAND_MAX));					if (flip<bias[ch2])	flip=1;					else				flip=-1;					evolveorderedinclade(tree[sp-notu],matrix,ch2,flip, INAP, UNKNOWN);					multistatevett(matrix, ch2, nstates[ch2], notu, INAP, UNKNOWN);					/* in this case all taxa must be modified just in case the matrix has been recentered due to a negative number */					for (sp2=0; sp2<notu; ++sp2)	{						if (ev==0 && invmatrix[ch2][sp2]!=matrix[sp2][ch2])	ev=1;						invmatrix[ch2][sp2]=matrix[sp2][ch2];						}					}									/* if ev=1 then the state has been derived */				if (ev==1)	{					++mpd[sp];					taxachange[ch2][steps[ch2]]=sp;					++steps[ch2];					++deltas;					/* note - do not increment st here - that is done only if a new state is derived */					}				/* check if all states have been derived */				/* note: this is needed only for ordered multistates */				if (steps[ch2]>=nstates[ch2]-1)	{					for(a=0; a<notu; ++a)	{						if (matrix[a][ch2]>st && (matrix[a][ch2]!=INAP && matrix[a][ch2]!=UNKNOWN))							st=matrix[a][ch2];						}					}				a=ttlbr-used;				used=used+trpd[sp];				/* remove branches from possible change list (but only if more changes must be made)	*/				if (st<(nstates[ch2]-1))					removefromivector(branches,sp,&a);				if (used<steps[ch2])					printf("ERROR LINE 12427 - there are more changes than deleted branches for Ch%d…\n",ch2+1);								/* emergency reboot procedure! - clear everything and start over again */				if (used==ttlbr)	{					for (a=0; a<steps[ch2]; ++a)	{						sp=taxachange[ch2][a];						--mpd[sp];						taxachange[ch2][a]=0;						}					deltas=deltas-steps[ch2];					st=steps[ch2]=used=0;					for (sp=0; sp<notu; ++sp)						if (matrix[sp][ch2]!=INAP && matrix[sp][ch2]!=UNKNOWN)							invmatrix[ch2][sp]=matrix[sp][ch2]=0;					for (sp=0; sp<ttlbr; ++sp)	branches[sp]=available[sp];					}				}			/* if there are many states and few taxa, then you do not want to mess with this anymore.  Any changes will either eliminate extreme states,			or simply shift the state up or down one (resulting in no observable change once standardized.  So, if steps >= half the taxa, then shut it down */			}	/* end loop for ordered multistates */		}	/* end loop of integrated characters (just one if independent)	*/	}	/* end derivation of all character states *//* Step #2: make sure that each apomorphic species has a derivation */for (sp=0; (sp<notu+nodes && deltas<ttlstp); ++sp)	{	if (mpd[sp]==0 && trpd[sp]>0)	{		while (mpd[sp]==0)	{			ev=0;			ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));			while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))				ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));			/* introduce correlated change loop here	*/						x=0.0f;			dch=1;			if (ch<ttlintegr)	{				x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);	/* see if whole set or just character changes	*/				}			if (x>=setinfo[2])	{				cset=ch/(b=setinfo[1]);		/* 0…4 go to cset = 0 if there are 5 per set	*/				for (b=0; b<(dch=setinfo[1]); ++b)	set[b]=integrated[cset][b];				}	/* coordinated shift in characters	*/			else	set[0]=ch;			for (f=0; f<dch; ++f)	{				ch=set[f];				if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{					if (nstates[ch]==2)							invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);					else if (ctype[ch]==1)						invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);					else if (ctype[ch]==0)	{						invmatrix[ch][sp]=matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);						/* make sure no negative numbers are kept! */						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					ev=1;	/* this means that there was a change */					}							else if (sp>notu)	{					d=0;					/* make sure that there are taxa with scorable conditions for this character 		*/					/* and also that not all the descendants have changed already for this character 	*/					/* (the latter can be omitted as evolution cannot know this - but it makes the 		*/					/* output easier to compare to empirical studies.)									*/							for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{						sp2=tree[sp-notu][sc];						if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;						else	{							for (c=0; c<steps[ch]; ++c)	{								if (taxachange[ch][c]==sp2)	{									++d;									c=steps[ch];									}								}							}		/* if any taxa have not yet changed, then d < clade diversity */						}	/* end search for scored taxa */						/* if d is less than clade diversity, then proceed with change */					if (d<tree[sp-notu][0])	{						/* if character is an unordered multistate, then we need an array	*/						/* that tells how each state changed withing the clade				*/						if (ctype[ch]==1)	{							/* routine for unordered multistates */							if (nstates[ch]>2)	{								evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);								}							/* routine for binaries */							else	{								evolvebinaryinclade(tree[sp-notu],matrix,ch);								}							}	/* end routine for unordered / binary characters */						/* routine for ordered multistate */						else {							/* flip is used only for multistates */							flip = ((int) (100 * rand() / RAND_MAX));							if (flip<bias[ch])	flip=1;							else				flip=-1;							evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);							multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);							}						/* now make sure that there was change */						for (c=0; c<notu; ++c)	{							if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;							invmatrix[ch][c]=matrix[c][ch];							}						}	/* end conditional loop */					}	/* end routine for clade */				/* if there was a change, then ev = 1.  Now tally the information */				if (ev==1)	{					taxachange[ch][steps[ch]]=sp;					++steps[ch];					++mpd[sp];					++deltas;					}	/* add changes if there actually was a change */				}	/* end changes (only 1 if independent)	*/			}	/* routine is repeated until an apomorphy is acquired */					}	/* end derivation of apomorphy for this branch */	}	/* end derivation for each apomorphic branch *//* Step #3: DO ADDITIONAL STEPS NOW *//* this is when we use the rate shift	*/	for (deltas=deltas; deltas < ttlstp; deltas=deltas)	{	/* first choose a character */	ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))		ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	/**************************************************************************/		x=0.0f;	dch=1;	if (ch<ttlintegr)	{		x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);	/* see if whole set or just character changes	*/		}	if (x>=setinfo[2])	{		cset=ch/(b=setinfo[1]);		/* 0…4 go to cset = 0 if there are 5 per set	*/		for (b=0; b<(dch=setinfo[1]); ++b)	set[b]=integrated[cset][b];		}	/* coordinated shift in characters	*/	else	set[0]=ch;	/* do not change the character on a branch where it already has changed */	for (br=0; br<ttlbr; ++br)	branches[br]=available[br];		used=0;	/* used will tally the number of deleted branches */	for (d=0; d<steps[ch]; ++d)	{		for (c=0; c<(ttlbr-used); ++c)	{			/* if branch with change is found, delete it from possible changes */			if (branches[c]==taxachange[ch][d])	{				for (a=c; a<ttlbr-1; ++a)	branches[a]=branches[a+1];				/* some taxa will be in 2+ times - step back to delete them all */				--c;				branches[ttlbr-(used+1)]=-1;				++used;				}			}		}	/* choose a branch from one available */	/* used will be equal to or greater than steps[ch] (due to long branches) */	br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));	sp = branches[br];	/* this shouldn't be necessary, but occassionaly the random number generator */	/* produces a number outside of the proscribed limits */	while (trpd[sp]==0 || br>=(ttlbr-used))	{		br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));		sp = branches[br];		}	ev=0;	for (f=0; f<dch; ++f)	{		ch=set[f];		if (nstates[ch]==2)	{			/* routine for binary characters */			if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{				invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);				ev=1;				}			/* routine for clade */			else if (sp>=notu)	{				evolvebinaryinclade(tree[sp-notu],matrix,ch);				for (a=1; a<=tree[sp-notu][0]; ++a)	{					sp2=tree[sp-notu][a];					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					}					}	/* end routine for clade */			}		/* Ordered Multistates */		else if (ctype[ch]==0)	{			flip = ((int) (100 * rand() / RAND_MAX));			if (flip<bias[ch])						flip=1;			else									flip=-1;						/* routine for species */			if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{				invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;				if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;				else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;				ev=1;				}			/* routine for clade */			else if (sp>=notu)	{				/* make sure that not all descendants have already changed! */				d=0;				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;					else	{						for (c=0; c<steps[ch]; ++c)	{							if (taxachange[ch][c]==sp2)	{								++d;								c=steps[ch];								}	/* end test of whether particular change matches species */							}	/* end search through each step */						}	/* end search for unchanged taxa */					}				if (d<tree[sp-notu][0])	{					evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);					multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);					}				/* now make sure that there was change */				for (c=0; c<notu; ++c)	{					if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;					invmatrix[ch][c]=matrix[c][ch];					}				}	/* end routine for clade */			}	/** END ROUTINE FOR ORDERED MULTISTATES **/		/* Unordered Multistate Characters */		else if (ctype[ch]==1)	{			if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{				invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);				ev=1;				}							else if (sp>notu)	{				evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);				/* make sure that there is change */				for (a=1; a<=tree[sp-notu][0]; ++a)	{					sp2=tree[sp-notu][a];					if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{						if (invmatrix[ch][sp2]!=matrix[sp2][ch])	{							invmatrix[ch][sp2]=matrix[sp2][ch];							ev=1;							}						}					}				}	/* end unordered change for a clade */				/* if change is made, tally */			}	/* end unordered change */		/* if ev = 1, then there has been a change.  Tally it */		if (ev==1)	{			++deltas;			taxachange[ch][steps[ch]]=sp;			++steps[ch];			++mpd[sp];			}		}	/* end all related changes	*/	}	/* end additional steps */free_ivector(der);free_ivector(mpd);free_ivector(trpd);free_ivector(steps);free_ivector(available);free_ivector(branches);free_ivector(aptaxa);free_ivector(set);free_ivector(indch);free_imatrix(integrated,a=setinfo[0],b=setinfo[1]);free_imatrix(taxachange,nchars,mxdel);free_lmatrix(invmatrix,nchars, notu);}/*click on the first character at some clade with N>>set size	Subsequent changes can reverse or add 3rd state.****************************************************************************************************************/void evolvematrix_evolve_sets(long **tree, int notu, int nodes, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, double *setinfo, int ttlstp, int UNKNOWN, int INAP){int		a, b, c, d, f, br, ch, ch2, sc, ev, flip, sp, sp2;int		st, u, clse, best;int		avnodes, used, deltas, mxdel, ttlbr=0;int		ttlintegr, dch, cset;int		*available, *branches, *steps, *trpd, *mpd, *der, *aptaxa, *set, *indch;int		**taxachange, **integrated;/*, **descnodes;	/* for debugging */long	**invmatrix;double 	x;/* add something for independent change in each character, too	*//* find the number of nodes and their diversities 	nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}										/* 2011-02-03: somehow, someway, I need a safeguard against fully bifurcating trees.... *//*nodes=cladecountbytaxa(tree,notu);		/* number of clades in tree									*/integrated=imatrix(a=setinfo[0],b=setinfo[1]);set=ivector(b);ttlintegr=0;for (a=0; a<setinfo[0]; ++a)	{	for (b=0; b<setinfo[1]; ++b)	{		integrated[a][b]=ttlintegr;		++ttlintegr;		}	}indch=ivector(nchars);mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character 				*/mpd=ivector(nodes+notu);					/* morphologic changes along each branch 					*/trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */steps=ivector(nchars);						/* number of times each character changes 					*/der=ivector(nchars);						/* number of taxa with derived condition for each character *//*fa=ivector(nodes+notu);						/* first appearance times for each branch */trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[nodes][sp];		/* array tree[notu-1] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[nodes+1][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	}	/**/	if (ttlbr<mxdel)	mxdel=ttlbr;/*if (ttltx<mxdel)	mxdel=ttltx;	/* 2014-03-21: we allow only as many changes as there are taxa that have changes	*//* allocate memory for arrays containing branches needing changes */available=ivector(ttlbr);branches=ivector(ttlbr);taxachange=imatrix(nchars, mxdel);	/* gives taxa that change for character */invmatrix=lmatrix(nchars, notu);aptaxa=applicabletaxa(matrix, nchars, notu, INAP);/* BEGIN HERE 5/18/01 describe each clade in terms of all species within it *//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********/	/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */avnodes=b=0;for (a=1; a<nodes; ++a)	{	avnodes=avnodes+trpd[a+notu];	for (c=0; c<trpd[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		available[b]=a;		++b;		}	}/* clear matrix */for (ch=0; ch<nchars; ++ch)	{	for (a=0; a<notu; ++a)	{		if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{			matrix[a][ch]=0;			}		invmatrix[ch][a]=matrix[a][ch];	/* for debugging */		}	}deltas=0;/* Step 1: Make sure each state is derived for each character *//*derive_each_char(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, aptaxa, mpd, trpd, notu, nchars, maxstp, mxdel, UNKNOWN, INAP, tree, branches, available, nodes, ttlbr);	*/for (ch=0; (ch<nchars && deltas<ttlstp); ++ch)	{	while ((maxch[ch]==0 && steps[ch]>0) && ch<nchars)	++ch;	/* skip integrated characters that already have changed	*/	if (ch>=nchars)			break;	steps[ch]=st=0;	clearivector(taxachange[ch],mxdel,-1);	ev=0;		if (ch<ttlintegr && (ch%(b=setinfo[1]))==0)	{		cset=ch/(b=setinfo[1]);		/* 0…4 go to cset = 0 if there are 5 per set	*/		for (b=0; b<(dch=setinfo[1]); ++b)	set[b]=integrated[cset][b];		/* now find a branch with N>>set size; try set size x 2	*/		}	else	{		set[0]=ch;		dch=1;		}	/* make sure that inapplicable characters have at least one taxon that can be changed */	if (aptaxa[ch]<notu)	{		/* count unknowns - these will be put back in later */		u=0;		for (a=0; a<notu; ++a)	if (matrix[a][ch]==UNKNOWN)	++u;		/* now find a node that has similar diversity */		clse=RAND_MAX;				/* start from the bottom if most taxa are scored */		if (aptaxa[ch]>(notu/2))	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==(notu-aptaxa[ch]))	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs((notu-aptaxa[ch])-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}		/* start from the top otherwise */		else	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==aptaxa[ch])	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs(aptaxa[ch]-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}				for (sp=0; sp<notu; ++sp)	{			if (aptaxa[ch]>(notu/2))	matrix[sp][ch]=0;			else						matrix[sp][ch]=INAP;			}		for (a=1; a<tree[best][0]; ++a)	{			sp=tree[best][a];			matrix[sp][a]=0;			}		}	/* end initial creation of inapplicable character */		/* make autapomorphic characters change on one species only */	/* invariants do not change at all */	for (ch=ch; maxch[ch]<=1; ++ch)	{		/* skip invariants and make autapomorphies autapomorphic */		if	(maxch[ch]==1)	{			c=0;			/* we will sample only from otus here - so do not include clades in branches array! */			/* this part rewritten with Cubs winning 7-0 against the Marlins in Game 4 */			for (sp=0; sp<notu; ++sp)				if ((matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP) && trpd[sp]>0)	++c;			if (c>0)	{				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || (trpd[sp]==0 || sp>=notu))					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=1;				taxachange[ch][0]=sp;				}			/* if only cells belong to species with 0 length branches */			if (c==0)	{				/* flip-flop an unknown apomorphic species with a known plesiomorphic one - give plesiomorphic species a ? and the other a 1 */				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || sp2>=notu)					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);								sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while (trpd[sp2]==0 || sp2>=notu)					sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp2][ch];				invmatrix[ch][sp2]=matrix[sp2][ch]=1;				taxachange[ch][0]=sp2;				}	/* end routine if all scored species were unknown */			ev=1;			++deltas;			++steps[ch];			++mpd[ch];			}		}	/* this should leave us with a character that needs to be changed OR out of characters */	if (ch>=nchars)	break;			used=0;	/* this tells how many branches are discarded; used > steps IF there are absents */	/* branch length is taken into account by trpd */	equalivector(branches,available,ttlbr);		/* moved 2014-04-07 to allow for correlated change more easily	*/	ev=0;				/* fixed 2014-02-26	*/	sp=0;	if (ch<ttlintegr && dch==1)	{		br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));		/* have binary characters change on branches - if they are not autapomorphic, then they need to diagnose multiple species THIS WAS REMOVED 10/14/2003		else				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (avnodes-used));*/		sp = branches[br];			/* this shouldn't be necessary, but occassionaly the random number generator */		/* produces a number outside of the proscribed limits */		while (trpd[sp]==0 || br>=(ttlbr-used))	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			sp = branches[br];			}		}	else	{		while (sp<(notu-1))	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			/* have binary characters change on branches - if they are not autapomorphic, then they need to diagnose multiple species THIS WAS REMOVED 10/14/2003			else				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (avnodes-used));*/			sp = branches[br];					/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			}	/* to avoid apomorphies, make all of these changes on nodes	*/		}	for (f=0; f<dch; ++f)	{		ch2=set[f];	/* Binary && unordered multistate is Easy */	/* for normal character, have it change until all X states are realized */		if (nstates[ch2]==2 || ctype[ch2]==1)	{			/* changed 10/14/2003 so that non-apomorphic characters	diagnose 2+ species 		*/			/* altered 03/18/2014 so that you stop this if used branches matches total branches	*/	/*		for (st=0; (st<nstates[ch2]-1 || der[ch2]<=1); st=st)	{	*//*			for (st=0; ((st<(nstates[ch2]-1) && used<ttlbr) || der[ch2]<=1); st=st)	{	*/			for (st=0; (st<(nstates[ch2]-1) && used<ttlbr); st=st)	{				/* There are ttlbr-used branches that could change */				if (sp<notu && (matrix[sp][ch2]!=INAP && matrix[sp][ch2]!=UNKNOWN))	{					ev=1;					if (nstates[ch2]==2)	invmatrix[ch2][sp]=matrix[sp][ch2]=1;					else					invmatrix[ch2][sp]=matrix[sp][ch2]=st+1;					++der[ch2];				/* add one to the number of species showing derived condition(s) */					}				else if (sp>notu)	{					/* use st+1 instead of nstates[ch2] here - we want only 0…st+1 not 0…nstates    */					/*		(remember, st has not yet been incremented, so we need st+1) 		   */					/* This section modified 10/14/2003 to make sure characters are not apomorphic */					/* if multistate, then we need at least two iterations */					if (nstates[ch2]>2)	{						/* if we have not yet derived all of the states, do it this way 			*/						/* if deriving first state (i.e., st=0), then it is the same as binary		*/						if (st<nstates[ch2] && st==0)							evolvebinaryinclade(tree[sp-notu],matrix,ch2);						/* if deriving subsequent states, then used change unmodified species to st+1 		*/						else if (st<(nstates[ch2]-1) && st>=1)	{							for (c=1; c<=tree[sp-notu][0]; ++c)	{								sp2=tree[sp-notu][c];								if (matrix[sp2][ch2]==0)	matrix[sp2][ch2]=st+1;								}							}	/*						evolveunorderedinclade(tree[sp-notu],matrix,ch2,st+2,UNKNOWN,INAP);	*/						/* if we have an essentially apomorphic states, then just do it like any other time */						else							evolveunorderedinclade(tree[sp-notu],matrix,ch2,nstates[ch2],UNKNOWN,INAP);						}					else		evolvebinaryinclade(tree[sp-notu],matrix,ch2);					for (c=1; c<=tree[sp-notu][0]; ++c)	{						sp2=tree[sp-notu][c];						if (invmatrix[ch2][sp2]!=matrix[sp2][ch2])	ev=1;						invmatrix[ch2][sp2]=matrix[sp2][ch2];						if (invmatrix[ch2][sp2]!=0 && (invmatrix[ch2][sp2]!=UNKNOWN && invmatrix[ch2][sp2]!=INAP))							++der[ch2];						else if (invmatrix[ch2][sp2]==0)							--der[ch2];					/* this will happen only if there are reversals */						}					/* if there was a change, then tally it */					}				a=ttlbr-used;				used=used+trpd[sp];				/* remove branches from possible change list (but only if more changes must be made)	*/				if (st<(nstates[ch2]-1) || der[ch2]<1)	/* check elsewhere where this is der[ch2]<=1	*/					removefromivector(branches,sp,&a);									if (used<steps[ch2])	{					printf("ERROR LINE 12350 - there are more changes than deleted branches for Ch%d…\n",ch2+1);					}				/* if ev=1 then the state has been derived */				if (ev==1)	{					++mpd[sp];					taxachange[ch2][steps[ch2]]=sp;					++steps[ch2];					if (dch==1)	++indch[ch2];					++deltas;					++st;	/* we increment this only if we have made a change */					}				}	/*end derivation of state */			}	/* end loop for binary / unordered characters */			/* Ordered Multistates are tougher */		else if (nstates[ch2]>2 && ctype[ch2]==0)	{			used=0;			for (st=0; (st<nstates[ch2]-1 && (steps[ch2]<mxdel && steps[ch2]<maxch[ch2])); st=st)	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp=branches[br];				/* this shouldn't be necessary, but occassionaly the random number generator */				/* produces a number outside of the proscribed limits */				while (trpd[sp]==0 || br>=(ttlbr-used))	{					br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));					sp = branches[br];					}				if (sp<notu && (matrix[sp][ch2]!=INAP && matrix[sp][ch2]!=UNKNOWN))	{					matrix[sp][ch2]=multi(matrix[sp][ch2],bias[ch2]);					multistatevett(matrix, ch2, nstates[ch2], notu, INAP, UNKNOWN);					/* in this case all taxa must be examined just in case the matrix has been recentered due to a negative number */					for (sp2=0; sp2<notu; ++sp2)	{						if (ev==0 && invmatrix[ch2][sp2]!=matrix[sp2][ch2])	ev=1;						invmatrix[ch2][sp2]=matrix[sp2][ch2];						}					ev=1;					}									else if (sp>notu)	{					flip = ((int) (100 * rand() / RAND_MAX));					if (flip<bias[ch2])	flip=1;					else				flip=-1;					evolveorderedinclade(tree[sp-notu],matrix,ch2,flip, INAP, UNKNOWN);					multistatevett(matrix, ch2, nstates[ch2], notu, INAP, UNKNOWN);					/* in this case all taxa must be modified just in case the matrix has been recentered due to a negative number */					for (sp2=0; sp2<notu; ++sp2)	{						if (ev==0 && invmatrix[ch2][sp2]!=matrix[sp2][ch2])	ev=1;						invmatrix[ch2][sp2]=matrix[sp2][ch2];						}					}									/* if ev=1 then the state has been derived */				if (ev==1)	{					++mpd[sp];					taxachange[ch2][steps[ch2]]=sp;					++steps[ch2];					++deltas;					/* note - do not increment st here - that is done only if a new state is derived */					}				/* check if all states have been derived */				/* note: this is needed only for ordered multistates */				if (steps[ch2]>=nstates[ch2]-1)	{					for(a=0; a<notu; ++a)	{						if (matrix[a][ch2]>st && (matrix[a][ch2]!=INAP && matrix[a][ch2]!=UNKNOWN))							st=matrix[a][ch2];						}					}				a=ttlbr-used;				used=used+trpd[sp];				/* remove branches from possible change list (but only if more changes must be made)	*/				if (st<(nstates[ch2]-1))					removefromivector(branches,sp,&a);				if (used<steps[ch2])					printf("ERROR LINE 12427 - there are more changes than deleted branches for Ch%d…\n",ch2+1);								/* emergency reboot procedure! - clear everything and start over again */				if (used==ttlbr)	{					for (a=0; a<steps[ch2]; ++a)	{						sp=taxachange[ch2][a];						--mpd[sp];						taxachange[ch2][a]=0;						}					deltas=deltas-steps[ch2];					st=steps[ch2]=used=0;					for (sp=0; sp<notu; ++sp)						if (matrix[sp][ch2]!=INAP && matrix[sp][ch2]!=UNKNOWN)							invmatrix[ch2][sp]=matrix[sp][ch2]=0;					for (sp=0; sp<ttlbr; ++sp)	branches[sp]=available[sp];					}				}			/* if there are many states and few taxa, then you do not want to mess with this anymore.  Any changes will either eliminate extreme states,			or simply shift the state up or down one (resulting in no observable change once standardized.  So, if steps >= half the taxa, then shut it down */			}	/* end loop for ordered multistates */		}	/* end loop of integrated characters (just one if independent)	*/	}	/* end derivation of all character states *//* Step #2: make sure that each apomorphic species has a derivation */for (sp=0; (sp<notu+nodes && deltas<ttlstp); ++sp)	{	if (mpd[sp]==0 && trpd[sp]>0)	{		while (mpd[sp]==0)	{			ev=0;			ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));			while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))				ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));			/* introduce correlated change loop here	*/						x=0.0f;			dch=1;			if (ch<ttlintegr)	{				x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);	/* see if whole set or just character changes	*/				}			if (x>=setinfo[2])	{				cset=ch/(b=setinfo[1]);		/* 0…4 go to cset = 0 if there are 5 per set	*/				for (b=0; b<(dch=setinfo[1]); ++b)	set[b]=integrated[cset][b];				}	/* coordinated shift in characters	*/			else	set[0]=ch;			for (f=0; f<dch; ++f)	{				ch=set[f];				if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{					if (nstates[ch]==2)							invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);					else if (ctype[ch]==1)						invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);					else if (ctype[ch]==0)	{						invmatrix[ch][sp]=matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);						/* make sure no negative numbers are kept! */						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					ev=1;	/* this means that there was a change */					}							else if (sp>notu)	{					d=0;					/* make sure that there are taxa with scorable conditions for this character 		*/					/* and also that not all the descendants have changed already for this character 	*/					/* (the latter can be omitted as evolution cannot know this - but it makes the 		*/					/* output easier to compare to empirical studies.)									*/							for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{						sp2=tree[sp-notu][sc];						if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;						else	{							for (c=0; c<steps[ch]; ++c)	{								if (taxachange[ch][c]==sp2)	{									++d;									c=steps[ch];									}								}							}		/* if any taxa have not yet changed, then d < clade diversity */						}	/* end search for scored taxa */						/* if d is less than clade diversity, then proceed with change */					if (d<tree[sp-notu][0])	{						/* if character is an unordered multistate, then we need an array	*/						/* that tells how each state changed withing the clade				*/						if (ctype[ch]==1)	{							/* routine for unordered multistates */							if (nstates[ch]>2)	{								evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);								}							/* routine for binaries */							else	{								evolvebinaryinclade(tree[sp-notu],matrix,ch);								}							}	/* end routine for unordered / binary characters */						/* routine for ordered multistate */						else {							/* flip is used only for multistates */							flip = ((int) (100 * rand() / RAND_MAX));							if (flip<bias[ch])	flip=1;							else				flip=-1;							evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);							multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);							}						/* now make sure that there was change */						for (c=0; c<notu; ++c)	{							if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;							invmatrix[ch][c]=matrix[c][ch];							}						}	/* end conditional loop */					}	/* end routine for clade */				/* if there was a change, then ev = 1.  Now tally the information */				if (ev==1)	{					taxachange[ch][steps[ch]]=sp;					++steps[ch];					++mpd[sp];					++deltas;					}	/* add changes if there actually was a change */				}	/* end changes (only 1 if independent)	*/			}	/* routine is repeated until an apomorphy is acquired */					}	/* end derivation of apomorphy for this branch */	}	/* end derivation for each apomorphic branch *//* Step #3: DO ADDITIONAL STEPS NOW *//* this is when we use the rate shift	*/	for (deltas=deltas; deltas < ttlstp; deltas=deltas)	{	/* first choose a character */	ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))		ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	/**************************************************************************/		x=0.0f;	dch=1;	if (ch<ttlintegr)	{		x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);	/* see if whole set or just character changes	*/		}	if (x>=setinfo[2])	{		cset=ch/(b=setinfo[1]);		/* 0…4 go to cset = 0 if there are 5 per set	*/		for (b=0; b<(dch=setinfo[1]); ++b)	set[b]=integrated[cset][b];		}	/* coordinated shift in characters	*/	else	set[0]=ch;	/* do not change the character on a branch where it already has changed */	for (br=0; br<ttlbr; ++br)	branches[br]=available[br];		used=0;	/* used will tally the number of deleted branches */	for (d=0; d<steps[ch]; ++d)	{		for (c=0; c<(ttlbr-used); ++c)	{			/* if branch with change is found, delete it from possible changes */			if (branches[c]==taxachange[ch][d])	{				for (a=c; a<ttlbr-1; ++a)	branches[a]=branches[a+1];				/* some taxa will be in 2+ times - step back to delete them all */				--c;				branches[ttlbr-(used+1)]=-1;				++used;				}			}		}	/* choose a branch from one available */	/* used will be equal to or greater than steps[ch] (due to long branches) */	br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));	sp = branches[br];	/* this shouldn't be necessary, but occassionaly the random number generator */	/* produces a number outside of the proscribed limits */	while (trpd[sp]==0 || br>=(ttlbr-used))	{		br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));		sp = branches[br];		}	ev=0;	for (f=0; f<dch; ++f)	{		ch=set[f];		if (nstates[ch]==2)	{			/* routine for binary characters */			if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{				invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);				ev=1;				}			/* routine for clade */			else if (sp>=notu)	{				evolvebinaryinclade(tree[sp-notu],matrix,ch);				for (a=1; a<=tree[sp-notu][0]; ++a)	{					sp2=tree[sp-notu][a];					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					}					}	/* end routine for clade */			}		/* Ordered Multistates */		else if (ctype[ch]==0)	{			flip = ((int) (100 * rand() / RAND_MAX));			if (flip<bias[ch])						flip=1;			else									flip=-1;						/* routine for species */			if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{				invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;				if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;				else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;				ev=1;				}			/* routine for clade */			else if (sp>=notu)	{				/* make sure that not all descendants have already changed! */				d=0;				for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;					else	{						for (c=0; c<steps[ch]; ++c)	{							if (taxachange[ch][c]==sp2)	{								++d;								c=steps[ch];								}	/* end test of whether particular change matches species */							}	/* end search through each step */						}	/* end search for unchanged taxa */					}				if (d<tree[sp-notu][0])	{					evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);					multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);					}				/* now make sure that there was change */				for (c=0; c<notu; ++c)	{					if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;					invmatrix[ch][c]=matrix[c][ch];					}				}	/* end routine for clade */			}	/** END ROUTINE FOR ORDERED MULTISTATES **/		/* Unordered Multistate Characters */		else if (ctype[ch]==1)	{			if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{				invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);				ev=1;				}							else if (sp>notu)	{				evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);				/* make sure that there is change */				for (a=1; a<=tree[sp-notu][0]; ++a)	{					sp2=tree[sp-notu][a];					if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{						if (invmatrix[ch][sp2]!=matrix[sp2][ch])	{							invmatrix[ch][sp2]=matrix[sp2][ch];							ev=1;							}						}					}				}	/* end unordered change for a clade */				/* if change is made, tally */			}	/* end unordered change */		/* if ev = 1, then there has been a change.  Tally it */		if (ev==1)	{			++deltas;			taxachange[ch][steps[ch]]=sp;			++steps[ch];			++mpd[sp];			}		}	/* end all related changes	*/	}	/* end additional steps */free_ivector(der);free_ivector(mpd);free_ivector(trpd);free_ivector(steps);free_ivector(available);free_ivector(branches);free_ivector(aptaxa);free_ivector(set);free_ivector(indch);free_imatrix(integrated,a=setinfo[0],b=setinfo[1]);free_imatrix(taxachange,nchars,mxdel);free_lmatrix(invmatrix,nchars, notu);}