#define TreeLikelihood#include "TreeLikelihood.h"#include "Probability.h"#include "memory.h"#include "sort.h"#include <stdlib.h>#include <stdio.h>#include <time.h>#include <math.h>#include <string.h>double **FossilAncestorLikelihood(double **MlnL, long **matrix, int ANC, int SOTU, double *RATE, int *NSTATES, int NCHARS, int UNKNOWN, int INAP, double LAMBDA, int *FA, int *LA, double GAPINC){int		a;int		sp, ch, br, st, maxbr;double	gap, mngap, mxgap, stage;double	P, Pbr, Pcond, Pdelta, Pp;double	denom, num;MlnL[ANC]=cleardbvector(MlnL[ANC], SOTU, 0);for (sp=0; sp<SOTU; ++sp)	{	if (sp==ANC)	++sp;	if (sp>=SOTU)	break;		mngap = (FA[sp]-LA[ANC]);	if (mngap<=0)	mngap = GAPINC;		mxgap=(FA[sp]-FA[ANC]);	/* make sure that the maximum gap is at least the minimum gap plus a little */	if (mxgap<=0)	mxgap=mngap;	for (ch=0; ch<NCHARS; ++ch)	{		if ((matrix[ANC][ch]!=UNKNOWN && matrix[ANC][ch]!=INAP) && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			/* routine if characters are the same is easy */			P=0;			/* add likelihoods until it no longer is profitable */			for (br=1; br<(maxbr=10); ++br)	{				/* calculate the probability of br species over interval gap 	*/				/* we will assume that all possible gaps are equiprobable here	*/				/* This will make the conditional probability 1 / options		*/				Pcond = 0;				for (gap=mngap; gap<=mxgap+GAPINC; gap=gap+1)	Pcond=Pcond+1;								if (Pcond==0)	Pcond = 1;				else			Pcond = 1/Pcond;				/* Pbr is the probability of net stasis over the branch */				Pbr=0;				stage=FA[sp];				a=0;								for (gap=mngap; gap<=mxgap+GAPINC; gap=gap+1)	{					if (gap>0)	{						/* insert stratigraphic test here		*/						Pbr = Pbr+Pcond*(Poisson(LAMBDA,gap,br)/(1-Poisson(LAMBDA,gap,0)));						}					}				if (matrix[ANC][ch]==matrix[sp][ch])	{					/* Now, calculate the probability of net stasis over br branches */					/* easy for one branch */					if (br==1)	Pdelta = Pbr*(1-RATE[ch]);					/* must allow for multiple changes if br ³ 2 */					else	{						Pdelta=0;						/* make branches the maximum # of steps */						for (st=0; st<=br; ++st)	{							denom = pow(NSTATES[ch]-1,st);							if (denom==0)	denom=1;							if (st>1)	num=PathsBack(st,NSTATES[ch]);							else		num=1;							/* calculate the probability of st changes and br-st stases */							Pp=pow(RATE[ch],st)*pow((1-RATE[ch]),br-st);							if (st>0 && br>1)								Pp=Combin(st,br)*(num/denom)*Pp;							Pdelta=Pdelta+(Pp*Pbr);							}	/* end examination of multiple changes going nowhere */						}	/* end allowance for silent reversals */					}	/* end calculation when ANC and sp are the same */									/* routine when ANC and sp have different states */				else	{					/* Now, calculate the probability of net change over br branches */					if (br==1)	Pdelta=Pbr*RATE[ch];					else	{						Pdelta=0;						/* make branches the maximum # of steps */						for (st=1; st<=br; ++st)	{							denom = pow(NSTATES[ch]-1,st);							if (denom==0)	denom=1;							if (st>1)	denom-PathsBack(st,NSTATES[ch]);							else		num=1;							num=num/(NSTATES[ch]-1);							/* calculate the probability of st changes and br-st stases */							Pp=pow(RATE[ch],st)*pow((1-RATE[ch]),br-st);							if (st>0 && br>1)								Pp=Combin(st,br)*(num/denom)*Pp;							Pdelta=Pdelta+(Pp*Pbr);							}	/* end examination of multiple changes going to one state */						}	/* end examination of multiple branches */					}	/* end calculation when ANC and sp are the same */				if (br>1 && (P/Pdelta)>100000)	br=maxbr;				P=P+Pdelta;				}	/* end summation over range of possible unsampled ancestors */							MlnL[ANC][sp]=MlnL[ANC][sp]+log(P);			}	/* end likelihood calculation for scored characters */		/* routine for transition from inapplicable to applicable */		/* Probability is simply 1/N with N = # of character states */		else if (matrix[ANC][ch]==INAP)	{			P=NSTATES[ch];			P=1/P;			MlnL[ANC][sp]=MlnL[ANC][sp]+log(P);			}		}	/* end comparison of characters for ANC and sp */	/* show average Support per character */	}	/* end pairwise comparisons for ANC */return MlnL;}double **FossilAncLikelihoodPart(double **MlnL, double **PD, long **matrix, int ANC, int SOTU, double *RATE, int *NSTATES, int NCHARS, int UNKNOWN, int INAP, double LAMBDA, int *FA, int *LA, double GAPINC, int *unavailable, int POSSTAXA){int		a, b, s;int		sp, sp2, ch, br, st, maxbr, maxposs;int		*order;double	gap, mngap, mxgap, stage;double	P, Pbr, Pcond, Pdelta, Pp;double	denom, num;order=ivector(SOTU);order=sortdnintbydouble(order,PD[ANC],SOTU);MlnL[ANC]=cleardbvector(MlnL[ANC], SOTU, 0);/* remove unavailable taxa from consideration */b=0;for (sp=0; sp<SOTU-b; ++sp)	{	a=0;	sp2=order[sp];	for (s=0; s<SOTU; ++s)	{		/* if order[sp] is already in tree, remove it from consideration */		if (unavailable[s]==sp2)	{			a=1;			s=SOTU;			}		}	/* if a==1, then this species is done already */	/* if PD[ANC][sp2]==RAND_MAX, this pairing is forbidden */	if (a==1 || PD[ANC][sp2]==RAND_MAX)	{		remove_int(order,sp2,SOTU-sp);		MlnL[ANC][sp2]=-RAND_MAX;		order[SOTU]=-1;		--sp;	/* decrement so that the next species can be removed too */		++b;	/* increment so that the loop will stop on time			 */		}	}	maxposs=minimum(SOTU-b,POSSTAXA);for (s=0; s<maxposs; ++s)	{	sp=order[s];	if (sp==ANC)	sp=order[++s];	if (sp>=SOTU)	break;		mngap = (FA[sp]-LA[ANC]);	if (mngap<=0)	mngap = GAPINC;		mxgap=(FA[sp]-FA[ANC]);	/* make sure that the maximum gap is at least the minimum gap plus a little */	if (mxgap<=0)	mxgap=mngap;	for (ch=0; ch<NCHARS; ++ch)	{		if ((matrix[ANC][ch]!=UNKNOWN && matrix[ANC][ch]!=INAP) && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			/* routine if characters are the same is easy */			P=0;			/* add likelihoods until it no longer is profitable */			for (br=1; br<(maxbr=10); ++br)	{				/* calculate the probability of br species over interval gap 	*/				/* we will assume that all possible gaps are equiprobable here	*/				/* This will make the conditional probability 1 / options		*/				Pcond = 0;				for (gap=mngap; gap<=mxgap+GAPINC; gap=gap+1)	Pcond=Pcond+1;								if (Pcond==0)	Pcond = 1;				else			Pcond = 1/Pcond;				/* Pbr is the probability of net stasis over the branch */				Pbr=0;				stage=FA[sp];				a=0;								for (gap=mngap; gap<=mxgap+GAPINC; gap=gap+1)	{					if (gap>0)	{						/* insert stratigraphic test here		*/						Pbr = Pbr+Pcond*(Poisson(LAMBDA,gap,br)/(1-Poisson(LAMBDA,gap,0)));						}					}				if (matrix[ANC][ch]==matrix[sp][ch])	{					/* Now, calculate the probability of net stasis over br branches */					/* easy for one branch */					if (br==1)	Pdelta = Pbr*(1-RATE[ch]);					/* must allow for multiple changes if br ³ 2 */					else	{						Pdelta=0;						/* make branches the maximum # of steps */						for (st=0; st<=br; ++st)	{							denom = pow(NSTATES[ch]-1,st);							if (denom==0)	denom=1;							if (st>1)	num=PathsBack(st,NSTATES[ch]);							else		num=1;							/* calculate the probability of st changes and br-st stases */							Pp=pow(RATE[ch],st)*pow((1-RATE[ch]),br-st);							if (st>0 && br>1)								Pp=Combin(st,br)*(num/denom)*Pp;							Pdelta=Pdelta+(Pp*Pbr);							}	/* end examination of multiple changes going nowhere */						}	/* end allowance for silent reversals */					}	/* end calculation when ANC and sp are the same */									/* routine when ANC and sp have different states */				else	{					/* Now, calculate the probability of net change over br branches */					if (br==1)	Pdelta=Pbr*RATE[ch];					else	{						Pdelta=0;						/* make branches the maximum # of steps */						for (st=1; st<=br; ++st)	{							denom = pow(NSTATES[ch]-1,st);							if (denom==0)	denom=1;							if (st>1)	denom-PathsBack(st,NSTATES[ch]);							else		num=1;							num=num/(NSTATES[ch]-1);							/* calculate the probability of st changes and br-st stases */							Pp=pow(RATE[ch],st)*pow((1-RATE[ch]),br-st);							if (st>0 && br>1)								Pp=Combin(st,br)*(num/denom)*Pp;							Pdelta=Pdelta+(Pp*Pbr);							}	/* end examination of multiple changes going to one state */						}	/* end examination of multiple branches */					}	/* end calculation when ANC and sp are the same */				if (br>1 && (P/Pdelta)>100000)	br=maxbr;				P=P+Pdelta;				}	/* end summation over range of possible unsampled ancestors */							MlnL[ANC][sp]=MlnL[ANC][sp]+log(P);			}	/* end likelihood calculation for scored characters */		/* routine for transition from inapplicable to applicable */		/* Probability is simply 1/N with N = # of character states */		else if (matrix[ANC][ch]==INAP)	{			P=NSTATES[ch];			P=1/P;			MlnL[ANC][sp]=MlnL[ANC][sp]+log(P);			}		}	/* end comparison of characters for ANC and sp */	/* show average Support per character */	}	/* end pairwise comparisons for ANC */for (s=POSSTAXA; s<SOTU; ++s)	{	sp=order[s];	MlnL[ANC][sp]=10+(-1*RAND_MAX);	}free_ivector(order);return MlnL;}long **UnknownMatrixAdj(long **matrix, int sp1, int sp2, int nchars, int UNKNOWN, int INAP){int	c;for (c=0; c<nchars; ++c)	{	if (matrix[sp1][c]==UNKNOWN && matrix[sp2][c]!=UNKNOWN)			matrix[sp1][c]=matrix[sp2][c];	else if (matrix[sp1][c]!=UNKNOWN && matrix[sp2][c]==UNKNOWN)	matrix[sp2][c]=matrix[sp1][c];	}	return matrix;}double MkSimple(long **matrix, long **tree, long *states, int notu, int nodes, int nchars)	{int	c,d,n;for (n=(nodes-1); n>=0; --n)	{	for (d=1; d<=tree[n][0]; ++d)	{		for (c=0; c<nchars; ++c)	{						}		}	}}