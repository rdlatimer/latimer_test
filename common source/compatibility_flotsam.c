/* if ordered multistate & binary, then we need to adjust things if the initial condition for the binary is 1	*/if (st2==2)	{	c=0;	while ((t2[c]==UNKNOWN || t2[c]==INAP) && c<notu)	++c;	if(t2[c]==1)		rev=1;	else if (t2[c]==0)	rev=0;	}if (rev==1)	{	c=0;	/* find where 0 begins	*/	while ((t2[c]==UNKNOWN || t2[c]==INAP) || t2[c]==1)	++c;	d=c;	while ((t2[d]==UNKNOWN || t2[d]==INAP) || t2[d]==0)	++d;	if (t1[d]==t1[c] && d>c)	{		for (f=c; t1[f]==t1[c]; ++f)	{			if (t2[f]==1)	t2[f]=0;			else			t2[f]=1;			} 		}	}int ordcompatible(int *t1, int *t2, int type2, int st1, int st2, int notu, int UNKNOWN, int INAP){int	drop, rise, last, sp1, sp2;int incompatible=0;drop=rise=0;/* make sure that there are coded species	*/sp1=0;while ((t2[sp1]==UNKNOWN || t2[sp1]==INAP) && sp1<notu) ++sp1;if (sp1<notu)	{	last = t2[sp1];	/* only bother if character1 is coded	*/	if (t1[sp1]!=UNKNOWN && t1[sp1]!=INAP)	{		for (sp2=sp1+1; sp2<notu; ++sp2)	{			if ((t2[sp2]!=UNKNOWN && t2[sp2]!=INAP))	{				if (t2[sp2]<last)	++drop;				if (t2[sp2]>last)	++rise;				last = t2[sp2];								if (type2==0 && (drop+rise)>=st2)	{					incompatible=1;					sp2=notu;					}				else if ((drop+rise)>st2)	{					incompatible=1;					sp2=notu;					}				}	/* end meaningful comparison for character 2	*/			}	/* end search through character 2	*/		}	/* end meaningful comparison for character 1	*/	}	/* end search of pertinent characters	*/return incompatible;}	/* end routine for ordered multistates	*/	if (sp1<notu)	{		last = t2[sp1];		/* only bother if character1 is coded	*/		if (t1[sp1]!=UNKNOWN && t1[sp1]!=INAP)	{			for (sp2=sp1+1; sp2<notu; ++sp2)	{				if ((t2[sp2]!=UNKNOWN && t2[sp2]!=INAP))	{					if (t2[sp2]<last)	++drop;					if (t2[sp2]>last)	++rise;					last = t2[sp2];										if (type2==0 && (drop+rise)>=st2)	{						incompatible=1;						sp2=notu;						}					else if ((drop+rise)>st2)	{						incompatible=1;						sp2=notu;						}					}	/* end meaningful comparison for character 2	*/				}	/* end search through character 2	*/			}	/* end meaningful comparison for character 1	*/		}	/* end search of pertinent characters	*/