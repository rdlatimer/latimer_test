#define matrixchange#include "matrixchange.h"#include "memory.h"#include <time.h>/* remove_int - removes an integer from an array/*/* Requires: i - an array to be altered;/*			 j - an integer to be removed from array i;/*			 N - the length of the array/**************************************************************************/void remove_int(int *i, int j, int N){int	k, l;for (k=0; k<N; ++k)	{	if (i[k]==j)	{		for (l=k; l<N-1; ++l)	i[l]=i[l+1];		k=N;		}	}/*return i;	*/}/* equalivector: sets v1 equal to v2;/*/* Requires: v1 - new array to get new values;/*			 v2 - original array;/*			 N - the length of the array***************************************************************************************/void equalivector(int *v1, int *v2, int N){int	a;for (a=0; a<N; ++a)	v1[a]=v2[a];/*return v1;*/}/* equalivector: sets v1 equal to v2;/*/* Requires: v1 - new array to get new values;/*			 v2 - original array;/*			 N - the length of the array***************************************************************************************/void equallvector(long *v1, long *v2, int N){int	a;for (a=0; a<N; ++a)	v1[a]=v2[a];/*return v1;*/}/* equaulivector: sets v1 equal to v2;/*/* Requires: v1 - new array to get new values;/*			 v2 - original array;/*			 N - the length of the array***************************************************************************************/void equalulvector(unsigned long *v1, unsigned long *v2, int N){int	a;for (a=0; a<N; ++a)	v1[a]=v2[a];/*return v1;*/}/* equaldvector: sets v1 equal to v2;/*/* Requires: v1 - new array to get new values;/*			 v2 - original array;/*			 N - the length of the array***************************************************************************************/void equaldvector(double *v1, double *v2, int N){int	a;for (a=0; a<N; ++a)	v1[a]=v2[a];/*return v1;*/}/* equalintmatrix: sets mat1 equal to mat2;/****************************************************************************************/void equalimatrix(int **mat1, int **mat2, int R, int C){int	a, b;for (a=0; a<R; ++a)	for (b=0; b<C; ++b)	mat1[a][b]=mat2[a][b];//return mat1;}/* equaldbmatrix: sets mat1 equal to mat2;/****************************************************************************************/void equaldmatrix(double **mat1, double **mat2, int R, int C){int	a, b;for (a=0; a<R; ++a)	for (b=0; b<C; ++b)	mat1[a][b]=mat2[a][b];//return mat1;}/* equallngmatrix: sets mat1 equal to mat2;/****************************************************************************************/void equallmatrix(long **mat1, long **mat2, int R, int C){int	a, b;for (a=0; a<R; ++a)	for (b=0; b<C; ++b)	mat1[a][b]=mat2[a][b];/*return(0); *//*return mat1;	*/}/* equaldbmatrix: sets mat1 equal to mat2;/****************************************************************************************/void equaldcube(double ***cube1, double ***cube2, int T, int R, int C){int	a, b, c;for (a=0; a<T; ++a)	for (b=0; b<R; ++b)	for (c=0; c<C; ++c)	cube1[a][b][c]=cube2[a][b][c];//return mat1;}/* clearivector - sets all elements of a vector of integers to k/* Requires:/*	i - the array/*	n - elements of the array/*	k - new value for those elements/* Returns:/*	i - now all set to k/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void clearivector(int *i, int n, int k){int j;for (j=0; j<n; ++j)	i[j]=k;/*return(0); *//*return i;	*/}/* clearlvector - sets all elements of a vector of long to k/* Requires:/*	i - the array/*	n - elements of the array/*	k - new value for those elements/* Returns:/*	i - now all set to k/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void clearlvector(long *i, int n, long k){int j;for (j=0; j<n; ++j)	i[j]=k;/*return(0); */}/* clearulvector - sets all n elements of unsigned long vector i to k/* Requires:/*	i - the array/*	n - elements of the array/*	k - new value for those elements/* Returns:/*	i - now all set to k/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void clearulvector(unsigned long *i, int n, long k){int j;for (j=0; j<n; ++j)	i[j]=k;/*return(0); */}/* cleardvector - sets all elements of a vector of double to k/* Requires:/*	i - the array/*	n - elements of the array/*	k - new value for those elements/* Returns:/*	i - now all set to k/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void cleardvector(double *i, int n, double k){int j;for (j=0; j<n; ++j)	i[j]=k;/*return(0); */}/* clearimatrix - sets all elements of a matrix of integers to k/* Requires:/*	i - the array/*	m - number of rows/*	n - number of columns/*	k - new value for those elements/* Returns:/*	i - now all set to k/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void clearimatrix(int **i, int m, int n, int k){int	a,b;for (a=0; a<m; ++a)	for (b=0; b<n; ++b)	i[a][b]=k;/*return(0); */}/* clearlmatrix - sets all elements of a matrix of long to k/* Requires:/*	i - the array/*	m - number of rows/*	n - number of columns/*	k - new value for those elements/* Returns:/*	l - now all set to k/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void clearlmatrix(long **l, int m, int n, int k){int	a,b;for (a=0; a<m; ++a)	for (b=0; b<n; ++b)	l[a][b]=k;/*return(0); */}/* clearulmatrix - sets all elements of a matrix of unsigned long to k/* Requires:/*	i - the array/*	m - number of rows/*	n - number of columns/*	k - new value for those elements/* Returns:/*	ul - now all set to k/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void clearulmatrix(unsigned long **ul, int m, int n, int k){int	a,b;for (a=0; a<m; ++a)	for (b=0; b<n; ++b)	ul[a][b]=k;/*return(0); */}/* cleardmatrix - sets all elements of a matrix of integers to k/* Requires:/*	i - the array/*	m - number of rows/*	n - number of columns/*	k - new value for those elements/* Returns:/*	i - now all set to k/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void cleardmatrix(double **i, int m, int n, double k){int	a,b;for (a=0; a<m; ++a)	for (b=0; b<n; ++b)	i[a][b]=k;/*return(0); */}/* cleardcube - sets all elements of a 3-d matrix of integers to k/* Requires:/*	i - the array/*	x - number of rows/*	y - number of columns/*	z - number of columns/*	k - new value for those elements/* Returns:/*	i - now all set to k/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */void cleardcube(double ***d, int m, int n, int p, int k){int	a,b,c;for (a=0; a<m; ++a)	for (b=0; b<n; ++b)	for (c=0; c<p; ++c)	d[m][n][p]=k;/*return(0); */}/* transposelong - tranposes an RXC matrix of long to a CXR matrix of long/* Requires:/*		mat - matrix of long;/*		R - number of rows;/*		C - number of columns;/* Returns:/*		T - mat turned on its side;***************************************************************************************/long **transposelong(long **mat, int R, int C){int		i, j;long	**T;T=lmatrix(C,R);for (i=0; i<R; ++i)	for (j=0; j<C; ++j)		T[j][i]=mat[i][j];return T;}/* transposeint - tranposes an RXC matrix of long to a CXR matrix of int/* Requires:/*		mat - matrix of int;/*		R - number of rows;/*		C - number of columns;/* Returns:/*		T - mat turned on its side;***************************************************************************************/int **transposeint(int **mat, int R, int C){int	i, j;int	**T;T=imatrix(C,R);for (i=0; i<R; ++i)	for (j=0; j<C; ++j)		T[j][i]=mat[i][j];return T;}/* transposefloat - tranposes an RXC matrix of long to a CXR matrix of float/* Requires:/*		mat - matrix of float;/*		R - number of rows;/*		C - number of columns;/* Returns:/*		T - mat turned on its side;***************************************************************************************/float **transposefloat(float **mat, int R, int C){int		i, j;float	**T;T=fmatrix(C,R);for (i=0; i<R; ++i)	for (j=0; j<C; ++j)		T[j][i]=mat[i][j];return T;}/* transposedbl - tranposes an RXC matrix of long to a CXR matrix of double/* Requires:/*		mat - matrix of double;/*		R - number of rows;/*		C - number of columns;/* Returns:/*		T - mat turned on its side;***************************************************************************************/double **transposedbl(double **mat, int R, int C){int		i, j;double	**T;T=dmatrix(C,R);for (i=0; i<R; ++i)	for (j=0; j<C; ++j)		T[j][i]=mat[i][j];return T;}/* transposechar - tranposes an RXC matrix of long to a CXR matrix of char/* Requires:/*		mat - matrix of char;/*		R - number of rows;/*		C - number of columns;/* Returns:/*		T - mat turned on its side;***************************************************************************************/char **transposechar(char **mat, int R, int C){int		i, j;char	**T;T=cmatrix(C,R);for (i=0; i<R; ++i)	for (j=0; j<C; ++j)		T[j][i]=mat[i][j];return T;}/* transposeunlng - tranposes an RXC matrix of long to a CXR matrix of unsigned long/* Requires:/*		mat - matrix of unsigned long;/*		R - number of rows;/*		C - number of columns;/* Returns:/*		T - mat turned on its side;***************************************************************************************/unsigned long **transposeunlng(unsigned long **mat, int R, int C){int				i, j;unsigned long	**T;T=ulmatrix(C,R);for (i=0; i<R; ++i)	for (j=0; j<C; ++j)		T[j][i]=mat[i][j];return T;}/* rescaleclmatrixmin - rescales a cladistic matrix so that the minimum column value is M/* Requires:/*		mat - taxon X character matrix of states (long);/*		notu - number of taxa;/*		nchars - number of characters;/*		UNKNOWN - code for unknown states/*		INAP - code for inapplicable characters/*		M - the minimum value to be present in each column ;/* Returns:/*		mat - rescaled matrix;***************************************************************************************/long **rescaleclmatrixmin(long **mat, int notu, int nchars, int UNKNOWN, int INAP, int M){int	c, r, min;for (c=0; c<nchars; ++c)	{	min=RAND_MAX;	for (r=0; r<notu; ++r)		if (mat[r][c]<min && (mat[r][c]!=UNKNOWN && mat[r][c]!=INAP))	min=mat[r][c];	if (min>M)		for (r=0; r<notu; ++r)			if (mat[r][c]!=UNKNOWN && mat[r][c]!=INAP)				mat[r][c]=mat[r][c]-min;	}return mat;}/* scrambleiarray - randomly reorders integer array i of n elements.  /* Requires:/*		i - integer array;/*		n - elements of array;/* Returns:/*		i - scrambled array;***************************************************************************************/int *scrambleiarray(int *i, int n){int	r, s, t;for (r=0; r<n; ++r)	{	s = (((unsigned int) rand())%n);	t=i[r];	i[r]=i[s];	i[s]=t;	}return i;}/* scrambledarray - randomly reorders double array i of n elements.  /* Requires:/*		d - integer array;/*		n - elements of array;/* Returns:/*		d - scrambled array;***************************************************************************************/double *scrambledarray(double *d, int n){int	r, s;double	t;for (r=0; r<n; ++r)	{	s = (((unsigned int) rand())%n);	t=d[r];	d[r]=d[s];	d[s]=t;	}return d;}/* scramblelarray - randomly reorders long array i of n elements.  /* Requires:/*		i - integer array;/*		n - elements of array;/* Returns:/*		i - scrambled array;***************************************************************************************/long *scramblelarray(long *i, int n){int	r, s, t;for (r=0; r<n; ++r)	{	s = (((unsigned int) rand())%n);	t=i[r];	i[r]=i[s];	i[s]=t;	}return i;}/* scrambleiarray - randomly reorders integer array i of n elements.  /* Requires:/*		i - integer array;/*		n - elements of array;/* Returns:/*		i - scrambled array;***************************************************************************************/void scrambleiarraycommand(int *i, int n){int	r, s, t;for (r=0; r<n; ++r)	{	s = (((unsigned int) rand())%n);	t=i[r];	i[r]=i[s];	i[s]=t;	}}/* scrambleiarray - randomly reorders integer array i of n elements.  /* Requires:/*		i - integer array;/*		n - elements of array;/* Returns:/*		i - scrambled array;***************************************************************************************/unsigned long *scrambleularray(unsigned long *i, int n){int	r, s, t;for (r=0; r<n; ++r)	{	s = (((unsigned int) rand())%n);	t=i[r];	i[r]=i[s];	i[s]=t;	}return i;}/* scrambleiarray - randomly reorders integer array i of n elements.  /* Requires:/*		i - integer array;/*		n - elements of array;/* Returns:/*		i - scrambled array;***************************************************************************************/void scrambleularraycommand(unsigned long *i, int n){int	r, s, t;for (r=0; r<n; ++r)	{	s = (((unsigned int) rand())%n);	t=i[r];	i[r]=i[s];	i[s]=t;	}}/* scrambledarraycommand - randomly reorders integer array i of n elements.  /* Requires:/*		i - double array;/*		n - elements of array;***************************************************************************************/void scrambledarraycommand(double *i, int n){int	r, s;double	t;for (r=0; r<n; ++r)	{	s = (((unsigned int) rand())%n);	t=i[r];	i[r]=i[s];	i[s]=t;	}}/* removefromivector - removes integer j from vector i of length k, reducing k along the way/* Requires:/*		i - integer array;/*		j - the value to be removed;/*		k - the length of i;/* Returns:/*		i - reduced array;***************************************************************************************/void removefromivectorold(int *i, int j, int *k){int	a, b;for (a=0; a<*k; ++a)	{	if (i[a]==j)	{		for (b=a; b<*k-1; ++b)	i[b]=i[b+1];		--*k;		--a;		/* back up - you might just have put another j into i[a] */		}	}/*return(0); */}void removefromivector(int *i, int j, int *k){int	a, b;int	len=*k;//int pos;a=len-1;while (a>=0)	{	if (i[a]==j)	{		for(b=a; b<(len-1); ++b)	{			i[b]=i[b+1];			}		--len;		if (a==len)	--a;			}	else	--a;	}*k=len;}/* removefromulvector - removes integer j from vector i of length k, reducing k along the way/* Requires:/*		i - integer array;/*		j - the value to be removed;/*		k - the length of i;/* Returns:/*		i - reduced array;***************************************************************************************/void removefromulvector(unsigned long *i, unsigned long j, int *k){int	a, b;for (a=0; a<*k; ++a)	{	if (i[a]==j)	{		for (b=a; b<*k-1; ++b)	i[b]=i[b+1];		--*k;		--a;		/* back up - you might just have put another j into i[a] */		}	}/*return(0); */}/* cleancladisticmatrix - "cleans" cladistic matrix by setting minimum state to 0 and eliminating gaps (e.g., if only 0 and 2 coded, then code changed to 0 and 1	/* Requires:/*		matrix - long array representing cladistic matrix;/*		notu - number of taxa (i.e., rows of matrix);/*		nchars - number of characters (i.e., columns of matrix);/*		UNKNOWN - numerical representation of unknown state;/*		INAP - numerical representation of inapplicable state;***************************************************************************************/void cleancladisticmatrix(long **matrix, int notu, int nchars, int UNKNOWN, int INAP){int	a,b,c,d; int	st, sp, ch, mn, mx;int obs[100];for (ch=0; ch<nchars; ++ch)	{	mn=RAND_MAX;	mx=-1*RAND_MAX;		for (sp=0; sp<notu; ++sp)	{		if (matrix[sp][ch]>=0 && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			if (mn>matrix[sp][ch])	mn=matrix[sp][ch];			if (mx<matrix[sp][ch])	mx=matrix[sp][ch];			}		}	/* set minimum state to zero for each character	*/	if (mn>0)	{		for (sp=0; sp<notu; ++sp)	{			if ((st=matrix[sp][ch])!=UNKNOWN && matrix[sp][ch]!=INAP)	{				if (matrix[sp][ch]>0)	matrix[sp][ch]-=mn;				else	{					d=c=0;					for (b=(-1*st)/10; b>=0; b=b)	{						a=(-1*st)%10;						a-=mn;						a*=pow(10,c);						d=d+a;						++c;						if (b==0)	break;						b/=10;						st/=10;						}					matrix[sp][ch]=-1*d;					}				}			}		mx-=mn;	/* maximum state must change, too	*/		}		/* find the number of species coded for each state	*/	for (st=0; st<=mx; ++st)	obs[st]=0;	for (sp=0; sp<notu; ++sp)	{		if (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP)	{			if ((st=matrix[sp][ch])>=0) ++obs[st];			else	{				b=(-1*st)/10;				c=0;				while (b>0)	{					a=(-1*st)%10;					++obs[a];					b=(-1*st)/10;					st/=10;					}				}			}		}		for (st=mx-1; st>0; --st)	{		/* if no species have state X, then recode all X+Y to X+Y-1	and eliminate coding gaps	*/		if (obs[st]==0)	{			for (sp=0; sp<notu; ++sp)	{				if (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP)	{					if (matrix[sp][ch]>st) 	--matrix[sp][ch];					/* polymorphic character found	*/					else if (matrix[sp][ch]<0)	{						b=(-1*matrix[sp][ch])/10;						d=c=0;						while (b>0)	{							a=(-1*matrix[sp][ch])%10;							if (a>st)	--a;							d=d+pow(10,c)*a;							++c;							b=(-1*matrix[sp][ch])/10;							}						}	/* end case of polymorphic character	*/					}	/* end search of species for states needing recoding	*/				}	/* end filling of observed gap in coding	*/			--mx;			}		}	/* note that we do not need to examine 0 or mx because we have seen those	*/	}/*return(0); */}/* vectorequallongmatrixcol - set a vector equal to a column within a matrix (e.g., a character column within a cladistic matrix)/* Requires:/*		matrix - long array representing cladistic matrix;/*		vector - the vector, of length rows;/*		ccol - the column to be copied;/*		rows - the number of rows;***************************************************************************************/void vectorequallongmatrixcol(long **matrix, long *vector, int ccol, int rows){int	a; for (a=0; a<rows; ++a)	vector[a]=matrix[ccol][a];/*return(0); */}/* rescaldedvector: rescales all n elements in array v by k times the original	*/void rescaledvector(double *v, int n, double k){int i;for (i=0; i<n; ++i)	v[i]*=k;/*return(0); */}void proportionaldvector(double *orig, double *scaled, double rescale, int n){int i;for (i=0; i<n; ++i)	scaled[i]=orig[i]*rescale;/*return(0); */}/* routine to reduce cladistic matrix to unique strings of character states	*/long **reducecladisticmatrix(long **origmatrix, int notu, int nchar){int	c1, c2, s;int match=0, count;int *novel;long **finalmatrix;novel=ivector(nchar);	/* number of characters matching this one (0 if duplicate of earlier character(	*/count=nchar;			/* number of uniquely coded characters	*//* redone 2014-09-15	for (c1=(nchar-1); c1>0; --c1)	{	for (c2=(c1-1); c2>=0; --c2)	{		sim=0;		for (s=0; s<notu && sim==0; ++s)	if		}	}	*/novel[0]=1;for (c1=(nchar-1); c1>0; --c1)	{	++novel[c1];	for (c2=(c1-1); c2>=0; --c2)	{		match=1;	/* fixed 2014-09-15	*/		for (s=0; s<notu && match==1; ++s)	{			if (origmatrix[s][c1]!=origmatrix[s][c2])	match=0;			}	/* compare all species unti a mismatch is found	*/		if (match==1)	{			novel[c2]+=novel[c1];	/* this will find total matching characters	*/			--count;		/* reduce novel character count	*/			c2=novel[c1]=0;			}	/* designate character as matching another with a 0	*/		}	/* end search of other characters	*/	}	finalmatrix=lmatrix(notu,count);c2=0;for (c1=0; c1<nchar; ++c1)	{	if (novel[c1]>0)	{		for (s=0; s<notu; ++s)	finalmatrix[s][c2]=origmatrix[s][c1];		++c2;		}	}free_ivector(novel);return finalmatrix;}/* routine to reduce cladistic matrix to unique strings of character states	*/long **eliminateuniformativefromcladisticmatrix(long **origmatrix, int *autaps, int *nstates, int notu, int nchar){int	c1, c2, s;int match=0, count;int *novel;long **finalmatrix;novel=ivector(nchar);	/* number of characters matching this one (0 if duplicate of earlier character(	*/count=nchar;			/* number of uniquely coded characters	*/novel[0]=1;for (c1=(nchar-1); c1>0; --c1)	{	++novel[c1];	for (c2=(c1-1); c2>=0; --c2)	{		match=1;	/* fixed 2014-09-15	*/		for (s=0; s<notu && match==1; ++s)	{			if (origmatrix[s][c1]!=origmatrix[s][c2])	match=0;			}	/* compare all species unti a mismatch is found	*/		if (match==1)	{			novel[c2]+=novel[c1];	/* this will find total matching characters	*/			--count;		/* reduce novel character count	*/			c2=novel[c1]=0;			}	/* designate character as matching another with a 0	*/		}	/* end search of other characters	*/	}	finalmatrix=lmatrix(notu,count);c2=0;for (c1=0; c1<nchar; ++c1)	{	if (novel[c1]>0)	{		for (s=0; s<notu; ++s)	finalmatrix[s][c2]=origmatrix[s][c1];		++c2;		}	}free_ivector(novel);return finalmatrix;}