long *evolvecharacterNstepsovertime(long **tree, int N, int notu, long *chvector, int nstates, int ctype, int bias, int UNKNOWN, int INAP){int		a, b, c, d, st, sc, ttlbr;int		flip, sp, sp2, nodes, branches;int		*available, *unord, *undum, *trpd, *change;/* find the number of nodes and their diversities */nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}for (a=0; a<notu; ++a)	if (chvector[a]!=UNKNOWN && chvector[a]!=INAP)	chvector[a]=0;/* allocate memory for branch lengths */trpd=ivector(nodes+notu);/* allocate memory for arrays to be used for unordered multistates */if (nstates>2 && ctype==1)	{	unord=ivector(nstates);	undum=ivector(nstates);	}trpd[notu]=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[notu-1][sp];		/* array tree[notu-1] gives branch lengths of species */	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[notu][sp];	/* array tree[notu] gives branch lengths of ancestors */	}/* allocate memory for arrays containing branches needing changes */ttlbr=branchnumber(tree,notu);available=ivector(ttlbr);/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */b=0;for (a=1; a<nodes; ++a)	{	for (c=0; c<trpd[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		available[b]=a;		++b;		}	}/* allocate memory for branches that do change */change=ivector(N);b=branches=0;for (a=0; a<N; ++a)	{	c=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-b));	sp=available[c];	if (sp>notu)	{		/* make sure that some members of the clade are scored, rather than all missing / inap	*/		d=0;		for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{			sp2=tree[sp-notu][sc];			if (chvector[sp2]!=UNKNOWN && chvector[sp2]!=INAP)	{				++d;				sc=tree[sp-notu][0];				}			/* if there are any species scored as having the character, then use this clade	*/			if (d>0)	{				change[branches]=sp;				b=b+trpd[change[branches]];				++branches;				}			else	--a;			}		}	else if (sp<notu)	{		if (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP)	{			change[branches]=sp;			b=b+trpd[change[branches]];			++branches;			}		else	--a;		}/*	removefromivector(available,sp,&ttlbr);	*/		for (sc=c; sc<ttlbr-1; ++sc)	{		available[sc]=available[sc+1];		}	--ttlbr;	available[ttlbr]=0;	}/* now, make changes */for (d=0; d<N; ++d)	{	sp=change[d];	/* routine for binary characters */	if (nstates==2)	{		/* routine for species */		if (sp<notu && (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP))	{			chvector[sp]=swap(chvector[sp]);			}	/* end binary change for species */		/* routine for clade */		else	{			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (chvector[sp2]!=UNKNOWN && chvector[sp2]!=INAP))	{					chvector[sp2]=swap(chvector[sp2]);					}				}	/* end binary change for species within clade */			}	/* end binary change for clade */		}	/* end routine for binary characters */			/** routine for unordered multistate **/	else if (ctype==1)	{		/* routine for species */		if (sp<notu && (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP))	{			for (b=chvector[sp]; b==chvector[sp]; b=b)				b=(int)((double)rand() / ((double)RAND_MAX + 1) * nstates);			chvector[sp]=b;			}	/* end unordered multistate change for species */		/* routine for clade */		else	{			/* first create an array stating which states change to which 	*/			for (a=0; a<nstates; ++a)	undum[a]=a;			/* now come up with new transitions for this clade 				*/			for (a=0; a<nstates; ++a)	{				b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates-a));				unord[a]=undum[b];				/* do not let unord[a]==a */				while (unord[a]==a || a>=nstates)	{					b=(int)((double)rand() / ((double)RAND_MAX + 1) * (nstates-a));					unord[a]=undum[b];					}				/* unord[0] cannot be a (otherwise we wouldn't have this problem */				/* therefore, flip-flop unord[0] and unord[a] */				if (unord[a]==a && a==(nstates-1))	{					unord[a]=unord[0];					unord[0]=a;					}									/* remove assigned state from possibilities */				for (c=b; c<nstates; ++c)					undum[c]=undum[c+1];				/* reboot if the final possible state matches original */				if (a==(nstates-2) && (a+1)==undum[0])	{					a=-1;	/* will increment to 0*/					for (b=0; b<nstates; ++b)	undum[b]=b;					}				}	/* end assignment of state changes */						/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (chvector[sp2]!=UNKNOWN && chvector[sp2]!=INAP))					chvector[sp2]=unord[chvector[sp2]];				}	/* end unordered multistate change for species within clade */			}	/* end unordered multistate change within clade */		}	/* end routine for unordered multistate characters */			/** routine for ordered multistate **/	else if (ctype==0)	{		/* determine whether state increases or decreases */		for (flip=-1; flip<0 || flip>99; flip=flip)	{			flip=(int)((double)rand() / ((double)RAND_MAX + 1) * 100);			}		if (flip<bias)	flip=1;		else				flip=-1;		/* routine for species */		if (sp<notu && (chvector[sp]!=UNKNOWN && chvector[sp]!=INAP))	{			chvector[sp]=chvector[sp]+flip;			}	/* end ordered multistate change for species */		/* routine for clade */		else	{			/* now make changes */			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (sp2<notu && (chvector[sp2]!=UNKNOWN && chvector[sp2]!=INAP))					chvector[sp2]=chvector[sp2]+flip;				}	/* end ordered multistate change for species within clade */			}	/* end ordered multistate change within clade */				/* Now, make sure that the lowest value is 0, not -1 or 1 */		st=nstates;		for (a=0; a<notu; ++a) {			if (chvector[a]<st)	st=chvector[a];			}		if (st!=0)	{			for (a=0; a<notu; ++a) {				chvector[a]=chvector[a]-st;				}			}		}	/* end routine for ordered multistate characters */	}free_ivector(trpd);free_ivector(available);free_ivector(change);if (nstates>2 && ctype==1)	{	free_ivector(unord);	free_ivector(undum);	}return chvector;}