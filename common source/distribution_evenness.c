/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//*/*	Peter J. Wagner: pwagner@fmnh.org/*	Matthew Kosnik: mkosnik@uchicago.edu/*/*	This file is copyright (C) 2001 Peter J. Wagner & Matthew Kosnik/*/*	This program is free software; you can redistribute it and/or modify it /*	under the terms of version 2 the GNU General Public License as published /*	by the Free Software Foundation./*/*	This program is distributed in the hope that it will be useful, but WITHOUT/*	ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or /*	FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for /*	more details./*/*	To view a copy of the license go to:/*	http://www.fsf.org/copyleft/gpl.html/*	To receive a copy of the GNU General Public License write the Free Software/* 	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA./*/*	Copies of this source code are available without cost from:/*	http://geosci.uchicago.edu/paleo/csource//*	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */#define evenness_functions#include "distribution_evenness.h"#include "minmax.h"/*CALCULATES WAGNER-KOSNIK EVENNESS METRICNEEDS:	- abundance (array with proportional abundance)	- S (number of taxa)RETURNS:	- square root of the sum log10 deviation from uniform distribution***********************************************************************/double calc_kw_evenness(double *abundance, int S)	{double answer=0.0f;				/* will contain answer */double even = 1/(S*1.0);		/* contains the perfectly even proportion */double y=0.0f;					/* temp variable */int b=0;						/* loop counter */for (b=0 ; b<S ; ++b) {	y+=(log10(abundance[b]) - log10(even))*(log10(abundance[b]) - log10(even));	}y*=even;answer=pow(y,0.5);return answer;}/*CALCULATES BUZAS AND GIBSONS EVENNESS METRIC, E = e^H / SNEEDS:	- abundance (array with proportional abundance)	- S (number of taxa)RETURNS:	- E, EVEN RAISED TO THE NEGATIVE SUM OF PROPORTIONAL ABUNDANCE*LOG PROPORTIONAL ABUNDANCE***********************************************************************/double calc_bg_evenness(double *abundance, int S)	{double E=0.0f;						/* will contain E */double even = 1/(S*1.0);			/* contains the perfectly even proportion */double H=0.0f;						/* Shannon's Information Function */int b=0;							/* loop counter */for (b=0 ; b<S ; ++b) {	H+=abundance[b]*log(abundance[b]);	}E=even*exp(-H);return E;}/*CALCULATES PIE (prob. of interspecific encounter) (HURLBERT 1971 ECOLOGY: eq. 4).NEEDS:	- abundance (array with proportional abundance)	- S (number of taxa)RETURNS:	- PROBABILITY OF SAMPLING TWO DIFFERENT SPECIES WITH TWO SAMPLES***********************************************************************/double calc_pie_evenness(double *abundance, int S)	{double PIE=0.0f;					/* the answer, Hurlbert's evenness metric */double y=0.0f;						/* temp variable */int b=0;							/* loop counter */for (b=0 ; b<S ; ++b) {	y+=abundance[b]*abundance[b];	}PIE=1-y;return PIE;}/*CALCULATES KOLMOGOROV-SMIRNOVÕS DÕ (= 1-D) AS USED BY POWELL & KOWALEWSKI 2001 GEOLOGYNEEDS:	- abundance (array with proportional abundance)	- S (number of taxa)RETURNS:	- COMPLIMENT OF KOLMOGOROV-SMIRNOVÕS D***********************************************************************/double calc_ksd_evenness(double *abundance, int S)	{double D=0.0f;						/* will contain answer */double even = 1/(S*1.0);			/* contains the perfectly even proportion */double co=0.0f, ce=0.0f;			/* cumulative variable */int b=0;							/* loop counter */for (b=0 ; b<S ; ++b) {	co+=abundance[b];	ce+=even;	if ((co-ce)>D)	D=co-ce;	}D=1-D;return D;}/*CALCULATES PIELOU'S J (= H/ln(S)) AS USED BY PIELOU 1966NEEDS:	- abundance (array with proportional abundance)	- S (number of taxa)RETURNS:	- J, a number between 0 and 1***********************************************************************/double calc_pj_evenness(double *abundance, int S)	{double J=0.0f;						/* will contain J */double H=0.0f;						/* temp variable */int b=0;							/* loop counter */for (b=0 ; b<S ; ++b) {	H+=abundance[b]*log(abundance[b]);	}J=-1*H/log(S);return J;}/*CALCULATES Franklin'a Ess AS USED BY PETERS 2001NEEDS:	- abundance (array with proportional abundance)	- S (number of taxa)RETURNS:	- Franklin's evenness metric***********************************************************************/double calc_sp_evenness(double *abundance, int S)	{double	franklin=0.0f;				/* the answer */double even = 1/(S*1.0);			/* contains the perfectly even proportion */int a=0;							/* loop counter */for (a=0; a<S ; ++a)	franklin+=(abundance[a]-even)* (abundance[a]-even);franklin=S*franklin/((S-1)*1.0);franklin=1-franklin;return franklin;}/*CALCULATES Smith & WilsonÕs Evar (Smith & Wilson 1996)NEEDS:	- abundance (array with proportional abundance)	- S (number of taxa)RETURNS:	- evr***********************************************************************/double calc_evr_evenness(double *abundance, int S)	{double	evr=0.0f;				/* the answer */double	ave=0.0f, sumsq=0.0f;int a;							/* loop counter */for (a=0; a<S; ++a)	ave+=log(abundance[a])/((double) S);for (a=0; a<S; ++a)	sumsq+=(((log(abundance[a])-ave) * (log(abundance[a])-ave))/((double) S));evr=atan(sumsq);evr*=(2/PI);evr=1-evr;return evr;}/*CALCULATES KrebÕs E1/D (Krebs 1989)NEEDS:	- abundance (array with proportional abundance)	- S (number of taxa)RETURNS:	- ev***********************************************************************/double calc_eod_evenness(double *abundance, int S){int	a;double D=0.0f, ev;for (a=0; a<S; ++a)	D+=(abundance[a]*abundance[a]); ev=1/(D*((double) S));return ev;}/*CALCULATES CamagroÕs EÕ (Camargo 1993)NEEDS:	- abundance (array with proportional abundance)	- S (number of taxa)RETURNS:	- ev***********************************************************************/double calc_epr_evenness(double *abundance, int S){int	a, b;double ev=0.0f;for (a=0; a<S-1; ++a)	for (b=a+1; b<S; ++b)	ev+=fabs(abundance[a]-abundance[b]); ev/=((double) S);return (1-ev);}/*CALCULATES Gini coefficient (Camargo 1993)NEEDS:	- abundance (array with proportional abundance)	- S (number of taxa)RETURNS:	- dom***********************************************************************/double calc_gini_dominance(double *abundance, int S){int	a;double *Lorenz;double x,y,dom=0.0f;//=1-((COUNT(Q$2:Q$101)+1)/COUNT(Q$2:Q$101)-(2*SUM(Q2:Q101)/(COUNT(Q2:Q101)*Q101)))Lorenz=dvector(S);x=Lorenz[0]=abundance[0];y=sumdvector(abundance,S);for (a=1; a<S; ++a)	{	Lorenz[a]=Lorenz[a-1]+abundance[a];	x+=Lorenz[a];	}if ((2*x)>((S+1)*y))	x=(((S+1)*y)-x);//dom=1-((((double) (S+1))/((double) S))-((2*x)/(S*Lorenz[S-1])));dom=((((double) (S+1))/((double) S))-((2*x)/(S*y)));free_dvector(Lorenz);return dom;}/*CALCULATES Simpson's dominance coefficient (Simpson 1949)NEEDS:	- abundance (array with proportional abundance)	- S (number of taxa)RETURNS:	- dom***********************************************************************/double calc_simp_dominance(double *abundance, int S){int	a;double y,dom=0.0f;//=1-((COUNT(Q$2:Q$101)+1)/COUNT(Q$2:Q$101)-(2*SUM(Q2:Q101)/(COUNT(Q2:Q101)*Q101)))y=sumdvector(abundance,S);for (a=0; a<S; ++a)	dom+=((abundance[a]*(abundance[a]-1))/(y*(y-1)));return dom;}