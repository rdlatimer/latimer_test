#define Functions#include "MovingFunctions.h"double* Linear(int **data, int branches)	{	int		a, i, j, start;	int		*deltas,*ttlst;	double	B, M, S;	double	BestS=-10000000, BestRate;	double	*bestline;	deltas =(int *)malloc(branches*sizeof(int));	ttlst =(int *)malloc(branches*sizeof(int));	bestline =(double *)malloc(2*sizeof(double));	for (a=0; a<branches; ++a)	{		deltas[a]=data[a][1];		ttlst[a]=data[a][3];		if (deltas[a]==ttlst[a])	start=a;		}		B = .001;	M = .001;	/* linear */	BestS = -100000;	for (j=1; j<=1000; ++j)	{		B = j;		B = B/1000;		S = 0;		for (i=start; i<branches; ++i)	{			M = deltas[i]-deltas[i-1];			S = S+LnPoisson((ttlst[i]-ttlst[i-1]),B,M);			}		if (S>BestS || j==1)	{			bestline[0]=BestRate=B;			bestline[1]=BestS=S;			}		else	j=1000;				}	free ((void *)deltas);	free ((void *)ttlst);	return bestline;}double* Finite(int **data, int BR)	{	int		a, i, j, BestTotal, start;	int		*deltas,*ttlst;	double	B, M, S, y;	double	BestS=-10000000;	double	*bestrare;	deltas =(int *)malloc(BR*sizeof(int));	ttlst =(int *)malloc(BR*sizeof(int));	bestrare =(double *)malloc(2*sizeof(double));	for (a=0; a<BR; ++a)	{		deltas[a]=data[a][1];		ttlst[a]=data[a][3];		if (deltas[a]==ttlst[a])	start=a;		}		/* the first loop gives a range of states to examine */	for (j=ttlst[BR-1]; j<10*deltas[BR-1]; ++j)	{		y = j;		S=0;		for (i=start; i<BR; ++i)	{			M = deltas[i]-deltas[i-1];			B = y*(1-pow(1-(1/y),deltas[i])) - y*(1-pow(1-(1/y),deltas[i-1]));					B = B/M;			S = S+LnPoisson((ttlst[i]-ttlst[i-1]),B,M);			}		if (S>BestS || j==ttlst[BR-1]-5)	{			bestrare[0]=BestTotal = j;			bestrare[1]=BestS=S;			}		else	j = 10*deltas[BR-1];		}	free ((void *)deltas);	free ((void *)ttlst);	return bestrare;}double* PowerF(int **data, int BR)	{	int		a, d, i, k, start, coef, exp, inexp, real;	int		*deltas,*ttlst;	double	E, B, M, X, S, y, C, BestS, BestX, *bestpowr;	deltas=(int *)malloc(BR*sizeof(int));	ttlst=(int *)malloc(BR*sizeof(int));	bestpowr=(double *)malloc(3*sizeof(double));	for (a=0; a<BR; ++a)	{		deltas[a]=data[a][1];		ttlst[a]=data[a][3];		if (deltas[a]==ttlst[a])	start=a;		}		d=0;	bestpowr[2]=-10000000;	/* the first loop gives a range of states to examine */	for (coef=1001; coef<3000+d; coef=coef+2)	{		C=coef;		C=0.001*C;		E=ttlst[BR-1];		E=100*E;				inexp=999;		while (E>ttlst[BR-1]+25)	{			X = inexp;			X = 0.001*X;			E = C*pow(deltas[BR-1],X);			--inexp;			}				BestS=-100000000;		for (exp=inexp; exp>0; --exp)	{			X = exp;			X = 0.001*X;			/* find where Æ is less than 1.0 */			real=0;			y=2;			while (y>=1)	{				y=(C*pow(real+1,X))-(C*pow(real,X));				++real;				}			--real;			S=0;						for (i=0; i<BR-start-1; ++i)	{				k=i+start;				M = deltas[k+1]-deltas[k];				B = (C*pow(real+deltas[k+1],X)) - (C*pow(real+deltas[k],X));				B = B/M;				S = S+LnPoisson((ttlst[k+1]-ttlst[k]),B,M);				}							if (S>BestS)	{				BestX=X;				BestS=S;				}			else	exp=0;			}		if (BestS>bestpowr[2])	{			bestpowr[0]=C;			bestpowr[1]=BestX;			bestpowr[2]=BestS;			if (coef>=3000+d)	++d;			}		}	free ((void *)deltas);	free ((void *)ttlst);	return bestpowr;	}double LnPoisson(int obs, double rate, double N){double	result, lambda, x, y;x = obs;lambda = rate*N;if (lambda==0)	lambda = rate;if (obs>0)	y = factorial(obs);else		y = 0;result = (x*log(lambda)-y)-lambda;return result;}double	factorial (int number){int	i;double	result;result=0;for (i=2; i<=number; ++i)	result=result+log(i);return result;}