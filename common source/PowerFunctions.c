#define PowerFunctions#include "PowerFunctions.h"#define Probability#include "Probability.h"#define more_math_functions#include "more_math.h"#define memory#include "memory.h"/* iLinear: finds the best linearly increasing function given first differences and integer data/*/* Requires:/*	data: Exhaustion curve/*		data[0]: # of changes/*		data[1]: # of characters/*		data[2]: # of states/*	branches: number of branches/*/* Returns:/*	bestline: information about best fit line/*		bestline[0]: best linear increase for characters/*		bestline[1]: log-likelihood for best linear increase/*		bestline[2]: best linear increase for states/*		bestline[3]: log-likelihood for best linear increase************************************************************************************/double* iLinear(int **data, int BR){int		a, i, j, start, r;int		*deltas,*ttlst;double	B, M, S;double	bestS=-10000000, BestRate;double	*bestline;deltas=ivector(BR);ttlst=ivector(BR);bestline=dvector(4);/* do two runs: one for characters, one for states */for (r=0; r<=1; ++r)	{	for (a=0; a<BR; ++a)	{		deltas[a]=data[a][1];		ttlst[a]=data[a][2+r];	/* 2 if chars, 3 if states */		if (deltas[a]==ttlst[a])	start=a+1;		}	B = 0.001f;	M = 0.001f;	/* linear */	bestS = -RAND_MAX;	for (j=1; j<=1000; ++j)	{		B = j;		B = B/1000;		S = 0;		for (i=start; i<BR; ++i)	{			M = deltas[i]-deltas[i-1];			S = S+lnPoisson(B,M,(ttlst[i]-ttlst[i-1]));			}		if (S>bestS || j==1)	{			bestline[0+(r*2)]=BestRate=B;	/* 0 for chars, 2 for states */			bestline[1+(r*2)]=bestS=S;		/* 1 for chars, 3 for states */			}		else	j=1000;				}	}free_ivector(deltas);free_ivector(ttlst);return bestline;}/* iLinear: finds the best linearly increasing function given first differences and double data/*/* Requires:/*	data: Exhaustion curve/*		data[0]: # of changes/*		data[1]: # of characters/*		data[2]: # of states/*	branches: number of branches/*/* Returns:/*	bestline: information about best fit line/*		bestline[0]: best linear increase for characters/*		bestline[1]: log-likelihood for best linear increase/*		bestline[2]: best linear increase for states/*		bestline[3]: log-likelihood for best linear increase************************************************************************************/double* dLinear(double **data, int BR){int		a, i, j, start, r;double	*deltas,*ttlst;double	B, M, S;double	bestS=-10000000, BestRate;double	*bestline;deltas=dvector(BR);ttlst=dvector(BR);bestline=dvector(4);/* do two runs: one for characters, one for states */for (r=0; r<=1; ++r)	{	for (a=0; a<BR; ++a)	{		deltas[a]=data[a][1];		ttlst[a]=data[a][2+r];	/* 2 if chars, 3 if states */		if (deltas[a]==ttlst[a])	start=a+1;		}	B = .001;	M = .001;	/* linear */	bestS = -1*RAND_MAX;	for (j=1; j<=1000; ++j)	{		B = j;		B = B/1000;		S = 0;		for (i=start; i<BR; ++i)	{			M = deltas[i]-deltas[i-1];			S = S+lnPoisson((ttlst[i]-ttlst[i-1]),B,M);			}		if (S>bestS || j==1)	{			bestline[0+(r*2)]=BestRate=B;	/* 0 for chars, 2 for states */			bestline[1+(r*2)]=bestS=S;		/* 1 for chars, 3 for states */			}		else	j=1000;				}	}free_dvector(deltas);free_dvector(ttlst);return bestline;}/* iFinite: finds the best finite equiprobable classes function given first differences & integer data/*/* Requires:/*	data: Exhaustion curve/*		data[0]: # of changes/*		data[1]: # of characters/*		data[2]: # of states/*	branches: number of branches/*/* Returns:/*	bestrare: information about best fit line/*		bestrare[0]: best linear increase for characters/*		bestrare[1]: log-likelihood for best linear increase/*		bestrare[2]: best linear increase for states/*		bestrare[3]: log-likelihood for best linear increase************************************************************************************/double* iFinite(int **data, int BR){int		a, i, j, besttotal, start, r;int		*deltas,*ttlst;double	B, M, S, y;double	bestS;double	*bestrare;deltas=ivector(BR);ttlst=ivector(BR);bestrare=dvector(4);for (r=0; r<=1; ++r)	{	for (a=0; a<BR; ++a)	{		deltas[a]=data[a][1];		ttlst[a]=data[a][2+r];	/* 2 if chars, 3 if states */		if (deltas[a]==ttlst[a])	start=a+1;		}	/* the first loop gives a range of states to examine */	bestS=-1*RAND_MAX;	for (j=ttlst[BR-1]; j<10*deltas[BR-1]; ++j)	{		y = j;		S=0;		for (i=start; i<BR; ++i)	{			M = deltas[i]-deltas[i-1];			B = y*(1-pow(1-(1/y),deltas[i])) - y*(1-pow(1-(1/y),deltas[i-1]));					B = B/M;			S = S+lnPoisson((ttlst[i]-ttlst[i-1]),B,M);			}		if (S>bestS || j==ttlst[BR-1]-5)	{			bestrare[0+(r*2)]=besttotal=j;			bestrare[1+(r*2)]=bestS=S;			}		else	j = 10*deltas[BR-1];		}	}free_ivector(deltas);free_ivector(ttlst);return bestrare;}/* i_finite: finds the best finite equiprobable classes function given first differences & integer data/*/* Requires:/*	data: Exhaustion curve/*		data[0]: # of changes/*		data[1]: # of characters realized/*		data[2]: # of states realized/*	branches: number of branches/*/* Returns:/*	bestrare: information about best fit line/*		bestrare[0]: most likely number of finite characters/*		bestrare[1]: log-likelihood for ml character number/*		bestrare[2]: most likely number of finite states/*		bestrare[3]: log-likelihood for ml state number************************************************************************************/double* i_finite(int **data, int BR){int		a, b, c;int		ic, lc[2], min;int		besttotal, start, r;int		*deltas,*ttlst;int		d, k, m, u, t;		/* variables for numbers of new and used states */double	S;double	x, y;double	bestS;double	*bestrare;deltas=ivector(BR);ttlst=ivector(BR);bestrare=dvector(4);for (r=0; r<=1; ++r)	{	for (a=0; a<BR; ++a)	{		deltas[a]=data[a][1];		ttlst[a]=data[a][2+r];	/* 2 if chars, 3 if states */		if (deltas[a]==ttlst[a])	start=a+1;		}	/* the first loop gives a range of states to examine */	bestS=-1*RAND_MAX;	min=lc[0]=lc[1]=ic=ttlst[BR-1];	for (c=min; abs(ic)>0; c+=ic)	{		S=0.0f;								/* clear support to zero						*/		for (b=start; b<BR; ++b)	{			m = deltas[b]-deltas[b-1];		/* number of changes 							*/			k = ttlst[b]-ttlst[b-1];		/* number of new states realized				*/			d=m-k;							/* number of retreads 							*/			u = c-ttlst[b-1];				/* number of possible new states at this branch	*/			t = ttlst[b-1];					/* number of realized states at this branch		*/			/* sum the probability of drawing the new states given the size of the new state pool	*/			/* 	and the size of the total state pool; remember, this is hypergeometric now.			*/			y=0;			for (a=0; a<k; ++a)	{				x=log(((double) (u-a))/((double) (c-a)));				y+=x;				S+=x;				}			/* sum the probability of drawing the old states given the size of the old state pool	*/			/* 	and the size of the total state pool; remember, this is hypergeometric now.			*/			y=0;			for (a=0; a<d; ++a)	{				x=log(((double) (t-a))/((double) (c-a)));				y+=x;				S+=x;				}			/* take into account the numerous combinations of drawing k new states and (m-k) old ones	*/			S+=log(combin(m,k));/*			S = S+lnPoisson((ttlst[b]-ttlst[b-1]),B,M);	*/			}		if (S>bestS)	{			bestrare[0+(r*2)]=besttotal=c;			bestrare[1+(r*2)]=bestS=S;			if (lc[0]!=min)	{				lc[1]=lc[0];				lc[0]=ic;				if (ic%2==0 || abs(ic)==1)	ic/=2;				else						ic=(ic/abs(ic))*(abs(ic)+1)/2;				}	/* end modification of increment to get to next c without repeating c's */			}	/* end routine when increasing space increases likelihood */		else	{			c-=ic;			lc[1]=lc[0];			lc[0]=ic;			if (lc[0]==abs(lc[1]) || c==min)	{	/* if the last two changes were x and -x, go to x/2	*/				if (ic%2==0 || abs(ic)==1)	ic/=2;				else						ic=(ic/abs(ic))*(abs(ic)+1)/2;				}			else	{				ic*=-1;				if (c+ic<min)	{					lc[1]=lc[0];					lc[0]=ic;					if (ic%2==0 || abs(ic)==1)	ic/=-2;					else			ic=(ic/abs(ic))*(abs(ic)+1)/-2;					}	/* make sure that we do not go to a c < characters or states	*/				}	/* end reversing direction if we decreased the increment last time	*/			}	/* end case where likelihood has decreased	*/		}	/* end search through branches	*/	}	/* end test for characters and states	*/free_ivector(deltas);free_ivector(ttlst);return bestrare;}/* i_finite_ebar: finds the ebar units of support around exhaustion curve given finite characters/states/*/* Requires:/*	data: Exhaustion curve/*		data[0]: # of changes/*		data[1]: # of characters realized/*		data[2]: # of states realized/*	st: 1 to analyze characters, 2 to analyze states/*	BR: number of branches/*	MLC: most likely number of characters/states/*	bestS: support for MLC/*	ebar: support "error bar" width/* Returns:/*	supcurve: log likelihood for numbers of states/characters/*		supcurve[0]: number of states/characters/*		supcurve[1]: log-likelihood of number of states/characters************************************************************************************/double** i_finite_ebar(int **data, int st, int BR, int MLC, double bestS, double ebar){int		a, b, c;int		lbc, ubc, mnc;int		start;int		*deltas, *ttlst;int		d, k, m, u, t;		/* variables for numbers of new and used states */double	S;double	x, y;double	ubS, lbS;double	**supcurve;deltas=ivector(BR);ttlst=ivector(BR);for (a=0; a<BR; ++a)	{	deltas[a]=data[a][1];	ttlst[a]=data[a][st];		/* 1 if chars, 2 if states */	if (deltas[a]==ttlst[a])	start=a+1;	}mnc=ttlst[BR-1];/* find bestS */lbS=ubS=bestS;for (lbc=MLC-1; (bestS-lbS)<ebar && lbc>=mnc; --lbc)	{	lbS=0.0f;	for (b=start; b<BR; ++b)	{		m = deltas[b]-deltas[b-1];		/* number of changes 							*/		k = ttlst[b]-ttlst[b-1];		/* number of new states realized				*/		d=m-k;							/* number of retreads 							*/		u = lbc-ttlst[b-1];				/* number of possible new states at this branch	*/		t = ttlst[b-1];					/* number of realized states at this branch		*/		/* sum the probability of drawing the new states given the size of the new state pool	*/		/* 	and the size of the total state pool; remember, this is hypergeometric now.			*/		y=0;		for (a=0; a<k; ++a)	{			x=log(((double) (u-a))/((double) (lbc-a)));			y+=x;			lbS+=x;			}		/* sum the probability of drawing the old states given the size of the old state pool	*/		/* 	and the size of the total state pool; remember, this is hypergeometric now.			*/		y=0;		for (a=0; a<d; ++a)	{			x=log(((double) (t-a))/((double) (lbc-a)));			y+=x;			lbS+=x;			}		/* take into account the numerous combinations of drawing k new states and (m-k) old ones	*/		lbS+=log(combin(m,k));		}	/* end calcuation of log-probability of lbc given Y new states in X derivations for branch b */	}if (lbc<MLC)	++lbc;for (ubc=MLC+1; (bestS-ubS)<ebar; ++ubc)	{	ubS=0.0f;	for (b=start; b<BR; ++b)	{		m = deltas[b]-deltas[b-1];		/* number of changes 							*/		k = ttlst[b]-ttlst[b-1];		/* number of new states realized				*/		d=m-k;							/* number of retreads 							*/		u = ubc-ttlst[b-1];				/* number of possible new states at this branch	*/		t = ttlst[b-1];					/* number of realized states at this branch		*/		/* sum the probability of drawing the new states given the size of the new state pool	*/		/* 	and the size of the total state pool; remember, this is hypergeometric now.			*/		y=0;		for (a=0; a<k; ++a)	{			x=log(((double) (u-a))/((double) (ubc-a)));			y+=x;			ubS+=x;			}		/* sum the probability of drawing the old states given the size of the old state pool	*/		/* 	and the size of the total state pool; remember, this is hypergeometric now.			*/		y=0;		for (a=0; a<d; ++a)	{			x=log(((double) (t-a))/((double) (ubc-a)));			y+=x;			ubS+=x;			}		/* take into account the numerous combinations of drawing k new states and (m-k) old ones	*/		ubS+=log(combin(m,k));		}	/* end calcuation of log-probability of ubc given Y new states in X derivations for branch b */	}--ubc;supcurve=dmatrix(2+(ubc+lbc),2);supcurve[0][0]=lbc;supcurve[0][1]=ubc;for (c=lbc; c<=ubc; ++c)	{	supcurve[1+(c-lbc)][0]=c;	S=0.0f;								/* clear support to zero						*/	for (b=start; b<BR; ++b)	{		m = deltas[b]-deltas[b-1];		/* number of changes 							*/		k = ttlst[b]-ttlst[b-1];		/* number of new states realized				*/		d=m-k;							/* number of retreads 							*/		u = c-ttlst[b-1];				/* number of possible new states at this branch	*/		t = ttlst[b-1];					/* number of realized states at this branch		*/		/* sum the probability of drawing the new states given the size of the new state pool	*/		/* 	and the size of the total state pool; remember, this is hypergeometric now.			*/		y=0;		for (a=0; a<k; ++a)	{			x=log(((double) (u-a))/((double) (c-a)));			y+=x;			S+=x;			}		/* sum the probability of drawing the old states given the size of the old state pool	*/		/* 	and the size of the total state pool; remember, this is hypergeometric now.			*/		y=0;		for (a=0; a<d; ++a)	{			x=log(((double) (t-a))/((double) (c-a)));			y+=x;			S+=x;			}		/* take into account the numerous combinations of drawing k new states and (m-k) old ones	*/		S+=log(combin(m,k));		}	/* end calcuation of log-probability of c given Y new states in X derivations for branch b */	supcurve[1+(c-lbc)][1]=S;	}free_ivector(ttlst);free_ivector(deltas);return supcurve;}/* dFinite: finds the best finite equiprobable classes function given first differences & double data/*/* Requires:/*	data: Exhaustion curve/*		data[0]: # of changes/*		data[1]: # of characters/*		data[2]: # of states/*	branches: number of branches/*/* Returns:/*	bestrare: information about best fit line/*		bestrare[0]: best linear increase for characters/*		bestrare[1]: log-likelihood for best power increase/*		bestrare[2]: best linear increase for states/*		bestrare[3]: log-likelihood for best power increase************************************************************************************/double* dFinite(double **data, int BR){int		a, i, j, besttotal, start, r;double	*deltas,*ttlst;double	B, M, S, y;double	bestS;double	*bestrare;deltas=dvector(BR);ttlst=dvector(BR);bestrare=dvector(4);for (r=0; r<=1; ++r)	{	for (a=0; a<BR; ++a)	{		deltas[a]=data[a][1];		ttlst[a]=data[a][2+r];	/* 2 if chars, 3 if states */		if (deltas[a]==ttlst[a])	start=a+1;		}	/* the first loop gives a range of states to examine */	bestS=-1*RAND_MAX;	for (j=ttlst[BR-1]; j<10*deltas[BR-1]; ++j)	{		y = j;		S=0;		for (i=start; i<BR; ++i)	{			M = deltas[i]-deltas[i-1];			B = y*(1-pow(1-(1/y),deltas[i])) - y*(1-pow(1-(1/y),deltas[i-1]));					B = B/M;			S = S+lnPoisson((ttlst[i]-ttlst[i-1]),B,M);			}		if (S>bestS || j==ttlst[BR-1]-5)	{			bestrare[0+(r*2)]=besttotal=j;			bestrare[1+(r*2)]=bestS=S;			}		else	j = 10*deltas[BR-1];		}	}free_dvector(deltas);free_dvector(ttlst);return bestrare;}/* iPower: finds the best power function given first differences and integer data/*/* Requires:/*	data: Exhaustion curve/*		data[0]: # of changes/*		data[1]: # of characters/*		data[2]: # of states/*	branches: number of branches/*/* Returns:/*	bestpowr: information about best fit line/*		bestpowr[0]: best coefficient for characters/*		bestpowr[1]: best exponent for characters/*		bestpowr[2]: log-likelihood for best power increase/*		bestpowr[3]: best coefficient for states/*		bestpowr[4]: best exponent for states/*		bestpowr[5]: log-likelihood for best power increase************************************************************************************/double* iPower(int **data, int BR){int		a, d, i, k, start, coef, exp, inexp, real, r, tries;int		*deltas,*ttlst;double	E, B, M, X, S, y, C, bestS, BestX, *bestpowr;deltas=ivector(BR);ttlst=ivector(BR);bestpowr=dvector(6);bestpowr[2]=bestpowr[5]=-1*RAND_MAX;for (r=0; r<=1; ++r)	{	for (a=0; a<BR; ++a)	{		deltas[a]=data[a][1];		ttlst[a]=data[a][2+r];	/* 2 if chars, 3 if states */		if (deltas[a]==ttlst[a])	start=a+1;		}	tries=d=0;	/* the first loop gives a range of states to examine */	for (coef=1001; coef<3000+d; coef=coef+2)	{		C=coef;		C=0.001*C;		E=ttlst[BR-1];		E=100*E;				inexp=999;		while (E>ttlst[BR-1]+25)	{			X = inexp;			X = 0.001*X;			E = C*pow(deltas[BR-1],X);			--inexp;			}				bestS=-100000000;		for (exp=inexp; exp>0; --exp)	{			X = exp;			X = 0.001*X;			/* find where Æ is less than 1.0 */			real=0;			y=2;			while (y>=1)	{				y=(C*pow(real+1,X))-(C*pow(real,X));				++real;				}			--real;			S=0;						for (i=0; i<BR-start-1; ++i)	{				k=i+start;				M = deltas[k+1]-deltas[k];				B = (C*pow(real+deltas[k+1],X)) - (C*pow(real+deltas[k],X));				B = B/M;				S = S+lnPoisson((ttlst[k+1]-ttlst[k]),B,M);				}							if (S>bestS)	{				BestX=X;				bestS=S;				}			else	exp=0;			}		if (bestS>bestpowr[2+(r*3)])	{			bestpowr[0+(r*3)]=C;			bestpowr[1+(r*3)]=BestX;			bestpowr[2+(r*3)]=bestS;			if (coef>=3000+d)	++d;			tries=0;			}		/* if bestS is lower than best overall S, then make note of this */		/* to avoid local optima due to rounding error, wait until we've seen this three times in a row */		else	++tries;				if (tries==3)	coef=3000+d;		}	}free_ivector(deltas);free_ivector(ttlst);return bestpowr;}/* dPower: finds the best power function given first differences and double data/*/* Requires:/*	data: Exhaustion curve/*		data[0]: # of changes/*		data[1]: # of characters/*		data[2]: # of states/*	branches: number of branches/*/* Returns:/*	bestpowr: information about best fit line/*		bestpowr[0]: best coefficient for characters/*		bestpowr[1]: best exponent for characters/*		bestpowr[2]: log-likelihood for best linear increase/*		bestpowr[3]: best coefficient for states/*		bestpowr[4]: best exponent for states/*		bestpowr[5]: log-likelihood for best linear increase************************************************************************************/double* dPower(double **data, int BR){int		a, d, i, k, start, coef, exp, inexp, real, r, tries;double	*deltas,*ttlst;double	E, B, M, X, S, y, C, bestS, BestX, *bestpowr;deltas=dvector(BR);ttlst=dvector(BR);bestpowr=dvector(6);bestpowr[2]=bestpowr[5]=-1*RAND_MAX;for (r=0; r<=1; ++r)	{	for (a=0; a<BR; ++a)	{		deltas[a]=data[a][1];		ttlst[a]=data[a][2+r];	/* 2 if chars, 3 if states */		if (deltas[a]==ttlst[a])	start=a+1;		}	tries=d=0;	/* the first loop gives a range of states to examine */	for (coef=1001; coef<3000+d; coef=coef+2)	{		C=coef;		C=0.001*C;		E=ttlst[BR-1];		E=100*E;				inexp=999;		while (E>ttlst[BR-1]+25)	{			X = inexp;			X = 0.001*X;			E = C*pow(deltas[BR-1],X);			--inexp;			}				bestS=-100000000;		for (exp=inexp; exp>0; --exp)	{			X = exp;			X = 0.001*X;			/* find where Æ is less than 1.0 */			real=0;			y=2;			while (y>=1)	{				y=(C*pow(real+1,X))-(C*pow(real,X));				++real;				}			--real;			S=0;						for (i=0; i<BR-start-1; ++i)	{				k=i+start;				M = deltas[k+1]-deltas[k];				B = (C*pow(real+deltas[k+1],X)) - (C*pow(real+deltas[k],X));				B = B/M;				S = S+lnPoisson((ttlst[k+1]-ttlst[k]),B,M);				}							if (S>bestS)	{				BestX=X;				bestS=S;				}			else	exp=0;			}		if (bestS>bestpowr[2+(r*3)])	{			bestpowr[0+(r*3)]=C;			bestpowr[1+(r*3)]=BestX;			bestpowr[2+(r*3)]=bestS;			if (coef>=3000+d)	++d;			tries=0;			}		/* if bestS is lower than best overall S, then make note of this */		/* to avoid local optima due to rounding error, wait until we've seen this three times in a row */		else	++tries;				if (tries==3)	coef=3000+d;		}	}free_dvector(deltas);free_dvector(ttlst);return bestpowr;}double LnPoisson(int obs, double rate, double N){double	result, lambda, x, y;x = obs;lambda = rate*N;if (lambda==0)	lambda = rate;if (obs>0)	y = factorial(obs);else		y = 0;result = (x*log(lambda)-y)-lambda;return result;}double	factorial (int number){int	i;double	result;result=0;for (i=2; i<=number; ++i)	result=result+log(i);return result;}/*FROM HURLBERT 1971 EQUATION 14 - E(Sn) = ·[1 - (1-¹i)^n]NEEDS:    - array with abundance distribution (*abundance)    - number of samples (n)RETURNS:    - expected number of sampled data at a given sampling intensity.*************************************************************/double HurlbertSimple(int n, int S)	{int	i;double	p, xx, ES=0;p=S;p=1/p;for (i=0; i<S; ++i)	{	xx=1-p;	xx=pow(xx,n);	xx=1-xx;	ES=ES+xx;	}return ES;}double PowerFunction(int n, double coeff, double exp)	{double	x, y;x=n;y=coeff*pow(x,exp);}