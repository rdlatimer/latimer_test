#define historicaldiversity#include "historicaldiversity.h"#define memory#include "memory.h"#define minmax#include "minmax.h"#define matrixanalysis#include "matrixanalysis.h"#define matrixchange#include "matrixchange.h"#define sort#include "sort.h"/* richnesstally - counts the number of taxa present in each interval/* Requires:/*		ranges - a notu x 2 matrix giving first and last appearances;/*			ranges[x][0] - first appearance of taxon x;/*			ranges[x][1] - last appearance of taxon x;/*		notu - number of taxa./*/* Returns:/*		S - an array giving the number of taxa per interval (S is standard notation for richness)*************************************************************************************/long *richnesstally(long **ranges, int notu){int	d, sp, onset, end;long *S;/*onset=minlarray(fa,notu);end=maxlarray(la,notu);	*/onset=minlmatrixcol(ranges,notu,0);end=maxlmatrixcol(ranges,notu,1);S=lvector(end+1);for (sp=0; sp<notu; ++sp)	{	for (d=ranges[sp][0]; d<=ranges[sp][1]; ++d)	{		++S[d];		}	}return S;}/* rangethru - counts the number of taxa before and after each interval*************************************************************************************/double *rangethru(long *fa, long *la, int notu){int	d, sp, onset, end;double *rt;onset=minlarray(fa,notu);end=maxlarray(la,notu);rt=dvector(end+1);for (sp=0; sp<notu; ++sp)	{	for (d=fa[sp]+1; d<la[sp]; ++d)	{		++rt[d];		}	}return rt;}/*	r: intrinsic rate of increase	K: peak richness	N: initial richness*************************************************************************/double logisticincrease(double r, int K, int S){double dSdt=r*S*(1-(((double) S)/((double) K)));return dSdt;}/*	r: intrinsic rate of increase	K: peak richness	Ni: initial richness of this group	Nj: initial richness of the other group	a: effect of group i on group j: >1 means that group j is worth 1+ group i; <1 means that group j is worth less than 1 of group i.			the group with the higher number is winning			if a==1, then it's just the standard logistic unless K or r differ between the two groups.*************************************************************************/double coupledlogisticincrease(double r, int K, int Si, int Sj, double a){//ROUND(C9+O$3*C9*(1-(C9+(O$4*B9))/O$2),0)//ROUND(Ni+O$3*Ni*(1-(Ni+(a*Nj))/K),0)/*double dNdt;double u, v, w, x, y, z;x=a*((double) Nj);y=((double) Ni)+(a*((double) Nj));z=(((double) Ni)+(a*((double) Nj)))/((double) K);u=1-(((double) Ni)+(a*((double) Nj)))/((double) K);v=r*Ni;w=v*u;	*/double dSdt=r*Si*(1-((((double) Si)+(a*((double) Sj)))/((double) K)));return dSdt;}/* extant - creates matrix showing when taxa were present*************************************************************************************/long **extant(long **ranges, int notu){int t, sp, onset, end, mxd;long *S, **present;onset=minlmatrixcol(ranges,notu,0);end=maxlmatrixcol(ranges,notu,1);S=richnesstally(ranges,notu);mxd=-1*MAXRAND;for (t=onset; t<=end; ++t)	if (S[t]>mxd)	mxd=S[t];present=lmatrix(end+1,mxd+1);for (sp=0; sp<notu; ++sp)	{	for (t=ranges[sp][0]; t<=ranges[sp][1]; ++t)	{		present[t][++present[t][0]]=sp;		}	}free_lvector(S);return present;}/* standing - create a vector of the extant taxa in an interval*************************************************************************************/long *standing(long **ranges, int notu, int S, int st){int t, sp;long *present;present=lvector(S);t=0;for (sp=0; sp<notu; ++sp)	{	if (ranges[sp][0]>=st && ranges[sp][1]<=st)	{		present[t]=sp;		++t;		}	}return present;}long *cumulativediversity(long **ranges, int notu){int	d, sp, onset, end;long *S;/*onset=minlarray(fa,notu);end=maxlarray(la,notu);	*/onset=minlmatrixcol(ranges,notu,0);end=maxlmatrixcol(ranges,notu,1);S=lvector(end+1);for (sp=0; sp<notu; ++sp)	{	for (d=ranges[sp][0]; d<=end; ++d)	{		++S[d];		}	}return S;}/* FreqRat - estimates sampling intensity based on singletons, doubletons, tripletons*************************************************************************************/double FreqRat(long *fa, long *la, int notu){int	sp, onset, end;double	*range;double	rat;onset=minlarray(fa,notu);end=maxlarray(la,notu);range=dvector(2+(end-onset));range[1]=range[2]=range[3]=0.0f;for (sp=0; sp<notu; ++sp)	{	range[1+(la[sp]-fa[sp])]=1+range[1+(la[sp]-fa[sp])];	}if (range[1]<1)	range[1]=1;if (range[3]<1 || ((end-onset)<2))	rat = 0;else	rat=(range[2]*range[2])/(range[1]*range[3]);free_dvector(range);return rat;}/* FreqRat - estimates sampling intensity based on singletons, doubletons, tripletons*************************************************************************************/double FreqRatMatrix(long **strat, int notu){int	sp, onset, end;double	*range;double	rat;onset=minlmatrixcol(strat,notu,0);end=maxlmatrixcol(strat,notu,1);range=dvector(2+(end-onset));range[1]=range[2]=range[3]=0.0f;for (sp=0; sp<notu; ++sp)	{	range[1+(strat[sp][1]-strat[sp][0])]=1+range[1+(strat[sp][1]-strat[sp][0])];	}if (range[1]<1)	range[1]=1;if (range[3]<1 || ((end-onset)<2))	{	if (range[2]>=range[1])	rat=1.0;	else 					rat=0.0;	}else	rat=(range[2]*range[2])/(range[1]*range[3]);free_dvector(range);return rat;}/* SameFAs - counts the number of different first appearances*************************************************************************************/int samefas(long *fa, int notu){int	sp;long	*f;int	shared=1;f=lvector(notu);equallvector(f,fa,notu);f=lshellsort_dec(f,notu);for (sp=1; sp<notu; ++sp)	{	if (f[sp]!=f[sp-1])	++shared;	}free_lvector(f);return shared;}/**************************************************************************************/double **gapprescalc(double *gaps, double *rthru, int stg){int	st;double p, q, r;double mS,lbS,ubS,l1S,u1S,mlR,lbR,ubR,l1R,u1R;double **results;results=dmatrix(stg,6);for (st=0; st<stg; ++st)	{	/* only bother if 10+ taxa range through */	while (rthru[st]<10 && st<stg)	++st;	if (st>=stg)	break;		p=rthru[st]-gaps[st];	q=gaps[st];	mlR=1-(gaps[st]/rthru[st]);	l1S=u1S=lbS=ubS=mS=(p*log(mlR)) + (q*log(1-mlR));		for (r=mlR; lbS>(mS-1) && r>0; r=r-0.005)	{		lbS=(p*log(r)) + (q*log(1-r));		if (l1S==mS && lbS<=(mS-1))	{			l1S=lbS;			l1R=r;			}		lbR=r+0.005;		}		for (r=mlR; ubS>(mS-1) && r<1; r=r+0.005)	{		ubS=(p*log(r)) + (q*log(1-r));		if (u1S==mS && ubS<=(mS-1))	{			u1S=ubS;			u1R=r;			}		ubR=r-0.005;		}	results[st][0]=mlR;	results[st][1]=mS;	results[st][2]=lbR;	results[st][3]=lbS;	results[st][4]=ubR;	results[st][5]=ubS;	}return results;}/**************************************************************************************/double *gapextinction(double *gaps, double *stgaps, double *rng, int stg, int notu){int		n, bins;double	sumrng=0, sumgps=0;double	m;double	/*rS, */eS;//, meS, zeS;double	mR;//, mM;double	*X;X=dvector(stg);n=stgaps[0];for (n=1; n<stg; ++n)	{	if (gaps[n]>0)	{		bins=n+1;		sumgps=sumgps+(n*gaps[n]);		}	}for (n=0; n<notu; ++n)	if (rng[n]>2)	sumrng=sumrng+(rng[n]-2);mR=1-(sumgps/sumrng);for (m=0.5; m<1; m=m+0.005)	{	eS=0;	for (n=1; n<bins; ++n)	{		eS=eS+gaps[n]*n*log(m*mR);		}	}return X;}/* expectedpropsampled - calculate the expected sampled proportion given sampling & extinction.Requires:	mu - extinction rate	r - preservation rateReturns:	1-miss = expected proportion.  *************************************************************************************/double completeness(double mu, double r){int 	i;double	invr, cas, rem=1, miss=0;invr=(1-r);		/* probability of not being sampled */cas=mu;			/* proportion lasting only one unit	*/rem=rem-cas;	/* proportion lasting two+ units 	*//* calculate the proportion that we will not sample */for (i=1; i<=100 && (invr*cas)>0.00000001; ++i)	{	miss=miss+(invr*cas);	/* lm*rem is proportion that live i units */	cas=mu*rem;				/* proportion going extinct at i+1 units given extinction lm */	rem=rem-cas;			/* proportion living ³i+1 units */	invr=invr*(1-r);		/* probability of not being sampled i+1 units given sampling r */	}return (1-miss);}/* expectedpropsampled - calculate the expected sampled proportion given sampling & extinction.Requires:	lm - extinction rate	r - preservation rateReturns:	1-miss = expected proportion.  *************************************************************************************/double expectedpropsampled(double lm, double r){int 	i;double	invr, cas, rem=1, miss=0;invr=(1-r);		/* probability of not being sampled */cas=lm;			/* proportion lasting only one unit	*/rem=rem-cas;	/* proportion lasting two+ units 	*//* calculate the proportion that we will not sample */for (i=1; i<=100 && (invr*cas)>0.00000001; ++i)	{	miss=miss+(invr*cas);	/* lm*rem is proportion that live i units */	cas=lm*rem;				/* proportion going extinct at i+1 units given extinction lm */	rem=rem-cas;			/* proportion living ³i+1 units */	invr=invr*(1-r);		/* probability of not being sampled i+1 units given sampling r */	}return (1-miss);}/* rarified - returns an array of length s subsampled from an array of length NRequires:	sample - an array of occurrences/specimens, with cell giving taxon number	N - number of lists	s - the subsample size;*************************************************************************************/unsigned long *rarifiedbylists(unsigned long *lists, int N, int s){int	i;unsigned long *dummy;//unsigned long *sub;i=s;					/* no real reason!	*/dummy=ulvector(N);equalulvector(dummy,lists,N);dummy=scrambleularray(dummy,N);}/* chao2 - estimate richness based on Chao 1984: Scandinavian Journal of Statistics 11:265 - 270Requires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxaReturns:	S = estimated richness.  *************************************************************************************/int chao2(int *abundance, int ntaxa){int	i, q1=0, q2=0;int S;double x;for (i=0; i<ntaxa; ++i)	{	if (abundance[i]==1)		++q1;	else if (abundance[i]==2)	++q2;	}x=ntaxa+(((double) (q1*q1))/((double) (2*(q2+1)))) - (((double)(q1*q2))/((double) (2*(q2+1)*(q2+1))));S=x;if ((x-S)>0.5)	++S;return S;}/* chao2 - estimate richness based on Chao 1984: Scandinavian Journal of Statistics 11:265 - 270Requires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxaReturns:	S = estimated richness.  *************************************************************************************/double chao2real(int *abundance, int ntaxa){int	i, q1=0, q2=0;double S;for (i=0; i<ntaxa; ++i)	{	if (abundance[i]==1)		++q1;	else if (abundance[i]==2)	++q2;	}S=ntaxa+(((double) (q1*q1))/((double) (2*(q2+1)))) - (((double)(q1*q2))/((double) (2*(q2+1)*(q2+1))));return S;}/* chao2 biased corrected- estimate richness based on Chao & Lee 1992: Journal of the American Statistical Association 87:210 - 217Requires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxa	finds - number of localities / specimensReturns:	S = estimated richness.  *************************************************************************************/int chao2bc(int *abundance, int ntaxa, int finds){int	i, q1=0, q2=0;int S;double x=1.0f;x=finds;for (i=0; i<ntaxa; ++i)	{	if (abundance[i]==1)		++q1;	else if (abundance[i]==2)	++q2;	}x=ntaxa+((double) (finds-1)/(((double) (finds-1))*((double) (q1*(q1-1)))/((double) (2*(q2+1)))));S=x;if ((x-S)>0.5)	++S;return S;}/* first order jacknife estimate of richnessRequires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxaReturns:	S = estimated richness.  *************************************************************************************/int jack1(int *abundance, int ntaxa){int i, ss=0;int S;double m,n, q1=0.0f;ss=sumivector(abundance,ntaxa);for (i=0; i<ntaxa; ++i)	if (abundance[i]==1)	++q1;m=ss;n = ntaxa + q1*((m-1)/m);S=n;if ((n-S)>=0.5)	++S;return S;}/* second order jacknife estimate of richnessRequires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxaReturns:	S = estimated richness.  *************************************************************************************/int jack2(int *abundance, int ntaxa){int i, ss=0;int S;double m,n, q1=0.0f, q2=0.0f;ss=sumivector(abundance,ntaxa);for (i=0; i<ntaxa; ++i)	{	if (abundance[i]==1)		++q1;	else if (abundance[i]==2)	++q2;	}m=ss;n = ntaxa + (q1*(((2*m)-3)/m)) - q2*(((m-2)*(m-2))/(m*(m-1)));S=n;if ((n-S)>=0.5)	++S;return S;}/* third order jacknife estimate of richnessRequires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxaReturns:	S = estimated richness.  *************************************************************************************/int jack3(int *abundance, int ntaxa){int i, ss=0;int S;double m,n, q1=0.0f, q2=0.0f, q3=0.0f;ss=sumivector(abundance,ntaxa);for (i=0; i<ntaxa; ++i)	{	if (abundance[i]==1)		++q1;	else if (abundance[i]==2)	++q2;	else if (abundance[i]==3)	++q3;	}m=ss;n = ntaxa + (q1*(((3*m)-6)/m)) - q2*((3*(m*m)-(15*m)+19)/(m*(m-1))) + q3*(pow(m-3,3)/(m*(m-1)*(m-2)));S=n;if ((n-S)>=0.5)	++S;return S;}/* fourth order jacknife estimate of richnessRequires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxaReturns:	S = estimated richness.  *************************************************************************************/int jack4(int *abundance, int ntaxa){int i, ss=0;int S;double m,n, q1=0.0f, q2=0.0f, q3=0.0f, q4=0.0f;ss=sumivector(abundance,ntaxa);for (i=0; i<ntaxa; ++i)	{	if (abundance[i]==1)		++q1;	else if (abundance[i]==2)	++q2;	else if (abundance[i]==3)	++q3;	else if (abundance[i]==4)	++q4;	}m=ss;n = ntaxa + (q1*(((4*m)-10)/m)) - q2*((6*(m*m)-(36*m)+55)/(m*(m-1))) + q3*(((4*pow(m,3))-(42*pow(m,2))+(148*m)-175))/(m*(m-1)*(m-2)) - q4*pow((m-4),4)/(m*(m-1)*(m-2)*(m-3));S=n;if ((n-S)>=0.5)	++S;return S;}/* fourth order jacknife estimate of richnessRequires:	abundance - an array of taxon abundances	ntaxa - the number of sampled taxaReturns:	S = estimated richness.  *************************************************************************************/int jack5(int *abundance, int ntaxa){int i, ss=0;int S;double m,n, q1=0.0f, q2=0.0f, q3=0.0f, q4=0.0f, q5=0.0f;ss=sumivector(abundance,ntaxa);for (i=0; i<ntaxa; ++i)	{	if (abundance[i]==1)		++q1;	else if (abundance[i]==2)	++q2;	else if (abundance[i]==3)	++q3;	else if (abundance[i]==4)	++q4;	else if (abundance[i]==5)	++q5;	}m=ss;n = ntaxa + (q1*(((5*m)-15)/m)) - q2*((10*(m*m)-(70*m)+125)/(m*(m-1)))+ q3*(((10*pow(m,3))-(120*pow(m,2))+(485*m)-660))/(m*(m-1)*(m-2))- q4*pow((m-4),4)/(m*(m-1)*(m-2)*(m-3))+ q5*pow((m-5),5)/(m*(m-1)*(m-2)*(m-3)*(m-4));S=n;if ((n-S)>=0.5)	++S;return S;}/********************************************************************	tad1: taxon occurrences in Bin X	tad2: taxon occurrences in Bin Y	spid1: taxon numbers for taxa in Bin X	spid2: taxon numbers for taxa in Bin Y	S1: observed taxa in Bin X	S2: observed taxa in Bin Y	w: for Bin X, total finds if abundance data or total collections if locality data	z: for Bin Y, total finds if abundance data or total collections if locality data/*	variables follow Chao et al. 2005 insofar as possible/********************************************************/double *chaosharedUV(unsigned long *tad1, unsigned long *tad2, unsigned long *spid1, unsigned long *spid2, int S1, int S2, int w, int z){int a, b;int D12=0;double fx1=0.0f, fx2=0.0, f1y=0.0f, f2y=0.0f;double sumXi=0, sumYi=0, sumXiOne=0, sumYiOne=0;double nx, ny;//double U, V;double *X, *Y;				/* arrays of finds for shared species in X and Y			*/double *UV;double ii, ij, ik, im, ji, jj, jk, jm;/* U = Prop. of List X occurrences that are co-occurrences + (([lists in Y] - 1)/[lists in Y]) x Prop. of occurrences in List X that are singletons in Y	*/UV=dvector(2);//shared=ivector(S1);X=dvector(S1);		/* finds in list X for shared taxa	*/Y=dvector(S1);		/* finds in list Y for shared taxa	*/for (a=0; a<S1; ++a)	{	for (b=0; b<S2; ++b)	{		if (spid1[a]==spid2[b])	{//			shared[D12]=spid1[a];			X[D12]=tad1[a];					/* sum all of the finds for shared taxa from list X	*/			Y[D12]=tad2[b];					/* sum all of the finds for shared taxa from list Y	*/			if (Y[D12]==1)	++fx1;			/* taxa from list X found once in list Y	*/			else if (Y[D12]==2)	++fx2;		/* taxa from list X found twice in list Y	*/			if (X[D12]==1)	++f1y;			/* taxa from list Y found once in list X	*/			else if (X[D12]==2)	++f2y;		/* taxa from list Y found twice in list X	*/			++D12;			b=S2;	/* terminate search: it's been found!	*/			}	/* end search for match	*/		}	}nx=sumulvector(tad1,S1);	/* total finds in X	*/ny=sumulvector(tad2,S2);	/* total finds in Y	*/if (f2y==0)	f2y=1.0f;if (fx2==0)	fx2=1.0f;/* U = [proportion of finds in X from species also found in Y] + [(Ycoll - 1)/Ycoll] x [shared Y singletons / (2 x shared Y doubletons)] x [prop. of finds in X from Y singletons]	*/ii=sumdvector(X,D12);ii/=nx;										/* proportion of occurrences in X from species shared with Y		*/ij=((double) (z-1))/((double) z);			/* (max poss. occurrences in Y - 1) / max possible occurrences in Y	*/ik=fx1/(2*fx2);								/* Y singletons / (2 x Y doubletons) assuming shared with X			*/im=0.0f;									/* prop. of occurrences in X from singletons in Y					*/for (a=0; a<D12; ++a)	if (Y[a]==1)	im+=X[a]/((double) nx);UV[0]= ii + (ij*ik*im);/* V = [proportion of finds in Y from species also found in X] + [(Xcoll - 1)/Xcoll] x [shared X singletons / (2 x shared X doubletons)] x [prop. of finds in Y from X singletons]	*/ji=sumdvector(Y,D12);ji/=ny;jj=((double) (w-1))/((double) w);jk=f1y/(2*f2y);jm=0.0f;for (a=0; a<D12; ++a)	if (X[a]==1)	jm+=Y[a]/((double) ny);UV[1]= ji + (jj*jk*jm);return (UV);/* find shared taxa	*/}/********************************************************************	tad1: taxon occurrences in Bin X	tad2: taxon occurrences in Bin Y	spid1: taxon numbers for taxa in Bin X	spid2: taxon numbers for taxa in Bin Y	S1: observed taxa in Bin X	S2: observed taxa in Bin Y	w: for Bin X, total finds if abundance data or total collections if locality data	z: for Bin Y, total finds if abundance data or total collections if locality data/*	variables follow Chao et al. 2005 insofar as possible/********************************************************/double chaosharedrichness(unsigned long *tad1, unsigned long *tad2, unsigned long *spid1, unsigned long *spid2, int S1, int S2, int w, int z){int a, b;int D12=0;double	f1k=0.0f, f2k=0.0f, fj1=0.0f, fj2=0.0f, f11=0.0f, f22=0.0f;int *shared;int *X, *Y;				/* arrays of finds for shared species in X and Y			*/double K1, K2;double	S12=0.0f;shared=ivector(S1);X=ivector(S1);		/* finds in list X for shared taxa	*/Y=ivector(S1);		/* finds in list Y for shared taxa	*/for (a=0; a<S1; ++a)	{	for (b=0; b<S2; ++b)	{		if (spid1[a]==spid2[b])	{			shared[D12]=spid1[a];			X[D12]=tad1[a];		/* sum all of the finds for shared taxa from list X	*/			Y[D12]=tad2[b];		/* sum all of the finds for shared taxa from list Y	*/			/* tally shared species that are singletons in one or both	*/			if (Y[D12]==1)	{				++fj1;			/* taxa from list X found once in list Y	*/				if (X[D12]==1)	++f11;				}			else if (Y[D12]==2)	{				++fj2;			/* taxa from list X found twice in list Y	*/				if (X[D12]==2)	++f22;				}			if (X[D12]==1)					++f1k;			/* taxa from list Y found once in list X	*/			else if (X[D12]==2)				++f2k;			/* taxa from list Y found twice in list X	*/			b=S2;	/* terminate search: it's been found!	*/			++D12;			}	/* end search for match	*/		}	/* end search to see if bin B has a match with bin A	*/	}//if (fj1==0)	fj1=1;			/* make sure these numbers all are at least 1	*/if (fj2==0)	fj2=1;//if (f1k==0)	f1k=1;if (f2k==0)	f2k=1;//if (f11==0)	f11=1;if (f22==0)	f22=1;K1=((double) (w-1))/((double) w);K2=((double) (z-1))/((double) z);S12=((K1*f1k*f1k)/(2*f2k))+((K2*fj1*fj1)/(2*fj2))+(((K1*K2*f11*(f11-1)))/(4*(f22+1)));return (S12);/* find shared taxa	*/}/* cladeshape: find clade shape statistics	ranges: first and last appearances of taxa	otus: number of taxa	basis: whether we do this based on first or last appearance data.  (Usually use last, except for things like stratigraphic compatibility!)Return: C	c[0] = · Si	c[1] = · (Si x ti)	c[2] = · (Si x (ti)^2)	c[3] = · (Si x (ti)^3)**************************************************/double *cladeshapefromranges(long **ranges, int otus, int basis){int n, t;int on, T=0;long *S;double *C;on=ranges[0][0];				/* key to finding earliest time	*/for (n=0; n<otus; ++n)	{	if (ranges[n][basis]>T)		T=ranges[n][basis];	if (ranges[n][basis]<on)	on=ranges[n][basis];	}S=richnesstally(ranges,otus);C=dvector(4);cleardvector(C,4,0);for (t=on; t<=T; ++t)	{	C[0]+=S[t];	C[1]+=(S[t]*(t+0.5));	C[2]+=(S[t]*(t+0.5)*(t+0.5));	C[3]+=(S[t]*(t+0.5)*(t+0.5)*(t+0.5));	}free_lvector(S);return C;}/* cladeshape: find clade shape statistics	S: vector giving richness at different times	onset: first appearance	end: last appearanceReturn: C	c[0] = · Si	c[1] = · (Si x ti)	c[2] = · (Si x (ti)^2)	c[3] = · (Si x (ti)^3)**************************************************/double *cladeshapefromrichness(long *S, int onset, int end){int t;double *C;C=dvector(4);cleardvector(C,4,0);for (t=onset; t<=end; ++t)	{	C[0]+=S[t];	C[1]+=(S[t]*(t+0.5));	C[2]+=(S[t]*(t+0.5)*(t+0.5));	C[3]+=(S[t]*(t+0.5)*(t+0.5)*(t+0.5));	}return C;}double centerofgravityfromranges(long **ranges, int otus, int basis, int onset, int end){double *C;double CG;C=cladeshapefromranges(ranges,otus,basis);CG=(((double) (1+(end-onset))) - (C[1]/C[0]))/((double) (1+(end-onset)));/* note: use 1 instead of 0.5 so the "peak" is attributed to the middle of the stage rather than the beginning	*/free_dvector(C);return CG;}double centerofgravityfromrichness(long *S, int onset, int end){double *C;double CG;C=cladeshapefromrichness(S,onset,end);CG=(((double) (1+(end-onset))) - (C[1]/C[0]))/((double) (1+(end-onset)));/* note: use 1 instead of 0.5 so the "peak" is attributed to the middle of the stage rather than the beginning	*/free_dvector(C);return CG;}double rawcenterofgravityfromranges(long **ranges, int otus, int basis){double *C;double CG;C=cladeshapefromranges(ranges,otus,basis);CG=C[1]/C[0];free_dvector(C);return CG;}double rawcenterofgravityfromrichness(long *S, int onset, int end){double *C;double CG;C=cladeshapefromrichness(S,onset,end);CG=C[1]/C[0];free_dvector(C);return CG;}double JaccardSim(double A, double B, double C){double a, b, c;a=dmax(A,0);b=dmax(B,0);c=dmax(C,0);if (a==0)	return (0.0);else		return (a/(a+b+c));}double SorensenSim(double A, double B, double C){double a, b, c;a=dmax(A,0);b=dmax(B,0);c=dmax(C,0);if (a==0)	return (0.0);else		return ((2*a)/((2*a)+b+c));}double SimpsonSim(double A, double B, double C){double a, b, c;a=dmax(A,0);b=dmax(B,0);c=dmax(C,0);if (a==0)	return (0.0);else		return (a/(a+dmin(b,c)));}double NestedResultantSim(double A, double B, double C){double a, b, c;double x, y;a=dmax(A,0);b=dmax(B,0);c=dmax(C,0);x=fabs(b-c)/((2*a)+b+c);y=a/(a+dmin(b,c));if (a==0)	return (0.0);else		return(1-(x*y));//return(1-((abs(b-c)/((2*a)+b+c))*(a/(a+dmin(b,c)))));//return (1-(((Smax-Smin)/((2*Sshared))) * (Sshared/(Sshared-Smin))));}double LennonSim(double A, double B, double C){double a, b, c;a=dmax(A,0);b=dmax(B,0);c=dmax(C,0);if (a==0)	return (0.0);else		return (1-(2*fabs(b-c)/((2*a)+b+c)));//return (1-(2*(Smax-Smin)/((2*Sshared))));}double JaccardDis(double A, double B, double C){double a, b, c;a=dmax(A,0);b=dmax(B,0);c=dmax(C,0);if (a==0)	return (1.0);else		return ((b+c)/(a+b+c));}double SorensenDis(double A, double B, double C){double a, b, c;a=dmax(A,0);b=dmax(B,0);c=dmax(C,0);if (a==0)	return (1.0);else		return ((b+c)/((2*a)+b+c));}double SimpsonDis(double A, double B, double C){double a, b, c;a=dmax(A,0);b=dmax(B,0);c=dmax(C,0);if (a==0)	return (1.0);else		return (dmin(b,c)/(a+dmin(b,c)));}double NestedResultantDis(double A, double B, double C){double a, b, c;double	x, y;a=dmax(A,0);b=dmax(B,0);c=dmax(C,0);x=fabs(b-c)/((2*a)+b+c);y=a/(a+dmin(b,c));if (a==0)	return (1.0);else		return(x*y);//return((abs(b-c)/((2*a)+b+c))*(a/(a+dmin(b,c))));//return (((Smax-Smin)/((2*Sshared))) * (Sshared/(Sshared-Smin)));}double LennonDis(double A, double B, double C){double a, b, c;a=dmax(A,0);b=dmax(B,0);c=dmax(C,0);if (a==0)	return (1.0);else		return (2*fabs(b-c)/((2*a)+b+c));//return (2*(Smax-Smin)/((2*Sshared)));}int countshared(unsigned long *taxa1, unsigned long *taxa2, int S1, int S2){int	i, j;int	shared=0;for (i=0; i<S1; ++i)	{	for (j=0; j<S2; ++j)	{		if (taxa1[i]==taxa2[j])	{			++shared;			j=S2;			}		}	}return (shared);}unsigned long *sharedabundance(unsigned long *tad1, unsigned long *taxa1, unsigned long *taxa2, int S1, int S2){int i, j, k, shared;unsigned long *shtad;shared=countshared(taxa1,taxa2,S1,S2);shtad=ulvector(shared);k=0;for (i=0; i<S1; ++i)	{	for (j=0; j<S2; ++j)	{		if (taxa1[i]==taxa2[j])	{			shtad[k]=tad1[i];			++k;			j=S2;			}		}	if (k==shared)	i=S1;	}return (shtad);}double **sharedrarefaction(unsigned long *finds0, unsigned long *finds1, int n0, int n1, int mxtaxa, int runs){int	f, r, lm, t1, t0;int	s0, s1, sh;unsigned long	**found;double	**results;found=ulmatrix(2,mxtaxa);lm=n0;if (n1<lm)	lm=n1;results=dmatrix(3,lm);for (r=0; r<runs; ++r)	{	s0=s1=sh=0;	clearulmatrix(found,2,mxtaxa,0);	scrambleularraycommand(finds0,n0);	scrambleularraycommand(finds1,n1);	for (f=0; f<lm; ++f)	{		t0=finds0[f];		t1=finds1[f];		if (found[0][finds0[f]]==0)	{			++s0;			found[0][t0]=1;			if (found[1][t0]>0)	++sh;		/* if this taxon is already found in other bin, then tally	*/			}		if (found[1][finds1[f]]==0)	{			++s1;			found[1][t1]=1;			if (found[0][t1]>0)	++sh;		/* if this taxon is already found in other bin, then tally	*/			}		results[0][f]+=((double) s0)/((double) runs);		results[1][f]+=((double) s1)/((double) runs);		results[2][f]+=((double) sh)/((double) runs);		}	}	/* end runs	*/free_ulmatrix(found,2,mxtaxa);return (results);}/*	finds:		finds[0]: locality		finds[1]: bin taxon number		finds[2]: overall taxon number****/unsigned long *sqs_vector(unsigned long *collections, unsigned long **finds, int C, int S, int Oc, double quota){int     c, f, n;int     coll, sp;double  q=0.0f;unsigned long    *found;unsigned long    *sqs;found=ulvector(S);sqs=ulvector(S);scrambleularraycommand(collections,C);n=0;for (c=0; q<quota && c<C; ++c) {	coll=collections[c];		f=0;	while (finds[f][0]!=coll)   ++f;	while (f<Oc && finds[f][0]==coll)   {		sp=finds[f][1];			/* bin species number	*/		if (found[sp]==0)	{			sqs[n]=finds[f][2];	/* "real" species number	*/			found[sp]=1;			}		q+=1/((double) Oc);		++f;		if (f>=Oc)	break;		}	}free_ulvector(found);ulshellsort_inc_command(sqs,n);return sqs;}unsigned long sqs_scalar(unsigned long *collections, unsigned long **finds, int C, int S, int Oc, double quota){int     c, f;int     coll, sp;double  q=0.0f;unsigned long    *found;unsigned sqs;found=ulvector(S);scrambleularraycommand(collections,C);for (c=0; q<quota && c<C; ++c) {    coll=collections[c];        f=0;    while (finds[f][0]!=coll)   ++f;    while (f<Oc && finds[f][0]==coll)   {        sp=finds[f][1];        found[sp]=1;        q+=1/((double) Oc);        ++f;        if (f>=Oc)	break;        }    }sqs=sumulvector(found, S);free_ulvector(found);return sqs;}/* routine to do shareholder quorum subsampling of lower taxa (e.g., species) and returning values for lower and higher taxa (e.g., genera)*********************************************************************************************************/unsigned long *sqs_lower_higher(unsigned long *collections, unsigned long **finds, int C, int LT, int HT, int Oc, int lc, int ht, int lt, double quota){int     c, f;int     coll, sp, gn;double  q=0.0f;unsigned long    *found_l, *found_h;unsigned long    *sqs;found_l=ulvector(LT);found_h=ulvector(HT);scrambleularraycommand(collections,C);for (c=0; q<quota && c<C; ++c) {	coll=collections[c];	f=0;	while (finds[f][lc]!=coll)   ++f;	while (f<Oc && finds[f][lc]==coll)   {		sp=finds[f][lt];		/* bin species number	*/		found_l[sp]=1;		gn=finds[f][ht];		found_h[gn]=1;		q+=1/((double) Oc);		++f;        if (f>=Oc)	break;		}	}sqs=ulvector(2);sqs[0]=sumulvector(found_l,LT);sqs[1]=sumulvector(found_h,HT);free_ulvector(found_l);free_ulvector(found_h);return sqs;}unsigned long *classicalrarefaction_lower_higher(unsigned long *finds, unsigned long *assignment, int LT, int HT, int Oc, int quota){int     f;int     sp, gn;unsigned long    *found_l, *found_h;unsigned long    *rare;found_l=ulvector(LT);found_h=ulvector(HT);scrambleularraycommand(finds,Oc);for (f=0; f<quota; ++f) {	sp=finds[f];	gn=assignment[sp];	found_l[sp]=1;	found_h[gn]=1;	}rare=ulvector(2);rare[0]=sumulvector(found_l,LT);rare[1]=sumulvector(found_h,HT);free_ulvector(found_l);free_ulvector(found_h);return rare;}unsigned long classicalrarefaction(unsigned long *finds, int Oc, int S, int quota){int     f;int     sp;unsigned long    *found;unsigned long    rare;found=ulvector(S);scrambleularraycommand(finds,Oc);for (f=0; f<quota; ++f) {	sp=finds[f];	found[sp]=1;	}rare=sumulvector(found,S);free_ulvector(found);return rare;}