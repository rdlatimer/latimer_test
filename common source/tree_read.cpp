#define TreeRead#include "tree_read.h"#define filereading#include "filereading.h"#define memory#include "memory.h"#define matrixanalysis#include "matrixanalysis.h"#define matrixchange#include "matrixchange.h"#define minmax#include "minmax.h"/* nexustotree - converts a nexus tree format to a matrix of phylogenetic information. *//* Requires:/*		dendogram - the nexus tree string;/*		notu - the number of taxa;/* Returns:/*		tree - a matrix of phylogenetic information/*			tree[node=x][0] - number of taxa in node x;/*			tree[node=x][1Étree[x][0]] - taxa in node x;*******************************************************************************************************************************************/long **nexustotree (char *nexus, int notu){int		a, b, lp, nodes, species, anc, R, L, max;int		*line, *dvr;long	**tree;lp=-1;								/*  Use Left Parentheses to Identify Clade	*/R=L=a=0;							/*         New Clades and Nodes     	*//* first find diversity of each clade *//* this will be used to allocate memory for tree */nodes=cladecountnexus(nexus);max=2;dvr=cladediversity(nexus,nodes,notu);max=maxiarray(dvr,nodes);tree=lmatrix(nodes+1,max+1);clearlmatrix(tree, nodes+1, max+1, -5);line=ivector(1+notu);lp=nodes=-1;						/*  Use Left Parentheses to Identify Clade	*/R=L=a=0;							/*         New Clades and Nodes     	*/for (a=0; R<L || R==0; ++a)	{	/* ',' signifies a new member of a clade coming up next */	if (nexus[a] == ',')	++a;	/* '(' signifies a new clade */	if (nexus[a] == '(')	{		tree[++nodes][0] = 0;		line[++lp] = nodes;		++L;		}	/* ')' signifies that we have all members of a clade */	else if (nexus[a] == ')')		{		b = line[lp-1];		++R;		if (R==L)	break;		if (b<0 || b > 2*notu)	{			printf("\a\a\a\a\n");			printf("Yo Dillweed, you goofed on line 399\n");			exit(0);			}		tree[b][++tree[b][0]] = notu+line[lp];		/* clade added */		--lp;		}	/* number indicates that we have a taxon */	else	{							/* species found	*/		species = nexus[a]-'0';		while (nexus[a+1]>='0' && nexus[a+1]<='9')	{			++a;			species = (10*species)+nexus[a]-'0';			}		/* get the node number from line & increment diversity */		anc = line[lp];		++tree[anc][0];		if (tree[anc][0]>1 && (tree[anc][tree[anc][0]] > species))	{			tree[anc][tree[anc][0]] = tree[anc][tree[anc][0]];			tree[anc][tree[anc][0]] = species;			}		else	tree[anc][tree[anc][0]] = species-1;		}	}for (a=0; a<nodes; ++a)	tree[a][0]=dvr[a];free_ivector(dvr);free_ivector(line);return tree;}/* nexusfiletotree - converts a nexus tree file format to a matrix of phylogenetic information. *//* Requires:/*		nexusfile - the nexus tree string file;/*		notu - the number of taxa;/* Returns:/*		tree - a matrix of phylogenetic information/*			tree[node=x][0] - number of taxa in node x;/*			tree[node=x][1Étree[x][0]] - taxa in node x;*******************************************************************************************************************************************/long **nexusfiletotree (char *nexusfile){int		a, b, lp, nodes, species, anc, R, L, max;int		notu, motu;int		*line, *dvr;long	**tree;char	*nexus;/*FILE 	*fopen();	*/FILE	*infile;lp=-1;								/*  Use Left Parentheses to Identify Clade	*/R=L=a=0;							/*         New Clades and Nodes     	*/notu=countotusinnexusfile(nexusfile);motu=maxtaxoninnexusfile(nexusfile);b=getlongestnameinfile(nexusfile,1);nexus = cvector(b+1);/*nexus = cvector(6*notu);*/infile = fopen(nexusfile,"r");fscanf(infile,"%s",nexus);fclose(infile);/* first find diversity of each clade *//* this will be used to allocate memory for tree */nodes=cladecountnexus(nexus);max=2;dvr=cladediversity(nexus,nodes,notu);max=maxiarray(dvr,nodes);tree=lmatrix(nodes+1,max+1);clearlmatrix(tree, nodes+1, max+1, -5);line=ivector(1+notu);lp=nodes=-1;						/*  Use Left Parentheses to Identify Clade	*/R=L=a=0;							/*         New Clades and Nodes     	*/for (a=0; R<L || R==0; ++a)	{	/* ',' signifies a new member of a clade coming up next */	if (nexus[a] == ',')	++a;	/* '(' signifies a new clade */	if (nexus[a] == '(')	{		tree[++nodes][0] = 0;		line[++lp] = nodes;		++L;		}	/* ')' signifies that we have all members of a clade */	else if (nexus[a] == ')')		{		b = line[lp-1];		++R;		if (R==L)	break;		if (b<0 || b > 2*notu)	{			printf("\a\a\a\a\n");			printf("Yo Dillweed, you goofed on line 161\n");			exit(0);			}		/* clade added - note, use motu, not notu, as we need to modify the maximum number */		tree[b][++tree[b][0]] = motu+line[lp];		/* clade added */		--lp;		}	/* number indicates that we have a taxon */	else	{							/* species found	*/		species = nexus[a]-'0';		while (nexus[a+1]>='0' && nexus[a+1]<='9')	{			++a;			species = (10*species)+nexus[a]-'0';			}		/* get the node number from line & increment diversity */		anc = line[lp];		++tree[anc][0];		if (tree[anc][0]>1 && (tree[anc][tree[anc][0]] > species))	{			tree[anc][tree[anc][0]] = tree[anc][tree[anc][0]];			tree[anc][tree[anc][0]] = species;			}		else	tree[anc][tree[anc][0]] = species-1;		}	}for (a=0; a<nodes; ++a)	tree[a][0]=dvr[a];free_ivector(dvr);free_ivector(line);return tree;}/* countotusinnexusfile - counts the number of taxa in a nexus file. *//* Requires:/*		nexusfile - the nexus tree string file;/* Returns:/*		notu - the number of taxa/*/*	NOTE: if the nexus file uses only some of the taxa from a nexus file, then the maximum/*		taxon number often will be greater than the number of OTUs.  Use ÒmaxtaxoninnexusfileÓ/*		to get that number*******************************************************************************************************************************************/int countotusinnexusfile (char *nexusfile){int		a, b, notu=0;char	*nexus;/*FILE 	*fopen();	*/FILE	*infile;b=getlongestnameinfile(nexusfile,1);nexus = cvector(b+1);infile = fopen(nexusfile,"r");fscanf(infile,"%s",nexus);fclose(infile);for (a=0; a<b; ++a)	{	/* ',' signifies a new member of a clade coming up next */	if (nexus[a+1]>='0' && nexus[a+1]<='9')	{		++notu;		while (nexus[a+1]>='0' && nexus[a+1]<='9')			++a;		}	}free_cvector(nexus);return notu;}/* maxtaxoninnexusfile - converts a nexus tree file format to a matrix of phylogenetic information. *//* Requires:/*		nexusfile - the nexus tree string file;/* Returns:/*		maxtax - the highest number of any taxon*******************************************************************************************************************************************/int maxtaxoninnexusfile (char *nexusfile){int		a, b, c, maxtax=0;char	*nexus;/*FILE 	*fopen();	*/FILE	*infile;b=getlongestnameinfile(nexusfile,1);nexus = cvector(b+1);infile = fopen(nexusfile,"r");fscanf(infile,"%s",nexus);fclose(infile);for (a=0; a<b; ++a)	{	/* ',' signifies a new member of a clade coming up next */	if (nexus[a]>='0' && nexus[a]<='9')	{		c=nexus[a]-'0';		while (nexus[a+1]>='0' && nexus[a+1]<='9')	{			c=(c*10)+nexus[a+1]-'0';			++a;			}		if (c>maxtax)	maxtax=c;		}	}free_cvector(nexus);return maxtax;}/* cladediversity - counts the number of branches springing from each clade/* Requires: nexus - a string where parentheses give clades/*			 clades - the number of clades/*			 notu - the number of taxa;/* Returns: nodes - an integer giving the number of clades************************************************************************/int* cladediversity (char *nexus, int clades, int notu){int	a, b, lp, nodes, anc, R, L;int	*line, *div2;line=ivector(1+notu);div2=ivector(clades);lp=nodes=-1;						/*  Use Left Parentheses to Identify Clade	*/R=L=a=0;							/*         New Clades and Nodes     	*/for (a=0; R<L || R==0; ++a)	{	if (nexus[a] == ',')	++a;	if (nexus[a] == '(')	{		div2[++nodes] = 0;		line[++lp] = nodes;		++L;		}	else if (nexus[a] == ')')		{		b = line[lp-1];		++R;		if (R==L)	break;		if (b<0 || b > 2*notu)	{			printf("\a\a\a\a\n");			printf("Yo Dillweed, you goofed on line 399\n");			exit(0);			}		++div2[b];		/* clade added */		--lp;		}	else	{							/* species found	*/		while (nexus[a+1]>='0' && nexus[a+1]<='9')			++a;		++div2[anc=line[lp]];		}	}free ((void *)line);return div2;}/* cladecountnexus - counts the number of clades in a nexus file string/* Requires: nexus - a string where parentheses give clades/* Returns: nodes - an integer giving the number of clades************************************************************************/int cladecountnexus (char *nexus){int	a, nodes, R, L;nodes=0;						/*  Use Left Parentheses to Identify Clade	*/R=L=a=0;						/*         New Clades and Nodes     	*/for (a=0; R<L || R==0; ++a)	{	if (nexus[a] == '(')	{	/*)*/		++nodes;		++L;		}	else if (nexus[a] == ')')		{		++R;		if (R==L)	break;		}	else	{							/* species found	*/		}	}return nodes;}/* patristicheight - gives the patristic distance between taxa and the node/*		Modified 6/17/03 to eliminate diversity array - that now is the first element of each node /* Requires:/*		tree: tree[i][1Én] gives the n members of node i; tree[i][0]=n;/*		clades: the number of clades;/*		notu: the number of taxa;/* Returns/*		ptht: Patristic distance from the base (= height)*******************************************************************************************************************************************/int* patristicheight(long **tree, int clades, int notu){int	c, d, sp, anc;int	*ptht;ptht=ivector(clades+notu);ptht[notu]=0;for (c=0; c<clades; ++c)	{	anc=c+notu;	for (d=1; d<=tree[c][0]; ++d)	{		sp=tree[c][d];		ptht[sp]=ptht[anc]+1;		}	}return ptht;}/* patristicdistance - gives the patristic distance between each species/* Requires:/*		tree: tree[i][1Én] gives the n members of node i; tree[i][0]=n;/*		clades: the number of clades;/*		notu: the number of taxa;/* Returns/*		pat: Patristic Distance matrix*******************************************************************************************************************************************/long **patristicdistance(long **tree, int clades, int notu){int		a, max, sp1, sp2;int		*ph;int 	**ancestors;long	**pat;ph=patristicheight(tree,clades,notu);max=maxiarray(ph,notu);		/* this gives the maximum number of ancestors for any particular species */ancestors=listancestors(tree,clades,notu);pat=lmatrix(notu,notu);/* because ancestors are listed from lowest [base] to highest, the ancestor lists are identical until divergence */for (sp1=0; sp1<notu-1; ++sp1)	{	while (ph[sp1]==0 && sp1<notu)	++sp1;	if (sp1>=notu)	break;	for (sp2=sp1+1; sp2<notu; ++sp2)	{		while (ph[sp2]==0 && sp2<notu)	++sp2;		if (sp2>=notu)	break;		/* a will give how far up the tree the last common ancestor is */		pat[sp1][sp2]=ph[sp1]+ph[sp2];		for (a=1; (ancestors[sp1][a]==ancestors[sp2][a] && (a<ancestors[sp1][0] && a<ancestors[sp2][0])); ++a)	{			/* the patristic distance now is the patristic height from that node for both */			if (ancestors[sp1][a]==ancestors[sp2][a])				pat[sp1][sp2]-=2;			}		pat[sp2][sp1]=pat[sp1][sp2];		}	}free_ivector(ph);free_imatrix(ancestors,notu,max+1);return pat;}/* patristicdissimilarity - gives the patristic distance between each species/* Requires:/*		tree: tree[i][1Én] gives the n members of node i; tree[i][0]=n;/*		bl: bl[i] gives the branch length for branch i;/*		clades: the number of clades;/*		notu: the number of taxa;/* Returns/*		ptdss: Patristic Distance matrix*******************************************************************************************************************************************/double **patristicdissimilarity(long **tree, long **chmatrix, int *bl, int clades, int notu, int nchars, int UNKNOWN, int INAP){int	a, b, max, sp1, sp2;int	*ptht;int **ancestors;double pd, x;double **ptdss, **sbl;ptht=patristicheight(tree,clades,notu);max=maxiarray(ptht,notu);		/* this gives the maximum number of ancestors for any particular species */ptdss=dmatrix(notu,notu);ancestors=listancestors(tree,clades,notu);sbl=dmatrix(notu,max+2);for (sp1=0; sp1<notu; ++sp1)	{	while (ptht[sp1]==0 && sp1<notu)	++sp1;	if (sp1>=notu)	break;	sbl[sp1][ptht[sp1]+1]=bl[sp1];	for (a=ptht[sp1]; a>0; --a)	sbl[sp1][a]=sbl[sp1][a+1]+bl[ancestors[sp1][a]];	}/* because ancestors are listed from lowest [base] to highest, the ancestor lists are identical until divergence */for (sp1=0; sp1<notu-1; ++sp1)	{	while (ptht[sp1]==0 && sp1<notu)	++sp1;	if (sp1>=notu)	break;	for (sp2=sp1+1; sp2<notu; ++sp2)	{		while (ptht[sp2]==0 && sp2<notu)	++sp2;		if (sp2>=notu)	break;		/* a will give how far up the tree the last common ancestor is */		pd=ptht[sp1]+ptht[sp2];		for (a=1; ancestors[sp1][a]==ancestors[sp2][a]; ++a)			if (ancestors[sp1][a]==ancestors[sp2][a])				/* the patristic distance now is the patristic height from that node for both */				pd-=2;		if (bl[sp1]==0)	pd=pd-1;		if (bl[sp2]==0)	pd=pd-1;		ptdss[sp1][sp2]=sbl[sp1][a]+sbl[sp2][a];		ptdss[sp2][sp2]=ptdss[sp1][sp2]=ptdss[sp1][sp2]/pd;		x=b=charraycomparable(chmatrix[sp1],chmatrix[sp2],nchars,UNKNOWN,INAP);		ptdss[sp2][sp2]=ptdss[sp1][sp2]=ptdss[sp1][sp2]/x;		}	}free_ivector(ptht);free_imatrix(ancestors,notu,max+1);free_dmatrix(sbl,notu,max+2);return ptdss;}/* Describes trees in terms of all members of a clade (i.e., no nodes listed). *//* Requires:	   tree - a matrix containing members of each node cl (with nodes given as supraspecific numbers);			tree[cl][0] is the diversity of the node - this will change from branches to cumulative richness;			the last two lines give the branch lengths (in species) of each branch;				the first line (tree[notu-1]) gives it for species;				the second line (tree[notu]) gives it for internal nodes;			tree will be returned in modified form;		clades - the number of clades;		notu - number of taxa in the tree;		maxsp - the highest number of a taxon in the tree (for cases where not all taxa are used);					this will be the htu number of the basal node.		Returns:		vtree - tree described as a Venn diagram	*******************************************************************************************************************************************/long **VennTree(long **tree, int clades, int notu, int maxsp){int	a, b, cl, f1, sp, dcl;long	**vtree;vtree=lmatrix(clades,notu+1);for (a=0; a<clades; ++a)	for (b=0; b<=tree[a][0]; ++b)	vtree[a][b]=tree[a][b];for (cl=clades-1; cl>=0; --cl)	{	for (f1=1; f1<=vtree[cl][0]; ++f1)	{		sp=vtree[cl][f1];		/* tally total diversity and cumulative membership */		if (sp>=maxsp)	{			dcl=sp-maxsp;			b=vtree[dcl][0]-1;			for (a=vtree[cl][0]; a>f1; --a)		vtree[cl][a+b]=vtree[cl][a];			for (a=f1; a<f1+vtree[dcl][0]; ++a)	vtree[cl][a]=vtree[dcl][1+a-f1];			vtree[cl][0]=vtree[cl][0]+vtree[dcl][0]-1;			f1=f1+vtree[dcl][0]-1;			}		}	for (f1=vtree[cl][0]+1; f1<=notu; ++f1)	vtree[cl][f1]=-1;	}return vtree;}/* VennTreePlus: Venn tree plus information about branch lengths at the end./* Describes trees in terms of all members of a clade (i.e., no nodes listed). *//* Requires:	   tree - a matrix containing members of each node cl (with nodes given as supraspecific numbers);			tree[cl][0] is the diversity of the node - this will change from branches to cumulative richness;			the last two lines give the branch lengths (in species) of each branch;				the first line (tree[notu-1]) gives it for species;				the second line (tree[notu]) gives it for internal nodes;			tree will be returned in modified form;		clades - the number of clades;		notu - number of taxa in the tree;		maxsp - the highest number of a taxon in the tree (for cases where not all taxa are used);					this will be the htu number of the basal node.		Returns:		vtree - tree described as a Venn diagram	*******************************************************************************************************************************************/long **VennTreePlus(long **tree, int clades, int notu, int maxsp){int	a, b, cl, f1, sp, dcl;long	**vtree;vtree=lmatrix(clades+3,notu+1);for (a=0; a<clades; ++a)	for (b=0; b<=tree[a][0]; ++b)	vtree[a][b]=tree[a][b];for (cl=clades-1; cl>=0; --cl)	{	for (f1=1; f1<=vtree[cl][0]; ++f1)	{		sp=vtree[cl][f1];		/* tally total diversity and cumulative membership */		if (sp>=maxsp)	{			dcl=sp-maxsp;			b=vtree[dcl][0]-1;			for (a=vtree[cl][0]; a>f1; --a)		vtree[cl][a+b]=vtree[cl][a];			for (a=f1; a<f1+vtree[dcl][0]; ++a)	vtree[cl][a]=vtree[dcl][1+a-f1];			vtree[cl][0]=vtree[cl][0]+vtree[dcl][0]-1;			f1=f1+vtree[dcl][0]-1;			}		}	for (f1=vtree[cl][0]+1; f1<=notu; ++f1)	vtree[cl][f1]=-1;	}for (sp=0; sp<notu; ++sp)	{	vtree[clades][sp]=tree[notu-1][sp];	vtree[clades+1][sp]=tree[notu][sp];	}vtree[clades+2][0]=clades;								/* just store this here: it will save tears later (2011-02-03)	*/return vtree;}/* VennTreePlus: Venn tree plus information about branch lengths at the end./* Describes trees in terms of all members of a clade (i.e., no nodes listed). *//* Requires:	   tree - a matrix containing members of each node cl (with nodes given as supraspecific numbers);			tree[cl][0] is the diversity of the node - this will change from branches to cumulative richness;			the last two lines give the branch lengths (in species) of each branch;				the first line (tree[notu-1]) gives it for species;				the second line (tree[notu]) gives it for internal nodes;			tree will be returned in modified form;		clades - the number of clades;		notu - number of taxa in the tree;		maxsp - the highest number of a taxon in the tree (for cases where not all taxa are used);					this will be the htu number of the basal node.		Returns:		vtree - tree described as a Venn diagram	*******************************************************************************************************************************************/long **VennTreePlusStrat(long **tree, int clades, int notu, int maxsp){int	a, b, cl, f1, sp, dcl;long	**vtree;vtree=lmatrix(clades+5,notu+1);for (a=0; a<clades; ++a)	for (b=0; b<=tree[a][0]; ++b)	vtree[a][b]=tree[a][b];for (cl=clades-1; cl>=0; --cl)	{	for (f1=1; f1<=vtree[cl][0]; ++f1)	{		sp=vtree[cl][f1];		/* tally total diversity and cumulative membership */		if (sp>=maxsp)	{			dcl=sp-maxsp;			b=vtree[dcl][0]-1;			for (a=vtree[cl][0]; a>f1; --a)		vtree[cl][a+b]=vtree[cl][a];			for (a=f1; a<f1+vtree[dcl][0]; ++a)	vtree[cl][a]=vtree[dcl][1+a-f1];			vtree[cl][0]=vtree[cl][0]+vtree[dcl][0]-1;			f1=f1+vtree[dcl][0]-1;			}		}	for (f1=vtree[cl][0]+1; f1<=notu; ++f1)	vtree[cl][f1]=-1;	}for (sp=0; sp<notu; ++sp)	{	vtree[clades][sp]=tree[notu-1][sp];	vtree[clades+1][sp]=tree[notu][sp];	vtree[clades+2][sp]=tree[notu+1][sp];	vtree[clades+3][sp]=tree[notu+2][sp];	}vtree[clades+4][0]=clades;								/* just store this here: it will save tears later (2011-02-03)	*/return vtree;}/* Describes trees in terms of all members of a clade (i.e., no nodes listed). *//* Requires:	   vtree - a matrix containing all members of each node cl;			tree[cl][0] is the diversity of the node - this will change from branches to cumulative richness;			the last two lines give the branch lengths (in species) of each branch;				the first line (tree[notu-1]) gives it for species;				the second line (tree[notu]) gives it for internal nodes;			tree will be returned in modified form;		clades - the number of clades;		notu - number of taxa in the tree;		maxsp - the highest number of a taxon in the tree (for cases where not all taxa are used);					this will be the htu number of the basal node.		Returns:		tree - tree described as a hierarchical diagram	*******************************************************************************************************************************************/long **VennTreetoTree(long **vtree, int notu, int maxsp, int clades){int	a, b, cl, f1, f2, f3, sp, lcl;long	**tree;tree=lmatrix(clades+1,notu+1);for (a=0; a<clades; ++a)	for (b=0; b<=vtree[a][0]; ++b)	tree[a][b]=vtree[a][b];for (cl=clades-1; cl>0; --cl)	{	sp=tree[cl][1];			/* find this species in lower clades and replace it with node  number	*/	for (lcl=cl-1; lcl>=0; --lcl)	{		for (f1=1; f1<=tree[lcl][0]; ++f1)	{			if (sp==tree[lcl][f1])	{	/* ancestral node found!	*/				tree[lcl][f1]=maxsp+cl;	/* replace first species with node number	*/				for (f2=2; f2<=tree[cl][0]; ++f2)	{					for (f3=f1+1; f3<=tree[lcl][0]; ++f3)	{						if (tree[cl][f2]==tree[lcl][f3])	{							for (f3=f3; f3<tree[lcl][0]; ++f3)								tree[lcl][f3]=tree[lcl][f3+1];	/* replace granddaughter	*/							tree[lcl][f3]=0;							--tree[lcl][0];		/* decrement diversity of lcl	*/							}	/* end removal of granddaughter otu from lcl	*/						}	/* end search of ancestral node for granddaughters	*/					}	/* end remaining daughter taxa for clade cl	*/				f1=tree[lcl][0];	/* terminate successful search	*/				}	/* end case where lcl is a ancestral	*/			}	/* end search of possible ancestral node	*/		}	/* end search of lower nodes	*/	}	/* end condensing of tree	*/return tree;}/* Find the last common ancestor of each species pair/* Requires:	   tree - a matrix containing members of each node cl (with nodes given as supraspecific numbers);			tree[cl][0] is the diversity of the node - this will change from branches to cumulative richness;			the last two lines give the branch lengths (in species) of each branch;				the first line (tree[notu-1]) gives it for species;				the second line (tree[notu]) gives it for internal nodes;			tree will be returned in modified form;		clades - the number of clades;		notu - number of taxa;		Returns:		lca - tree described as a Venn diagram	*******************************************************************************************************************************************/int **lastcommonancestormatrix(long **tree, int clades, int notu){int	a, sp1, sp2;int	**ancestors;int	**lca;lca=imatrix(notu,notu);clearimatrix(lca,notu,notu,-1);ancestors=listancestors(tree,clades,notu);/* because ancestors are listed from lowest [base] to highest, the ancestor lists are identical until divergence */for (sp1=0; sp1<notu-1; ++sp1)	{	/* skip species not in the tree */	while (ancestors[sp1][0]==-1 && sp1<(notu-1))	++sp1;	if (sp1>=(notu-1))	break;	for (sp2=sp1+1; sp2<notu; ++sp2)	{		/* skip species not in the tree */		while (ancestors[sp2][0]==-1 && sp2<notu)	++sp2;		if (sp2>=notu)	break;		for (a=0; ancestors[sp1][a]==ancestors[sp2][a]; a=a)	++a;		lca[sp1][sp2]=lca[sp2][sp1]=a;		}	}free_imatrix(ancestors,notu,clades+1);return lca;}/* List each node to which a species belongs/* Requires:	   tree - a matrix containing members of each node cl (with nodes given as supraspecific numbers);			tree[cl][0] is the diversity of the node - this will change from branches to cumulative richness;			the last two lines give the branch lengths (in species) of each branch;				the first line (tree[notu-1]) gives it for species;				the second line (tree[notu]) gives it for internal nodes;			tree will be returned in modified form;		clades - the number of clades;		notu - number of taxa;		Returns:		Ancestors - All the nodes from the base to the last common ancestor of a species	*******************************************************************************************************************************************/int **listancestors(long **tree, int clades, int notu){int  b, c, d, m, max, sp;int	 *ptht;long **vtree;int  **ancestors;ptht=patristicheight(tree,clades,notu);max=maxiarray(ptht,notu);ancestors=imatrix(notu,max+2);clearimatrix(ancestors, notu, max+2, -1);for (sp=0; sp<notu; ++sp)	ancestors[sp][0]=0;/* this routine looks useless	*/m=RAND_MAX;for (b=1; b<=tree[0][0]; ++b)	if (tree[0][b]<m)	m=tree[0][b];--m;									/* this gives the htu number of the basal node	*//*vtree=lmatrix(clades,notu);/*equallmatrix(vtree,tree,clades,notu);	*/vtree=VennTree(tree,clades,notu,notu);/* make a list of all nodes that include species */for (c=0; c<clades; ++c)	{	for (d=1; d<=vtree[c][0]; ++d)	{		sp=vtree[c][d];		ancestors[sp][++ancestors[sp][0]]=c+notu;		}	}free_lmatrix(vtree,clades,notu+1);free_ivector(ptht);return ancestors;}/* List the node to which a species belongs/* Requires:	   tree - a matrix containing members of each node cl (with nodes given as supraspecific numbers);			tree[cl][0] is the diversity of the node - this will change from branches to cumulative richness;			the last two lines give the branch lengths (in species) of each branch;				the first line (tree[notu-1]) gives it for species;				the second line (tree[notu]) gives it for internal nodes;			tree will be returned in modified form;		clades - the number of clades;		notu - number of taxa;		Returns:		ancestors - The immediate ancestor of a species	*******************************************************************************************************************************************/int *listancestor(long **tree, int clades, int notu){int  c,d,sp;int  *ancestors;ancestors=ivector(notu+clades);/* make a list of all nodes that include species */for (c=0; c<clades; ++c)	{	for (d=1; d<=tree[c][0]; ++d)	{		sp=tree[c][d];		ancestors[sp]=c+notu;		}	}return ancestors;}/* Describes trees in terms of all members of a clade (i.e., no nodes listed). *//* Requires:   tree - a matrix containing members of each node cl (with nodes given as supraspecific numbers);		tree[cl][0] is the diversity of the node - this will change from branches to cumulative richness;		the last two lines give the branch lengths (in species) of each branch;			the first line (tree[notu-1]) gives it for species;			the second line (tree[notu]) gives it for internal nodes;		tree will be returned in modified form;	notu - number of taxa;	nodes - the number of clades;*******************************************************************************************************************************************/long **clademember(long **tree, int notu, int nodes){int	a, b, cl, f1, sp, dcl;for (cl=nodes-1; cl>=0; --cl)	{	for (f1=1; f1<=tree[cl][0]; ++f1)	{		sp=tree[cl][f1];		/* tally total diversity and cumulative membership */		if (sp>=notu)	{			dcl=sp-notu;			b=tree[dcl][0]-1;			for (a=tree[cl][0]; a>f1; --a)		tree[cl][a+b]=tree[cl][a];			for (a=f1; a<f1+tree[dcl][0]; ++a)	tree[cl][a]=tree[dcl][1+a-f1];			tree[cl][0]=tree[cl][0]+tree[dcl][0]-1;			f1=f1+tree[dcl][0]-1;			}		}	for (f1=tree[cl][0]+1; f1<notu; ++f1)	tree[cl][f1]=-1;	}return tree;}/* cladecountbytaxa - takes a matrix of relationships and counts the clades;/* Requires:   tree - a matrix containing members of each node cl (with nodes given as supraspecific numbers);		tree[cl][0] is the diversity of the node;   taxa - the number of notu;      returns: cl - the number of clades*******************************************************************************************************************************************/int	cladecountbytaxa(long **tree, int notu){int	a;int	sp, notus=0, cl=0;for (cl=0; notus<notu; ++cl)	{	for (a=1; a<=tree[cl][0]; ++a)	{		sp=tree[cl][a];		if (sp<notu)	++notus;		if (notus==notu)	{			a=1+tree[cl][0];			}		}	}return cl;}/* cladecount - takes a matrix of relationships and counts the clades;/* Requires:   tree - a matrix containing members of each node cl (with nodes given as supraspecific numbers);		tree[cl][0] is the diversity of the node;*******************************************************************************************************************************************/int	cladecount(long **tree){int	cl=0;for (cl=0; tree[cl][0]>0; cl=cl)	++cl;return cl;}/* cladesinclades - takes a matrix of relationships and returns a tree giving only descendant clades;/* Requires:   tree - a matrix containing members of each node cl (with nodes given as supraspecific numbers);		tree[cl][0] is the diversity of the node;	clades - the number of clades	notus - the number of otus*******************************************************************************************************************************************/long **cladesinclades(long **tree, int clades, int notu){int	a, b, cl, f1, f2, sp, dcl;long	**cltree;cltree=lmatrix(clades,clades+1);for (a=0; a<clades; ++a)	for (b=0; b<=tree[a][0]; ++b)	cltree[a][b]=tree[a][b];/* eliminate species from cltree */for (cl=clades-1; cl>=0; --cl)	{	for (f1=1; f1<=cltree[cl][0]; ++f1)	{		sp=cltree[cl][f1];		while (sp<notu && f1<=cltree[cl][0])	{			for (b=f1+1; b<=cltree[cl][0]; ++b)	cltree[cl][b-1]=cltree[cl][b];		/* erase otu 				*/			cltree[cl][cltree[cl][0]]=-1;											/* erase otu 				*/			--cltree[cl][0];														/* decrease clade richness	*/			if (f1<=cltree[cl][0])	sp=cltree[cl][f1];								/* get next descendant		*/			}		}	/* finish node */	}		/* finish tree */	/* now, "sink" daughter nodes into ancestral nodes */for (cl=clades-1; cl>=0; --cl)	{	while (cltree[cl][0]==0)	--cl;	b=cltree[cl][0];	for (f1=1; f1<=b; ++f1)	{				cltree[cl][f1]-=notu;														/* convert to clade number	*/		dcl=cltree[cl][f1];															/* daughter clade number 	*/		for (f2=1; f2<=cltree[dcl][0]; ++f2)	{			cltree[cl][++cltree[cl][0]]=cltree[dcl][f2];							/* add granddaughter		*/			}	/* add granddaughter node as a node number */		}	/* finish node cl */	}	/* finish tree */		/* tally total diversity and cumulative membership */return cltree;}/* taxaintree - takes a matrix of relationships and counts the clades;/* Requires:   tree - a matrix containing members of each node cl (with nodes given as supraspecific numbers);		tree[cl][0] is the diversity of the node;*******************************************************************************************************************************************/int	taxaintree(long **tree, int notu){int	a, sp, cl, tx=0;for (cl=0; tree[cl][0]>0; ++cl)	{	for (a=1; a<=tree[cl][0]; ++a)	{		if ((sp=tree[cl][a])<notu)	++tx;		}	}return tx;}/* treesymFould - takes a tree and determines the Fould Robinson symmetry.  /* Requires:   tree - a matrix containing members of each node cl (with nodes given as supraspecific numbers);		tree[cl][0] is the diversity of the node;	notu - number of taxa in treereturns:	symmetry: 1.0 if perfectly symmetrical, 0.0 if perfectly pectinate**************************************************************************************************************************************/double treesymFould(long **tree, int notu){int    j;int    sp, sp2, nd;int    clades, htus;double symmetry, denom, Polytomies;clades=cladecount(tree);symmetry = denom = Polytomies = 0.0f;for (nd=0; nd<clades; ++nd)	{	if (tree[nd][0]>2)	{		++Polytomies;		htus=0;		for (j=1; j<=tree[nd][0]; ++j)	if (tree[nd][j]>=notu)	++htus;		if (htus>=2)	{			denom = denom+1;			symmetry = symmetry+1;			}		else if (htus==1)	denom = denom+1;		}	else if (tree[nd][0] == 2)	{		sp = tree[nd][1];		sp2 = tree[nd][2];		/* if two clades, then note that it is balanced	*/		if (sp >=notu && sp2 >=notu)	{			symmetry = symmetry+1;			denom = denom+1;			}		/* if a clade and a species, then note that it is unbalanced	*/		else if ((sp>=notu && sp2<notu) || (sp<notu && sp2>=notu))			denom = denom+1;		}	}if (denom>0)	symmetry = symmetry / denom;else			symmetry = 0.0f;return symmetry;}/* treesymColless - takes a tree and determines the Colless symmetry.  /*	see Heard (1992 Evolution p. 1819)/* Requires:   tree - a matrix containing members of each node cl (with nodes given as supraspecific numbers);		tree[cl][0] is the diversity of the node;	notu - number of taxa in tree	notu - number of taxa in treereturns:	symmetry: 0.0 if perfectly symmetrical, 1.0 if perfectly pectinate**************************************************************************************************************************************/double treesymColless(long **tree, int notu){int		b, i, j, m, s;int		sp, sp2, nd;int		clades, htus;int		dc[25];double 	symmetry, denom, Polytomies;long	**vtree;clades=cladecount(tree);/*denom=clades*(clades-1);				/*this is (n-1)*(n-2) in Colless' equation								*/denom=((double) (notu-1)*(notu-2))/2;	/* note: this needs to be based on number of taxa, not number of nodes!	*/		m=RAND_MAX;	/**//*m=-1;	/**/for (b=1; b<=tree[0][0]; ++b)	if (tree[0][b]<m && tree[0][b]>notu)	m=tree[0][b];	/**//*	if (tree[0][b]>m)	m=tree[0][b];	/**/--m;									/* this gives the htu number of the basal node	*/vtree=VennTree(tree,clades,notu,m);symmetry = Polytomies = 0.0f;for (nd=0; nd<clades; ++nd)	{	if (tree[nd][0]>2)	{		htus=0;		for (j=1; j<=tree[nd][0]; ++j)	if (tree[nd][j]>=notu)	++htus;		if (htus==1)			for (j=1; j<=tree[nd][0]; ++j)	{				if ((sp=tree[nd][j])>=notu)	{					symmetry+=(tree[nd][0]-1)*(vtree[sp-notu][0]-1);	/* add difference between clade & all species attached to polytomy */					j=tree[nd][0];	/* end loop now */					}				}		if (htus>=2)	{			s=i=0;			/* tally the richness of each clade */			for (j=1; j<=tree[nd][0] && i<htus; ++j)	{				sp=tree[nd][j];				if (sp>notu)	{					dc[i]=vtree[sp-notu][0];					s+=(tree[nd][0]-htus)*(dc[i]-1);	/* add difference between clade and all species attached to polytomy */					++i;					}				}			/* now tally all of the differences in balance */			for (i=0; i<htus-1; ++i)	{				for (j=i+1; j<htus; ++j)	{					if (dc[i]>=dc[j])	s+=dc[i]-dc[j];					else				s+=dc[j]-dc[i];					}				}			symmetry += ((double) s)/((double) ((htus*htus)-htus)/2);	/* this gives the average difference in clade richness */			}		}	else if (tree[nd][0] == 2)	{		sp = tree[nd][1];		sp2 = tree[nd][2];		s=0;		if (sp >=notu && sp2 >=notu)	{			s=vtree[sp-notu][0]-vtree[sp2-notu][0];			}		else if (sp>=notu && sp2<notu)			s=vtree[sp-notu][0]-1;		else if (sp<notu && sp2>=notu)			s=vtree[sp2-notu][0]-1;		if (s<0)	s*=-1;		symmetry+=s;		}	}if (denom>0)	symmetry = symmetry / denom;else			symmetry = 0.0f;/*free_lmatrix(vtree,clades,notu);*/return symmetry;}char **nodenaming(long **tree, int clades, int notu, long *bl, char **taxonnames, int zed){#define ADD	"-clade"int b, c, m;int anc, cl, sp;long **vtree;char **nodenames;nodenames=cmatrix(clades,1+(2*zed));m=RAND_MAX;for (b=1; b<=tree[0][0]; ++b)	if (tree[0][b]<m)	m=tree[0][b];--m;									/* this gives the htu number of the basal node	*/vtree=VennTree(tree,clades,notu,m);/* find most distant relatives and trees and choose those names 		*//* copy the first name to nodenames; add '-' or '+'; add second name	 */for (cl=0; cl<clades; ++cl)	{	/* first look for any ancestors */	anc=-1;	for (b=1; b<tree[cl][0]; ++b)	{		sp=tree[cl][b];		if (bl[sp]==0)	{			anc=sp;			b=tree[cl][0];			}		}	if (anc==-1)	{		b=vtree[cl][1];		strcpy(nodenames[cl],taxonnames[b]);		if (vtree[cl][0]>2)	strcat(nodenames[cl],"-");		/* if two taxa tree, then call it A+B */		else				strcat(nodenames[cl],"+");		c=vtree[cl][0];		b=vtree[cl][c];		strcat(nodenames[cl],taxonnames[b]);		}	/* if ancestor found, name the clade for it */	else	{		strcpy(nodenames[cl],taxonnames[anc]);		strcat(nodenames[cl],ADD);		}	}free_lmatrix(vtree,clades,notu);return nodenames;}/* nexustotree - converts a nexus tree format to a matrix of phylogenetic information. *//* Requires:/*		dendogram - the nexus tree string;/*		notu - the number of taxa;/* Returns:/*		tree - a matrix of phylogenetic information/*			tree[node=x][0] - number of taxa in node x;/*			tree[node=x][1Étree[x][0]] - taxa in node x;*******************************************************************************************************************************************/double *tree_draw (char *nexusfile, long ** tree, int notu, int clades){int		a, b, species, sc, sp, cl, max, htu;double	*ordinate;char	*nexus;FILE	*infile;b=getlongestnameinfile(nexusfile,1);nexus = cvector(b+1);/*nexus = cvector(6*notu);*/infile = fopen(nexusfile,"r");fscanf(infile,"%s",nexus);fclose(infile);/* first find diversity of each clade *//* this will be used to allocate memory for tree */ordinate=dvector(notu+clades);max=1;for (a=0; max<=notu; ++a)	{	/* ',' signifies a new member of a clade coming up next */	while (nexus[a] == ',' || (nexus[a] == '(' || nexus[a] == ')'))	++a;	species = nexus[a]-'0';	while (nexus[a+1]>='0' && nexus[a+1]<='9')	{		++a;		species = (10*species)+nexus[a]-'0';		}	ordinate[species-1]=max;	++max;	}for (cl=(clades-1); cl>=0; --cl)	{	htu=cl+notu;	for (sc=1; sc<=tree[cl][0]; ++sc)	{		sp=tree[cl][sc];		ordinate[htu]+=ordinate[sp];		}	ordinate[htu]/=((double) tree[cl][0]);	}return ordinate;}/* nexustotree - converts a nexus tree format to a matrix of phylogenetic information. *//* Requires:/*		dendogram - the nexus tree string;/*		notu - the number of taxa;/* Returns:/*		tree - a matrix of phylogenetic information/*			tree[node=x][0] - number of taxa in node x;/*			tree[node=x][1Étree[x][0]] - taxa in node x;*******************************************************************************************************************************************/double *tree_draw_anc (char *nexusfile, long ** tree, int notu, int clades, int *ancestral){int		a, b, species, sc, sp, cl, max, htu;double	*ordinate;char	*nexus;FILE	*infile;b=getlongestnameinfile(nexusfile,1);nexus = cvector(b+1);/*nexus = cvector(6*notu);*/infile = fopen(nexusfile,"r");fscanf(infile,"%s",nexus);fclose(infile);/* first find diversity of each clade *//* this will be used to allocate memory for tree */ordinate=dvector(notu+clades);max=1;for (a=0; max<=notu; ++a)	{	/* ',' signifies a new member of a clade coming up next */	while (nexus[a] == ',' || (nexus[a] == '(' || nexus[a] == ')'))	++a;	species = nexus[a]-'0';	while (nexus[a+1]>='0' && nexus[a+1]<='9')	{		++a;		species = (10*species)+nexus[a]-'0';		}	ordinate[species-1]=max;	++max;	}for (cl=(clades-1); cl>=0; --cl)	{	htu=cl+notu;	for (sc=1; sc<=tree[cl][0]; ++sc)	{		sp=tree[cl][sc];		if (ancestral[sp]>0)	ordinate[htu]+=(ordinate[sp]/((double) tree[cl][0]));		/* if ancestor is sampled, then just set ordinate at ancestor	*/		else	{			ordinate[htu]=ordinate[sp];			sc=tree[cl][0];			}		}	}return ordinate;}/* added 2014-01-05	*//* routine to take tree evolved from bifurcating processes and turn ancestors into grandparents so we have a bifurcating tree	*//* this will alter branch lengths so that the new clades have BL's of 1, too.NOTE:	tree[notu-1][0Énotu-1] gives branch lengths of the observed taxa	tree[notu][0Éclades-1] gives branch lengths of the clades;*************************************************************************************************/void ConvertTreeToBifurcating(long **tree, int notu){int c, cl, acl, fx, i;cl=0;for (c=0; c<(notu-1); ++c)	if (tree[c][0]>=2)	++cl;fx=notu-2;for (c=(cl-1); c>=0; --c)	{	if (tree[c][0]==2)	{		for (i=0; i<3; ++i)	tree[fx][i]=tree[c][i];		tree[notu][fx]=tree[notu][c];				/* now turn notu+c into notu+fx in the ancestral clade	*/		for (acl=(c-1); acl>=0; --acl)	{			for (i=1; i<=tree[acl][0]; ++i)	{				if (tree[acl][i]==(notu+c))	{					tree[acl][i]=notu+fx;					i=tree[acl][0]+1;					acl=0;					}	/* end loop after finding old clade number	*/				}	/* end search for old clade number	*/			}	/* end search for ancestral clade	*/		--fx;		}	if (tree[c][0]==3)	{		tree[fx][0]=2;		tree[fx][1]=tree[c][2];		tree[fx][2]=tree[c][3];		tree[notu][fx]=1;		tree[c][0]=2;		tree[c][2]=fx+notu;		tree[c][3]=-1;		--fx;		++c;		}	}/*for (c=0; fx<ply && c<(notu-1); ++c)	{	if (tree[c][0]>2)	{		tree[cl][0]=2;		tree[cl][1]=tree[c][2];		tree[cl][2]=tree[c][3];		tree[c][0]=2;		tree[c][2]=notu+cl;		tree[notu][cl]=1;		++cl;		}	}	*/}void convertApeToNexus(long *ape, long **nexus, int notu, int nodes){int c, n, s;for (c=0; c<nodes; ++c)	nexus[c][0]=0;for (s=0; s<notu+nodes; ++s)	{	if ((c=ape[s])>=0)	{		++nexus[n=(c-notu)][0];		nexus[n][nexus[n][0]]=s;		}	}}