/* Routines for disparity analyses.  /*	Peter Wagner	04/13/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */#define disparityanalysis#include "disparityanalyses.h"#include "compatibility_functions.h"#include "matrixanalysis.h"#include "matrixchange.h"#include "matrixreading.h"#include "memory.h"#include "minmax.h"#include "MonteCarloPhylogenyFunctions.h"#include "probability.h"#include "sort.h"#include "stratocladistics.h"#include "tree_read.h"#include <stdlib.h>#include <stdio.h>#include <time.h>#include <math.h>#include <string.h>/* RawDist - returns a matrix giving number of differing characters		and the number of comparable characters		/*/* Requires: /*		mat: species X character matrix of character states/*		notu: number of species/*		nchars: number of characters***************************************************************************************/long **RawDist(long **mat, int notu, int nchars, int UNKNOWN, int INAP){int sp1, sp2, ch;long	**DistMat;DistMat=lmatrix(notu,notu);for (sp1=0; sp1<notu-1; ++sp1)	{	for (sp2=sp1+1; sp2<notu; ++sp2)	{		DistMat[sp1][sp2]=DistMat[sp2][sp1]=0;		for (ch=0; ch<nchars; ++ch)	{			while (ch<nchars && ((mat[sp1][ch]==UNKNOWN || mat[sp1][ch]==INAP) || (mat[sp2][ch]==UNKNOWN || mat[sp2][ch]==INAP)))	++ch;			if (ch>=nchars)	break;			if (mat[sp1][ch]!=mat[sp2][ch])	++DistMat[sp1][sp2];				++DistMat[sp2][sp1];			}		}	}return DistMat;}/* PhenDis - returns a matrix giving phenetic dissimilarity bn. species/*/* Requires: /*		Dmat: species X species matrix of raw differences & comparable states/*		notu: number of species***************************************************************************************/double **PhenDist(long **DMat, int notu){int 	sp1, sp2;double	x,y;double	**PD;PD=dmatrix(notu,notu);for (sp1=0; sp1<notu-1; ++sp1)	{	for (sp2=sp1+1; sp2<notu; ++sp2)	{		x=DMat[sp1][sp2];		y=DMat[sp2][sp1];		if (y==0)	y=1;		PD[sp1][sp2]=PD[sp2][sp1]=x/y;		}	}return PD;}/* PhenDis - returns a matrix giving phenetic dissimilarity bn. species/*/* Requires: /*		Dmat: species X species matrix of raw differences & comparable states/*		notu: number of species***************************************************************************************/double **PhDfromData(long **mat, int notu, int nchars, int UNKNOWN, int INAP){int 	a, b, c, d;int 	sp1, sp2, ch, c1, c2;int		poly1[10], poly2[10];double	denom;double	**PD;PD=dmatrix(notu,notu);for (sp1=0; sp1<notu-1; ++sp1)	{	for (sp2=sp1+1; sp2<notu; ++sp2)	{		denom=PD[sp1][sp2]=PD[sp2][sp1]=0;		for (ch=0; ch<nchars; ++ch)	{			while (ch<nchars && ((mat[sp1][ch]==UNKNOWN || mat[sp1][ch]==INAP) || (mat[sp2][ch]==UNKNOWN || mat[sp2][ch]==INAP)))	++ch;			if (ch>=nchars)	break;			/* routine for two normal species */			if (mat[sp1][ch]!=mat[sp2][ch] && (mat[sp1][ch]>=0 && mat[sp2][ch]>=0))	++PD[sp1][sp2];			/* routine for two species with polymorphic codes */			else if (mat[sp1][ch]<0 && mat[sp2][ch]<0)	{				for (a=0; a<10; ++a)	poly1[a]=poly2[a]=-1;				a=mat[sp1][ch];				b=0;				while(abs(a)>0)	{					poly1[b]=abs(a%10);					a/=10;					++b;					}				a=mat[sp2][ch];				c=0;				while(abs(a)>0)	{					poly2[c]=abs(a%10);					a/=10;					++c;					}				a=0;				/* search through polymorphs to see if states match */				for (c1=0; c1<b; ++c1)	{					for (c2=0; c2<c; ++c2)	{						if (poly1[c1]==poly2[c2])	{							++a;							c2=c;							}	/* end tallying of match */						}	/* end search of polymorphs of second character */					}	/* end search of polymorphs of first character */								if (b>c)	PD[sp1][sp2]+=(1-((double) a)/((double) b));				else		PD[sp1][sp2]+=(1-((double) a)/((double) c));				}	/* end routine for two polymorphic species */			/* routine for one species with polymorphic codes */			else if (mat[sp1][ch]<0)	{				for (a=0; a<10; ++a)	poly1[a]=-1;				a=mat[sp1][ch];				b=0;					/* number of states that state 1 will have */				while(abs(a)>0)	{					poly1[b]=abs(a%10);					a/=10;					++b;					}				a=0;				/* search through polymorphs to see if states match */				for (c1=0; c1<b; ++c1)	{					if (poly1[c1]==(d=mat[sp2][ch]))	{						a=1;						c1=b;						}	/* end tallying of match */					}	/* end search of polymorphs of first character */								PD[sp1][sp2]+=1-((double) a)/((double) b);				}	/* end routine for two polymorphic species */			/* routine for one species with polymorphic codes */			else if (mat[sp2][ch]<0)	{				for (a=0; a<10; ++a)	poly2[a]=-1;				a=mat[sp2][ch];				c=0;					/* number of states that state 2 will have */				while(abs(a)>0)	{					poly2[c]=abs(a%10);					a/=10;					++c;					}				a=0;				/* search through polymorphs to see if states match */				for (c1=0; c1<c; ++c1)	{					if (poly2[c1]==(d=mat[sp1][ch]))	{						a=1;						c1=c;						}	/* end tallying of match */					}	/* end search of polymorphs of first character */								PD[sp1][sp2]+=(1-((double) a)/((double) c));				}	/* end routine for two polymorphic species */			++denom;			}		if (denom==0)	denom=1;		PD[sp1][sp2]=PD[sp2][sp1]=(PD[sp1][sp2]/denom);		}	}return PD;}/* PhenDis - returns a matrix giving phenetic dissimilarity bn. species/*/* Requires: /*		Dmat: species X species matrix of raw differences & comparable states/*		notu: number of species***************************************************************************************/double **PhDfromDataPlus(long **mat, long *type, int weight, int notu, int nchars, int UNKNOWN, int INAP){int 	a, b, c, d;int 	sp1, sp2, ch, c1, c2, mn, mx;int		poly1[10], poly2[10];int		*states;double	denom;double	**PD;states=ivector(nchars);for (ch=0; ch<nchars; ++ch)	{	mn=MAXRAND;	mx=-1*MAXRAND;		for (sp1=0; sp1<notu; ++sp1)	{		if (mat[sp1][ch]!=UNKNOWN && mat[sp1][ch]!=INAP)	{			if (mat[sp1][ch]<mn)	mn=mat[sp1][ch];			if (mat[sp1][ch]>mx)	mx=mat[sp1][ch];			}		}			states[ch]=1+(mx-mn);	}PD=dmatrix(notu,notu);for (sp1=0; sp1<notu-1; ++sp1)	{	for (sp2=sp1+1; sp2<notu; ++sp2)	{		denom=PD[sp1][sp2]=PD[sp2][sp1]=0;		for (ch=0; ch<nchars; ++ch)	{			while (ch<nchars && ((mat[sp1][ch]==UNKNOWN || mat[sp1][ch]==INAP) || (mat[sp2][ch]==UNKNOWN || mat[sp2][ch]==INAP)))	++ch;			if (ch>=nchars)	break;			/* routine for two normal species */			if (mat[sp1][ch]!=mat[sp2][ch] && (mat[sp1][ch]>=0 && mat[sp2][ch]>=0))	{				if (type[ch]==1)	++PD[sp1][sp2];				else	{					if (weight==0)	PD[sp1][sp2]+=abs(mat[sp1][ch]-mat[sp2][ch]);					else						PD[sp1][sp2]+=abs(mat[sp1][ch]-mat[sp2][ch])/((double) states[ch]-1);					}				}			/* routine for two species with polymorphic codes */			else if (mat[sp1][ch]<0 && mat[sp2][ch]<0)	{				for (a=0; a<10; ++a)	poly1[a]=poly2[a]=-1;				a=mat[sp1][ch];				b=0;				while(abs(a)>0)	{					poly1[b]=abs(a%10);					a/=10;					++b;					}				a=mat[sp2][ch];				c=0;				while(abs(a)>0)	{					poly2[c]=abs(a%10);					a/=10;					++c;					}				a=0;				/* search through polymorphs to see if states match */				for (c1=0; c1<b; ++c1)	{					for (c2=0; c2<c; ++c2)	{						if (poly1[c1]==poly2[c2])	{							++a;							c2=c;							}	/* end tallying of match */						}	/* end search of polymorphs of second character */					}	/* end search of polymorphs of first character */								if (b>c)	PD[sp1][sp2]+=(1-((double) a)/((double) b));				else		PD[sp1][sp2]+=(1-((double) a)/((double) c));				}	/* end routine for two polymorphic species */			/* routine for one species with polymorphic codes */			else if (mat[sp1][ch]<0)	{				for (a=0; a<10; ++a)	poly1[a]=-1;				a=mat[sp1][ch];				b=0;					/* number of states that state 1 will have */				while(abs(a)>0)	{					poly1[b]=abs(a%10);					a/=10;					++b;					}				a=0;				/* search through polymorphs to see if states match */				for (c1=0; c1<b; ++c1)	{					if (poly1[c1]==(d=mat[sp2][ch]))	{						a=1;						c1=b;						}	/* end tallying of match */					}	/* end search of polymorphs of first character */								PD[sp1][sp2]+=1-((double) a)/((double) b);				}	/* end routine for two polymorphic species */			/* routine for one species with polymorphic codes */			else if (mat[sp2][ch]<0)	{				for (a=0; a<10; ++a)	poly2[a]=-1;				a=mat[sp2][ch];				c=0;					/* number of states that state 2 will have */				while(abs(a)>0)	{					poly2[c]=abs(a%10);					a/=10;					++c;					}				a=0;				/* search through polymorphs to see if states match */				for (c1=0; c1<c; ++c1)	{					if (poly2[c1]==(d=mat[sp1][ch]))	{						a=1;						c1=c;						}	/* end tallying of match */					}	/* end search of polymorphs of first character */								PD[sp1][sp2]+=(1-((double) a)/((double) c));				}	/* end routine for two polymorphic species */			++denom;			}		if (denom==0)	denom=1;		PD[sp1][sp2]=PD[sp2][sp1]=(PD[sp1][sp2]/denom);		}	}free_ivector(states);return PD;}/* PhD - Returns the phenetic distance between two species/* Requires:/*		sp1: species 1's characters/*		sp2: species 2's characters/*		nchars: # characters/*		UNKNOWN: number for unknown characters/*		INAP: number for inapplicable characters/*/* Returns:/*		pd: proportion of characters that differ***************************************************************************************/double PhD(long *sp1, long *sp2, int nchars, int UNKNOWN, int INAP){int		ch;double	pd=0, denom=0;for (ch=0; ch<nchars; ++ch)	{	while (ch<nchars && ((sp1[ch]==UNKNOWN || sp1[ch]==INAP) || (sp2[ch]==UNKNOWN || sp2[ch]==INAP)))		++ch;	if (ch>=nchars)	break;	if (sp1[ch]!=sp2[ch])	++pd;	++denom;	}if (denom==0)	denom=1;pd=pd/denom;return pd;}/*Function returning the similarities among characters (see Oâ€™Keefe & Wagner 2001 Syst. Biol.) 	given a compatibility matrix.Needs:	comatrix: binary matrix, such as a char x char compatibility matrix, 		with 1 = compatible and 0 = incompatible	n: number of characters*****************************************************************************/double **binarydis(unsigned long **matrix, int n){int		i, j;double	x, nn;double	**m;m=dmatrix(n,n);nn=n-1;for (i=0; i<n-1; ++i)	{	m[i][i]=0;	for (j=i+1; j<n; ++j)	{		x=matrix[i][j];		x=x/n;		m[i][j]=x;		m[j][i]=m[i][j]=1-m[i][j];		}	}return m;}/*Function returning the similarities among characters (see Oâ€™Keefe & Wagner 2001 Syst. Biol.) 	given a compatibility matrix.Needs:	comatrix: binary matrix, such as a char x char compatibility matrix, 		with 1 = compatible and 0 = incompatible	n: number of characters*****************************************************************************/double **propshared(unsigned long **matrix, int n){int		i, j;double	x;double	**m;m=dmatrix(n,n);for (i=0; i<n-1; ++i)	{	for (j=i; j<n; ++j)	{		x=matrix[i][j];		x=x/n;		m[i][j]=x;		m[j][i]=m[i][j]=1-m[i][j];		}	}return m;}double *bootstrapdisparity(double **dmat, long *present, int notu, int reps, double EB){int a, b, c, r, sp1, sp2;int comps;double	*booted, *results;comps=((notu*notu)-notu);  booted=dvector(reps);for (r=0; r<reps; ++r)	{	for (c=0; c<comps; ++c)	{		a=b=(int)((double)rand() / ((double)MAXRAND + 1) * (double) notu);		sp1=present[a];		while (b==a)	{			b=(int)((double)rand() / ((double)MAXRAND + 1) * (double) notu);			sp2=present[b];			}		booted[r]+=dmat[sp1][sp2];		}	booted[r]/=((double) comps);	}booted=dshellsort_inc(booted,comps);results=dvector(3);if (comps%2==1)	{	results[0]=booted[(comps/2)];	c=(0.5-(EB/2))*comps;	results[1]=booted[c];	c=(0.5+(EB/2))*comps;	results[2]=booted[c];	}else	{	results[0]=(booted[(comps/2)]+booted[(comps/2)-1])/2;	c=(0.5-(EB/2))*comps;	results[1]=(booted[c]+booted[c+1]);	c=(0.5+(EB/2))*comps;	results[2]=(booted[c]+booted[c+1]);	}			free_dvector(booted);return results;}double *wholecladedisparitytime(double **PWDis, int notu, long **ranges, int onset, int term){int	s, t, s1, s2, sp1, sp2;int quar1=0, quar2=1, quar3=2, cog=3;double	x;double *accumdisp, *reldisp, *sumdisp;int	*rich, **evolved;double *results;accumdisp=dvector((term-onset)+1);reldisp=dvector((term-onset)+1);sumdisp=dvector((term-onset)+1);rich=ivector((term-onset)+1);evolved=imatrix((term-onset)+1,notu);results=dvector(5);cleardvector(results,5,-1);/* find which species appear by which "stage"	*/for (s=0; s<notu; ++s)	{	for (t=ranges[s][0]; t<=term; ++t)	{		evolved[t][rich[t]]=s;	/* cummulative taxa	*/		++rich[t];				/* cummulative richness	*/		}	}for (t=onset; t<=term; ++t)	{	for (s1=0; s1<(rich[t]-1); ++s1)	{		sp1=evolved[t][s1];					/* first species	*/		for (s2=s1+1; s2<rich[t]; ++s2)	{			sp2=evolved[t][s2];				/* second species	*/			accumdisp[t]+=PWDis[sp1][sp2];	/* sum pairwise dissimilarities	*/			}		}	/* now, get average	*/	if (rich[t]>1)	accumdisp[t]/=(((double) ((rich[t]*rich[t])-rich[t]))/2);	else			accumdisp[t]=0.0f;	}/* reset disparity to 1.0 for all comparisons	*/for (t=onset; t<=term; ++t)	{	reldisp[t]=accumdisp[t]/accumdisp[term];	if (results[quar1]==-1 && reldisp[t]>=0.25)	results[quar1]=((double) t)/((double) term);	if (results[quar2]==-1 && reldisp[t]>=0.50)	results[quar2]=((double) t)/((double) term);	if (results[quar3]==-1 && reldisp[t]>=0.75)	results[quar3]=((double) t)/((double) term);		if (t==onset)	sumdisp[t]=reldisp[t];	else			sumdisp[t]=sumdisp[t-1]+reldisp[t];	}x=sumdisp[term]/2;for (t=onset; t<term; ++t)	{	if (sumdisp[t]<x && sumdisp[t+1]>=x)	results[cog]=((double) (t+1))/((double) term);	}free_ivector(rich);free_imatrix(evolved,(term-onset)+1,notu);free_dvector(accumdisp);free_dvector(reldisp);free_dvector(sumdisp);return(results);}/*	results[0]: species after 25% of disparity	results[1]: species after 50% of disparity	results[2]: species after 75% of disparity.	results[3]: disparity after 50% of species.************/double *wholecladedisparitytaxa(double **PWDis, int notu, long **ranges, int onset, int term){int	s, t, s1, s2, sp1, sp2;int quar1=0, quar2=1, quar3=2, cog=3;double	x, M;double y, z, zz, zzz;double *accumdisp;//double	*sumdisp, *reldisp;int	*rich, **evolved;double *results;accumdisp=dvector((term-onset)+1);//reldisp=dvector((term-onset)+1);rich=ivector((term-onset)+1);evolved=imatrix((term-onset)+1,notu);results=dvector(5);cleardvector(results,5,-1);/* find which species appear by which "stage"	*/for (s=0; s<notu; ++s)	{	for (t=ranges[s][0]; t<=term; ++t)	{		evolved[t][rich[t]]=s;	/* cummulative taxa	*/		++rich[t];				/* cummulative richness	*/		}	}	/* end richness tallying	*/for (t=onset; t<=term; ++t)	{	for (s1=0; s1<(rich[t]-1); ++s1)	{		sp1=evolved[t][s1];					/* first species	*/		for (s2=s1+1; s2<rich[t]; ++s2)	{			sp2=evolved[t][s2];				/* second species	*/			accumdisp[t]+=PWDis[sp1][sp2];	/* sum pairwise dissimilarities	*/			}		}	/* now, get average	*/	if (rich[t]>1)	accumdisp[t]/=(((double) ((rich[t]*rich[t])-rich[t]))/2);	else			accumdisp[t]=0.0f;	}	/* end cumulative disparity tallying */x=accumdisp[term];rescaledvector(accumdisp,term+1,1/x);/* reset disparity to 1.0 for all comparisons	/* Note to self: should I add*/for (t=onset; t<=term; ++t)	{//	reldisp[t]=accumdisp[t]/accumdisp[term];/*	if (results[quar1]==-1 && reldisp[t]>=0.25)	results[quar1]=((double) rich[t])/((double) notu);	if (results[quar2]==-1 && reldisp[t]>=0.50)	results[quar2]=((double) rich[t])/((double) notu);	if (results[quar3]==-1 && reldisp[t]>=0.75)	results[quar3]=((double) rich[t])/((double) notu);	*/	if (results[quar1]==-1 && accumdisp[t]>=0.25)	{		if (t>onset)	{			y=accumdisp[t]-accumdisp[t-1];			x=log(rich[t])-log(rich[t-1]);			M=(accumdisp[t]-accumdisp[t-1])/(log(rich[t])-log(rich[t-1]));			z=(0.25-accumdisp[t-1])/M;									/* how much disparity is added to get to 0.25 divided by slope	*/			zz=log(rich[t-1])+z;										/* log of richness passing 0.25	*/			zzz=exp(zz);												/* richness passing 0.25		*/			results[quar1]=exp(log(rich[t-1])+((0.25-accumdisp[t-1])/M));				results[quar1]/=((double) notu);			}	/* end case where 25% found after first interval	*/		else	{//			y=accumdisp[t];//			x=log(rich[t]);//			M=y/x;			M=(accumdisp[t])/log(rich[t]);//			z=0.25/M;			results[quar1]=exp(0.25/M);			results[quar1]/=((double) notu);			}	/* end case where 25% found in first interval	*///		results[quar1]=((double) rich[t])/((double) notu);		}	/* end search for richness generating 25% of disparity	*/	if (results[quar2]==-1 && accumdisp[t]>=0.50)	{		if (t>onset)	{//			y=accumdisp[t]-accumdisp[t-1];//			x=log(rich[t])-log(rich[t-1]);//			M=y/x;			/* shift in disparity against shift in log richness	*/			M=(accumdisp[t]-accumdisp[t-1])/(log(rich[t])-log(rich[t-1]));			/* change in disparity to get to 0.25 divided by slope: that is the extra taxa	*///			z=(0.5-accumdisp[t-1]);//			zz=z/M;//			zz=(0.5-accumdisp[t-1])/M;//			zzz=log(rich[t-1])+zz;//			zzz=log(rich[t-1])+((0.5-accumdisp[t-1])/M);//			results[quar2]=exp(zzz);			results[quar2]=exp(log(rich[t-1])+((0.5-accumdisp[t-1])/M));			results[quar2]/=((double) notu);//			M=(accumdisp[t]-accumdisp[t-1])/(log(rich[t]-log(rich[t-1])));			}	/* end case where 50% found after first interval	*/		else	{//			y=accumdisp[t];//			x=log(rich[t]);//			M=y/x;			M=(accumdisp[t])/log(rich[t]);//			z=0.5/M;			results[quar2]=exp(0.5/M);			results[quar2]/=((double) notu);			}	/* end case where 50% found in first interval	*///		results[quar2]=((double) rich[t])/((double) notu);		}	/* end search for richness generating 50% of disparity	*/	if (results[quar3]==-1 && accumdisp[t]>=0.75)	{		if (t>onset)	{			M=(accumdisp[t]-accumdisp[t-1])/(log(rich[t])-log(rich[t-1]));			results[quar3]=exp(log(rich[t-1])+((0.75-accumdisp[t-1])/M));			results[quar3]/=((double) notu);			}	/* end case where 75% found after first interval	*/		else	{//			y=accumdisp[t];//			x=log(rich[t]);//			M=y/x;			M=(accumdisp[t])/log(rich[t]);//			z=0.75/M;			results[quar3]=exp(0.75/M);			results[quar3]/=((double) notu);			}	/* end case where 75% found in first interval	*/		}	/* end search for richness generating 75% of disparity	*/	}	//x=sumdisp[term]/2;x=((double) notu)/2;for (t=onset; t<term; ++t)	{//	if (sumdisp[t]<x && sumdisp[t+1]>=x)	{//		results[cog]=((double) rich[t+1])/((double) notu);//		t=term;//		}	if (rich[t]==x)	{		results[cog]=accumdisp[t];		t=term;		}	if (rich[t]<x && rich[t+1]>x)	{		z=log(x)-log(rich[t]);										/* richness shift	*/		y=(accumdisp[t+1]-accumdisp[t]);									/* disparity shift	*/		M=(accumdisp[t+1]-accumdisp[t])/(log(rich[t+1])-log(rich[t]));	/* slope			*/		results[cog]=accumdisp[t]+(log(x)-log(rich[t]))*M;		t=term;		}	else if (rich[t]>x && t==onset)	{		M=accumdisp[t]/log(rich[t]);	/* slope			*/		results[cog]=log(x)*M;		t=term;		}	}free_ivector(rich);free_imatrix(evolved,(term-onset)+1,notu);free_dvector(accumdisp);return(results);}/* stratcompatparambstest2: simulations for stratigraphic compatibility with parameters determined by best fit for stratigraphic data****************************************************************************/double *accumdisparityparambstest(double *summary, double *mbl, long **omatrix, int *ctype, int *nstates, int *bias, int *maxch, int *depend, int notu, int nchars, int compat, int RUNS, int debug, int UNKNOWN, int INAP){/* part one - matrix properties */int		d, r, s;int		c;int 	clades;long  	**simatrix, **ranges;long	**tree, **vtree;double	**sPWDis, *simaccumdisp;double	*simmary;double	tieq1=0.0f, tieq2=0.0f, tieq3=0.0f, tiecg=0.0f;double	*quart1, *quart2, *quart3, *halftaxa;long	secs;//char	outfile[120];//FILE	*output, *debugoutput;/* 2013-04-13: for center of gravity madness	*/int		term, onset;				if (RUNS%2==0)	++RUNS;			/* it's easier to use an odd number....	*/quart1=dvector(RUNS);quart2=dvector(RUNS);quart3=dvector(RUNS);halftaxa=dvector(RUNS);time(&secs);srand((unsigned int) secs);ranges=lmatrix(notu,2);			/* simulated ranges										*/simatrix=lmatrix(notu,nchars);	/* simulated morphologies								*/simmary=dvector(45);			/* OUTPUT												*/d=0;							/* for debugging	*/for (r=d; r<RUNS; ++r)	{	/* 2011-03-28: BLOWOUT at r=5	*/	for (s=0; s<notu; ++s)	{		for (c=0; c<nchars; ++c)	{			if (omatrix[s][c]==UNKNOWN)				simatrix[s][c]=UNKNOWN;			else if (omatrix[s][c]==INAP)				simatrix[s][c]=INAP;			else				simatrix[s][c]=0;			}		}	if (debug==1)	{		srand((unsigned int) (r+1)*notu*nchars);		}		/* 	trees[notu-1]: branch length of otus			trees[notu]:   branch length of clades		trees[notu+1]: first appearances of otus		trees[notu+2]: last appearances of otus	**********************************************/	tree=evolvetree(notu,mbl,1);	clades=cladecountbytaxa(tree,notu);	/* pull range data out of back of tree matrix	*/	for (s=0; s<notu; ++s)	{		ranges[s][0]=tree[notu+1][s];		ranges[s][1]=tree[notu+2][s];		}	cleancladerangedata(ranges,notu);		/* set of center of gravity madness	*/	onset=minlmatrixcol(ranges,notu,0);							/* first stage in which something appears						*/	term=maxlmatrixcol(ranges,notu,0);							/* last stage in which something appears						*/	vtree=VennTreePlus(tree,clades,notu,notu);	/* evolve character matrix, simatrix	*///	long **evolvetocompat(long **tree, int tcomp, int notu, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int *depend, int comptype, int UNKNOWN, int INAP)//	simatrix=evolvetocompat(tree,empcompat,notu,matrix,nchars,nstates,ctype,bias,chmax,depend,comptype,UNKNOWN,INAP);	simatrix=evolvetocompatibility(vtree, compat, notu, clades, simatrix, nchars, nstates, ctype, bias, maxch, depend, 0, UNKNOWN, INAP);		sPWDis=PhDfromData(simatrix,notu,nchars,UNKNOWN,INAP);	simaccumdisp=wholecladedisparitytaxa(sPWDis, notu, ranges, onset, term);		/* tally expectations		*///	simmary[1]+=simaccumdisp[0]/((double) RUNS);//	simmary[3]+=simaccumdisp[1]/(1/((double) RUNS));//	simmary[5]+=simaccumdisp[2]/(1/((double) RUNS));//	simmary[6]+=simaccumdisp[3]/(1/((double) RUNS));	quart1[r]=simaccumdisp[0];	quart2[r]=simaccumdisp[1];	quart3[r]=simaccumdisp[2];	halftaxa[r]=simaccumdisp[3];	/* tally cases where simulated values are lower than observed values		*/	if (simaccumdisp[0]<summary[0])		simmary[0]+=(1/((double) RUNS));	if (simaccumdisp[1]<summary[1])		simmary[2]+=(1/((double) RUNS));	if (simaccumdisp[2]<summary[2])		simmary[4]+=(1/((double) RUNS));	if (simaccumdisp[3]<summary[3])		simmary[6]+=(1/((double) RUNS));	/* tally cases where simulated values are exactly equal to observed values	*/	if (simaccumdisp[0]==summary[0])	tieq1+=(1/((double) RUNS));	if (simaccumdisp[1]==summary[1])	tieq2+=(1/((double) RUNS));	if (simaccumdisp[2]==summary[2])	tieq3+=(1/((double) RUNS));	if (simaccumdisp[3]==summary[3])	tiecg+=(1/((double) RUNS));		if ((r%10)==9)	{//			printf("Doing Rate = %5.4f",mbl[2]);		if (r>10)	{			printf("\b\b\b\b\b");					/* clear ", Tree %d"		*/			}		if (r>18 && r<100) 			printf("\b\b\b");		else if (r>99 && r<1000)	printf("\b\b\b\b");		else if (r>999)				printf("\b\b\b\b\b");		printf("Tree %d\n", r+1);		}	/*	free_dvector(sC);						/* 2013-04-15		*/	free_dmatrix(sPWDis,notu,notu);	free_dvector(simaccumdisp);	free_lmatrix(vtree,clades+1,notu);	free_lmatrix(tree,clades+3,notu);	}/* sort for medians	*/quart1=dshellsort_inc(quart1,RUNS);quart2=dshellsort_inc(quart2,RUNS);quart3=dshellsort_inc(quart3,RUNS);halftaxa=dshellsort_inc(halftaxa,RUNS);	simmary[1]=quart1[RUNS/2];simmary[3]=quart2[RUNS/2];simmary[5]=quart3[RUNS/2];simmary[7]=halftaxa[RUNS/2];/* get alpha values: if observed values are "low" then we want p[observed or lower]: so, add ties to total	*//* for "high" values, we do not need to do this: 1-simmary gives p[observed or more extreme] as we tallied only sims less than observed	*//* we want the probability of the observed OR MORE EXTREME; because we tallied every time the observed was lower than what we saw,		we don't need to do this when p> 0.5	*/if (simmary[0]<0.5)		simmary[0]+=tieq1;			/* general stratigraphic compatibility	*/if (simmary[2]<0.5)		simmary[2]+=tieq2;			/* strict stratigraphic compatibility	*/if (simmary[4]<0.5)		simmary[4]+=tieq3;if (simmary[6]<0.5)		simmary[6]+=tiecg;/* return output to here!	*//* TEMPORARY!  UNTIL I'VE DEBUGGED THIS.....	*///keep=1;//keep=0;//printf("Enter '1' if you want output for this taxon: ");//scanf("%i",&keep);	free_dvector(quart1);free_dvector(quart2);free_dvector(quart3);free_dvector(halftaxa);free_lmatrix(ranges,notu,2);		/* simulated ranges										*/free_lmatrix(simatrix,notu,nchars);	/* simulated morphologies								*/return simmary;}/* stratcompatparambstest2: simulations for stratigraphic compatibility with parameters determined by best fit for stratigraphic data****************************************************************************/double *accumdisparityparambstest2(double *summary, double *mbl, long **omatrix, int *ctype, int *nstates, int *bias, int *maxch, int *depend, int notu, int nchars, int compat, int RUNS, int debug, int UNKNOWN, int INAP){/* part one - matrix properties */int		d, r, s;int		c;int 	clades;long  	**simatrix, **ranges;long	**tree, **vtree;double	**sPWDis, *simaccumdisp;double	*simmary;double	tied1=0.0f, tied2=0.0f, tied3=0.0f, ties1=0.0f, ties2=0.0f, ties3=0.0f;double	*quardisp, *halfdisp, *threeqdisp, *quartaxa, *halftaxa, *threeqtaxa;long	secs;//char	outfile[120];//FILE	*output, *debugoutput;/* 2013-04-13: for center of gravity madness	*/int		term, onset;				if (RUNS%2==0)	++RUNS;			/* it's easier to use an odd number....	*/quardisp=dvector(RUNS);halfdisp=dvector(RUNS);threeqdisp=dvector(RUNS);quartaxa=dvector(RUNS);halftaxa=dvector(RUNS);threeqtaxa=dvector(RUNS);time(&secs);srand((unsigned int) secs);ranges=lmatrix(notu,2);			/* simulated ranges										*/simatrix=lmatrix(notu,nchars);	/* simulated morphologies								*/simmary=dvector(11);			/* OUTPUT												*/d=0;							/* for debugging	*/for (r=d; r<RUNS; ++r)	{	/* 2011-03-28: BLOWOUT at r=5	*/	for (s=0; s<notu; ++s)	{		for (c=0; c<nchars; ++c)	{			if (omatrix[s][c]==UNKNOWN)				simatrix[s][c]=UNKNOWN;			else if (omatrix[s][c]==INAP)				simatrix[s][c]=INAP;			else				simatrix[s][c]=0;			}		}	if (debug==1)	{		srand((unsigned int) (r+1)*notu*nchars);		}		/* 	trees[notu-1]: branch length of otus			trees[notu]:   branch length of clades		trees[notu+1]: first appearances of otus		trees[notu+2]: last appearances of otus	**********************************************/	tree=evolvetree(notu,mbl,1);	clades=cladecountbytaxa(tree,notu);	/* pull range data out of back of tree matrix	*/	for (s=0; s<notu; ++s)	{		ranges[s][0]=tree[notu+1][s];		ranges[s][1]=tree[notu+2][s];		}	cleancladerangedata(ranges,notu);		/* set of center of gravity madness	*/	onset=minlmatrixcol(ranges,notu,0);							/* first stage in which something appears						*/	term=maxlmatrixcol(ranges,notu,0);							/* last stage in which something appears						*/	vtree=VennTreePlus(tree,clades,notu,notu);	/* evolve character matrix, simatrix	*///	long **evolvetocompat(long **tree, int tcomp, int notu, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, int *depend, int comptype, int UNKNOWN, int INAP)//	simatrix=evolvetocompat(tree,empcompat,notu,matrix,nchars,nstates,ctype,bias,chmax,depend,comptype,UNKNOWN,INAP);	simatrix=evolvetocompatibility(vtree, compat, notu, clades, simatrix, nchars, nstates, ctype, bias, maxch, depend, 0, UNKNOWN, INAP);		sPWDis=PhDfromData(simatrix,notu,nchars,UNKNOWN,INAP);	simaccumdisp=wholecladedisparitytaxa2(sPWDis, notu, ranges, onset, term);		/* tally expectations		*///	simmary[1]+=simaccumdisp[0]/((double) RUNS);//	simmary[3]+=simaccumdisp[1]/(1/((double) RUNS));//	simmary[5]+=simaccumdisp[2]/(1/((double) RUNS));//	simmary[6]+=simaccumdisp[3]/(1/((double) RUNS));	quardisp[r]=simaccumdisp[0];	halfdisp[r]=simaccumdisp[1];	threeqdisp[r]=simaccumdisp[2];	quartaxa[r]=simaccumdisp[3];	halftaxa[r]=simaccumdisp[4];	threeqtaxa[r]=simaccumdisp[5];	/* tally cases where simulated values are lower than observed values		*/	if (simaccumdisp[0]<summary[0])		simmary[0]+=(1/((double) RUNS));	if (simaccumdisp[1]<summary[1])		simmary[2]+=(1/((double) RUNS));	if (simaccumdisp[2]<summary[2])		simmary[4]+=(1/((double) RUNS));	if (simaccumdisp[3]<summary[3])		simmary[6]+=(1/((double) RUNS));	if (simaccumdisp[4]<summary[4])		simmary[8]+=(1/((double) RUNS));	if (simaccumdisp[5]<summary[5])		simmary[10]+=(1/((double) RUNS));	/* tally cases where simulated values are exactly equal to observed values	*/	if (simaccumdisp[0]==summary[0])	tied1+=(1/((double) RUNS));	if (simaccumdisp[1]==summary[1])	tied2+=(1/((double) RUNS));	if (simaccumdisp[2]==summary[2])	tied3+=(1/((double) RUNS));	if (simaccumdisp[3]==summary[3])	ties1+=(1/((double) RUNS));	if (simaccumdisp[4]==summary[4])	ties2+=(1/((double) RUNS));	if (simaccumdisp[5]==summary[5])	ties3+=(1/((double) RUNS));		if ((r%10)==9)	{//			printf("Doing Rate = %5.4f",mbl[2]);		if (r>10)	{			printf("\b\b\b\b\b");					/* clear ", Tree %d"		*/			}		if (r>18 && r<100) 			printf("\b\b\b");		else if (r>99 && r<1000)	printf("\b\b\b\b");		else if (r>999)				printf("\b\b\b\b\b");		printf("Tree %d\n", r+1);		}	/*	free_dvector(sC);						/* 2013-04-15		*/	free_dmatrix(sPWDis,notu,notu);	free_dvector(simaccumdisp);	free_lmatrix(vtree,clades+1,notu);	free_lmatrix(tree,clades+3,notu);	}/* sort for medians	*/quardisp=dshellsort_inc(quardisp,RUNS);halfdisp=dshellsort_inc(halfdisp,RUNS);threeqdisp=dshellsort_inc(threeqdisp,RUNS);halftaxa=dshellsort_inc(halftaxa,RUNS);	simmary[1]=quardisp[RUNS/2];simmary[3]=halfdisp[RUNS/2];simmary[5]=threeqdisp[RUNS/2];simmary[7]=quartaxa[RUNS/2];simmary[9]=halftaxa[RUNS/2];simmary[11]=threeqtaxa[RUNS/2];/* get alpha values: if observed values are "low" then we want p[observed or lower]: so, add ties to total	*//* for "high" values, we do not need to do this: 1-simmary gives p[observed or more extreme] as we tallied only sims less than observed	*//* we want the probability of the observed OR MORE EXTREME; because we tallied every time the observed was lower than what we saw,		we don't need to do this when p> 0.5	*/if (simmary[0]<0.5)		simmary[0]+=tied1;			/* general stratigraphic compatibility	*/if (simmary[2]<0.5)		simmary[2]+=tied2;			/* strict stratigraphic compatibility	*/if (simmary[4]<0.5)		simmary[4]+=tied3;if (simmary[6]<0.5)		simmary[6]+=ties1;if (simmary[8]<0.5)		simmary[8]+=ties2;if (simmary[10]<0.5)	simmary[10]+=ties3;/* return output to here!	*//* TEMPORARY!  UNTIL I'VE DEBUGGED THIS.....	*///keep=1;//keep=0;//printf("Enter '1' if you want output for this taxon: ");//scanf("%i",&keep);	free_dvector(quardisp);free_dvector(halfdisp);free_dvector(threeqdisp);free_dvector(quartaxa);free_dvector(halftaxa);free_dvector(threeqtaxa);free_lmatrix(ranges,notu,2);		/* simulated ranges										*/free_lmatrix(simatrix,notu,nchars);	/* simulated morphologies								*/return simmary;}/*	results[0]: species after 25% of disparity	results[1]: species after 50% of disparity	results[2]: species after 75% of disparity.	results[3]: disparity after 25% of species.	results[4]: disparity after 50% of species.	results[5]: disparity after 75% of species.************/double *wholecladedisparitytaxa2(double **PWDis, int notu, long **ranges, int onset, int term){int	s, t, s1, s2, sp1, sp2;int disp1=0, disp2=1, disp3=2, rich1=3, rich2=4, rich3=5;double	x, M;double y, z, zz, zzz;double *accumdisp;//double	*sumdisp, *reldisp;int	*rich, **evolved;double *results;accumdisp=dvector((term-onset)+1);//reldisp=dvector((term-onset)+1);rich=ivector((term-onset)+1);evolved=imatrix((term-onset)+1,notu);results=dvector(6);cleardvector(results,5,-1);/* find which species appear by which "stage"	*/for (s=0; s<notu; ++s)	{	for (t=ranges[s][0]; t<=term; ++t)	{		evolved[t][rich[t]]=s;	/* cummulative taxa	*/		++rich[t];				/* cummulative richness	*/		}	}	/* end richness tallying	*/for (t=onset; t<=term; ++t)	{	for (s1=0; s1<(rich[t]-1); ++s1)	{		sp1=evolved[t][s1];					/* first species	*/		for (s2=s1+1; s2<rich[t]; ++s2)	{			sp2=evolved[t][s2];				/* second species	*/			accumdisp[t]+=PWDis[sp1][sp2];	/* sum pairwise dissimilarities	*/			}		}	/* now, get average	*/	if (rich[t]>1)	accumdisp[t]/=(((double) ((rich[t]*rich[t])-rich[t]))/2);	else			accumdisp[t]=0.0f;	}	/* end cumulative disparity tallying */x=accumdisp[term];rescaledvector(accumdisp,term+1,1/x);/* reset disparity to 1.0 for all comparisons	/* Note to self: should I add*/for (t=onset; t<=term; ++t)	{//	reldisp[t]=accumdisp[t]/accumdisp[term];/*	if (results[disp1]==-1 && reldisp[t]>=0.25)	results[disp1]=((double) rich[t])/((double) notu);	if (results[disp2]==-1 && reldisp[t]>=0.50)	results[disp2]=((double) rich[t])/((double) notu);	if (results[disp3]==-1 && reldisp[t]>=0.75)	results[disp3]=((double) rich[t])/((double) notu);	*/	if (results[disp1]==-1 && accumdisp[t]>=0.25)	{		if (t>onset)	{			y=accumdisp[t]-accumdisp[t-1];			x=log(rich[t])-log(rich[t-1]);			M=(accumdisp[t]-accumdisp[t-1])/(log(rich[t])-log(rich[t-1]));			z=(0.25-accumdisp[t-1])/M;									/* how much disparity is added to get to 0.25 divided by slope	*/			zz=log(rich[t-1])+z;										/* log of richness passing 0.25	*/			zzz=exp(zz);												/* richness passing 0.25		*/			results[disp1]=exp(log(rich[t-1])+((0.25-accumdisp[t-1])/M));				results[disp1]/=((double) notu);			}	/* end case where 25% found after first interval	*/		else	{//			y=accumdisp[t];//			x=log(rich[t]);//			M=y/x;			M=(accumdisp[t])/log(rich[t]);//			z=0.25/M;			results[disp1]=exp(0.25/M);			results[disp1]/=((double) notu);			}	/* end case where 25% found in first interval	*///		results[disp1]=((double) rich[t])/((double) notu);		}	/* end search for richness generating 25% of disparity	*/	if (results[disp2]==-1 && accumdisp[t]>=0.50)	{		if (t>onset)	{//			y=accumdisp[t]-accumdisp[t-1];//			x=log(rich[t])-log(rich[t-1]);//			M=y/x;			/* shift in disparity against shift in log richness	*/			M=(accumdisp[t]-accumdisp[t-1])/(log(rich[t])-log(rich[t-1]));			/* change in disparity to get to 0.25 divided by slope: that is the extra taxa	*///			z=(0.5-accumdisp[t-1]);//			zz=z/M;//			zz=(0.5-accumdisp[t-1])/M;//			zzz=log(rich[t-1])+zz;//			zzz=log(rich[t-1])+((0.5-accumdisp[t-1])/M);//			results[disp2]=exp(zzz);			results[disp2]=exp(log(rich[t-1])+((0.5-accumdisp[t-1])/M));			results[disp2]/=((double) notu);//			M=(accumdisp[t]-accumdisp[t-1])/(log(rich[t]-log(rich[t-1])));			}	/* end case where 50% found after first interval	*/		else	{//			y=accumdisp[t];//			x=log(rich[t]);//			M=y/x;			M=(accumdisp[t])/log(rich[t]);//			z=0.5/M;			results[disp2]=exp(0.5/M);			results[disp2]/=((double) notu);			}	/* end case where 50% found in first interval	*///		results[disp2]=((double) rich[t])/((double) notu);		}	/* end search for richness generating 50% of disparity	*/	if (results[disp3]==-1 && accumdisp[t]>=0.75)	{		if (t>onset)	{			M=(accumdisp[t]-accumdisp[t-1])/(log(rich[t])-log(rich[t-1]));			results[disp3]=exp(log(rich[t-1])+((0.75-accumdisp[t-1])/M));			results[disp3]/=((double) notu);			}	/* end case where 75% found after first interval	*/		else	{//			y=accumdisp[t];//			x=log(rich[t]);//			M=y/x;			M=(accumdisp[t])/log(rich[t]);//			z=0.75/M;			results[disp3]=exp(0.75/M);			results[disp3]/=((double) notu);			}	/* end case where 75% found in first interval	*/		}	/* end search for richness generating 75% of disparity	*/	}	//x=sumdisp[term]/2;x=((double) notu)/2;y=((double) notu)/4;z=3*((double) notu)/4;for (t=onset; t<term; ++t)	{//	if (sumdisp[t]<x && sumdisp[t+1]>=x)	{//		results[rich2]=((double) rich[t+1])/((double) notu);//		t=term;//		}	if (rich[t]==y)	{		results[rich1]=accumdisp[t];		t=term;		}	if (rich[t]<y && rich[t+1]>y)	{		z=log(y)-log(rich[t]);										/* richness shift	*/		y=(accumdisp[t+1]-accumdisp[t]);									/* disparity shift	*/		M=(accumdisp[t+1]-accumdisp[t])/(log(rich[t+1])-log(rich[t]));	/* slope			*/		results[rich1]=accumdisp[t]+(log(y)-log(rich[t]))*M;		t=term;		}	else if (rich[t]>y && t==onset)	{		M=accumdisp[t]/log(rich[t]);	/* slope			*/		results[rich1]=log(y)*M;		t=term;		}			if (rich[t]==x)	{		results[rich2]=accumdisp[t];		t=term;		}	if (rich[t]<x && rich[t+1]>x)	{		z=log(x)-log(rich[t]);										/* richness shift	*/		y=(accumdisp[t+1]-accumdisp[t]);									/* disparity shift	*/		M=(accumdisp[t+1]-accumdisp[t])/(log(rich[t+1])-log(rich[t]));	/* slope			*/		results[rich2]=accumdisp[t]+(log(x)-log(rich[t]))*M;		t=term;		}	else if (rich[t]>x && t==onset)	{		M=accumdisp[t]/log(rich[t]);	/* slope			*/		results[rich2]=log(x)*M;		t=term;		}	if (rich[t]==z)	{		results[rich3]=accumdisp[t];		t=term;		}	if (rich[t]<z && rich[t+1]>z)	{		z=log(z)-log(rich[t]);										/* richness shift	*/		z=(accumdisp[t+1]-accumdisp[t]);									/* disparity shift	*/		M=(accumdisp[t+1]-accumdisp[t])/(log(rich[t+1])-log(rich[t]));	/* slope			*/		results[rich3]=accumdisp[t]+(log(z)-log(rich[t]))*M;		t=term;		}	else if (rich[t]>z && t==onset)	{		M=accumdisp[t]/log(rich[t]);	/* slope			*/		results[rich3]=log(z)*M;		t=term;		}	}free_ivector(rich);free_imatrix(evolved,(term-onset)+1,notu);free_dvector(accumdisp);return(results);}