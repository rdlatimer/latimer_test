// This code was taken from (and then slightly modified) Press et al. (1992). Numerical Recipes// in C.  Cambridge: Cambridge University Press. Pages 456-495.#include <nrutil.h>#include <stdlib.h>#include <stdio.h>#include <iostream.h>#include <stddef.h>#include <math.h>// From Numerical Recipes in C (Press et al) - Defined in <nrutl.h>.#define NR_END 1#define FREE_ARG char*#define ROTATE(a,i,j,k,l) g=a[i][j]; h=a[k][l];a[i][j]=g-s*(h+g*tau);a[k][l]=h+s*(g-h*tau);// Function Headers// Transforms the Gower-Transformed matrix (matrix T) in order to extract eigen*'svoid tred2(int n);// Extracts the Eigen*'s from the transformed matrixvoid tqli(float d[], float e[], int n, float **v);// Sorts the eigenvaluesvoid eigensort(float d[], float **v, int n);// "Numerical Recipes in C" error functionvoid nrerror(char error_text[]);// This function reduces a real, symmetric matrix to its tridiagonal form// a = the matrix// n = the number of elements in each row/column of a// d returns the diagonal elements of the new matrix// e returns the off-diagolan elements// This function sends all variables to function tqli for eigenanalysis void tred2(float **a, int n, float d[], float e[]){	int counter=0;	float **a;	a = new float*[n];	for(counter = 1; counter <= n; counter++ )	{		a[counter] = new float[n];	}	int l,i, j, k;	float *e,*d, f, g, hh, scale, h;	e = new float[n];	d = new float[n];	for (i=n;i>=2;i--)	{		l=i-1;		h=scale=0.0;		if (l>1)		{			for (k=1;k<=l;k++)				scale += (float)(fabs(a[i][k]));			if (scale == 0.0)				e[i]=a[i][l];			else			{				for (k=1;k<=l;k++)				{					a[i][k] /= scale;					h += a[i][k]*a[i][k];				}				f=a[i][l];				g=(float)((f >= 0.0 ? -sqrt(h) : sqrt(h)));				e[i]=(float)(scale*g);				h -= f*g;				a[i][l] = f-g;				f=0.0;				for (j=1;j<=l;j++)				{					a[j][i]=a[i][j]/h;					g=0.0;					for (k=1;k<=j;k++)						g += a[j][k]*a[i][k];					for (k=1;k<=l;k++)						g += a[k][j]*a[i][k];					e[j]=g/h;					f += e[j]*a[i][j];				}				hh=f/(h+h);				for (j=1; j<=l; j++)				{					f=a[i][j];					e[j]=g=e[j]-hh*f;					for (k=1;k<=j;k++)						a[j][k] -= (f*e[k]+g*a[i][k]);				}			}		}		else			e[i]=a[i][l];		d[i] = h;	}	d[1] = 0.0;	e[1] = 0.0;	for (i=1;i<=n;i++)	{		l=i-1;		if (d[i])		{			for (j=1;j<=l;j++)			{				g=0.0;				for (k=1; k<=l; k++)					g += a[i][k]*a[k][j];				for (k=1; k <= l; k++)					a[k][j] -= g*a[k][i];			}		}		d[i] = a[i][i];		a[i][i] = 1.0;		for (j=1; j<=l;j++)			a[j][i]=a[i][j]=0.0;	}	tqli(d,e,n,a);}// Taken from Press et al. (Numberical Recips in C).// This function calculates the eigenvectors and eigenvalues of the matrix a// z = a new matrix containing the eigenvectorsvoid tqli(float d[], float e[], int n, float **z){	int m,l,iter,i,k;	float s,r,p,g,f,dd,c,b;	for (i=2; i<=n;i++)		e[i-1]=e[i];	for (l=1;l<=n;l++)	{		iter=0;		do		{			for (m=1;m<=n-1;m++)			{				dd=(float)(fabs(d[m+1]));				if ((float)(fabs(e[m])+dd) == dd) break;			}			if (m != 1)			{				if (iter++ == 30) nrerror("Too many iterations in function tqli");				g=(float)((d[l+1]-d[l])/(2.0*e[l]));				r=(float)(pow((pow(g,2) + pow(1.0,2)),.5));				g=(float)(d[m]-d[l]+e[l]/(g+SIGN(r,g)));				s=c=1.0;				p=0.0;				for (i=m-1;i>=1;i--)				{					f=s*e[i];					b=c*e[i];					e[i+1]=(r=((float)(pow((pow(g,2) + pow(f,2)),.5))));					if (r == 0.0)					{						d[i+1] -= p;						e[m]=0.0;						break;					}					s=f/r;					c=g/r;					g=d[i+1]-p;					r=(float)((d[i]-g)*s+2.0*c*b);					d[i+1]=g+(p=s*r);					g=c*r-b;					for (k=1;k<=n;k++)					{						f=(float)(z[k][i+1]);						z[k][i+1]=(float)(s*z[k][i]+c*f);						z[k][i]=(float)(c*z[k][i]-s*f);					}				}				if (r == 0.0 && i >= l) continue;				d[l] -= p;				e[l] = g;				e[m]=0.0;			}		} while (m != 1);	}	eigensort(d,z,n);}// Sorts the eigenvalues from high to low.void eigensort(float d[], float **v, int n){	int k,j,i;	float p;	for (i=1;i<n;i++)	{		p=d[k=i];		for (j=i+1;j<=n;j++)		{			if (d[j] >= p) p=d[k=j];		}		if (k != i)		{			d[k]=d[i];			d[i]=p;			for (j=1; j<=n;j++)			{				p=v[j][i];				v[j][i]=v[j][k];				v[j][k]=p;			}		}	}}// Numerical Recipes Error-Handlervoid nrerror(char error_text[]){fprintf(stderr,"Numerical Recipes run-time error.  ");fprintf(stderr,error_text);fprintf(stderr,"\n");fprintf(stderr,"Now exiting to system...\n");exit(1);}