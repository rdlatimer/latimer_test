/* Returns a matrix for OTUs taxa with nchars characters.  Gaps and missing are kept in place *//* Requires:   tree - a VennTree where:   		tree[0][0]Étree[nodes][0] give the CUMULATIVE descendants of each node;   		tree[0][1Étree[0][0]]Étree[nodes][1Étree[nodes][0]] give the OTUS that (immediately or ultimately) evolved within this node	notu - number of taxa;	nodes - number of clades;		ADDED 2011-02-03!!!!!!	matrix - a taxon X character matrix with character data; this will be returned modified;	nchars - the number of characters;	nstates - the number of states per character;	ctype - the type of each character, with 0 = unordered, 1 = ordered;	bias - the probablility of increase (with 50 meaning 50:50 increase / decrease and 90 meaning 90:10 increase:decrease;	TTLSTP - the number of changes for the matrix;	UNKNOWN - character denoting missing data;	INAP - character denoting inapplicable data;*******************************************************************************************************************************************/long **evolvematrix_rateshift(long **tree, int notu, int nodes, long **matrix, int nchars, int *nstates, int *ctype, int *bias, int *maxch, long *ranges, *double shiftinfo, int ttlstp, int UNKNOWN, int INAP){int		a, b, c, d, br, ch, sc, ev, flip, sp, sp2;int		st, u, clse, best;int		avnodes, used, deltas, mxdel, ttlbr;int		*available, *branches, *steps, *trpd, *mpd, *der, *aptaxa;int		**taxachange;/*, **descnodes;	/* for debugging */long	**invmatrix;/* find the number of nodes and their diversities 	nodes=0;for (a=0; a<notu; ++a)	{	if (tree[a][0]>1)	++nodes;	else	a=notu;	}										/* 2011-02-03: somehow, someway, I need a safeguard against fully bifurcating trees.... *//*nodes=cladecountbytaxa(tree,notu);			/* number of clades in tree									*/mxdel=maxiarray(maxch,nchars);				/* maximum number of changes for any character 				*/mpd=ivector(nodes+notu);					/* morphologic changes along each branch 					*/trpd=ivector(nodes+notu);					/* number of ancestors along each branch - 1 means that there is only one branch after node; 2 means 1 unsampled ancestor */steps=ivector(nchars);						/* number of times each character changes 					*/der=ivector(nchars);						/* number of taxa with derived condition for each character */trpd[notu]=ttlbr=0;for (sp=0; sp<notu; ++sp)	{	trpd[sp]=tree[nodes][sp];		/* array tree[notu-1] gives branch lengths of species */	ttlbr=ttlbr+trpd[sp];	}for (sp=1; sp<nodes; ++sp)	{	trpd[sp+notu]=tree[nodes+1][sp];	/* array tree[notu] gives branch lengths of ancestors */	ttlbr=ttlbr+trpd[sp+notu];	}	if (ttlbr<mxdel)	mxdel=ttlbr;/* allocate memory for arrays containing branches needing changes */available=ivector(ttlbr);branches=ivector(ttlbr);taxachange=imatrix(nchars, mxdel);	/* gives taxa that change for character */invmatrix=lmatrix(nchars, notu);aptaxa=applicabletaxa(matrix, nchars, notu, INAP);/* BEGIN HERE 5/18/01 describe each clade in terms of all species within it *//******* CHARACTER EVOLUTION - REWRITTEN 3/31/01 TO DO TOTAL TREE LENGTH ********/	/* determine appropriate branches for changes - all nodes & species without sampled descendants *//* we'll ignore the basal node, assuming that it is all 0's */avnodes=b=0;for (a=1; a<nodes; ++a)	{	avnodes=avnodes+trpd[a+notu];	for (c=0; c<trpd[a+notu]; ++c)	{		available[b]=a+notu;		++b;		}	}for (a=0; a<notu; ++a)	{	for (c=0; c<trpd[a]; ++c)	{		available[b]=a;		++b;		}	}/* clear matrix */for (ch=0; ch<nchars; ++ch)	{	for (a=0; a<notu; ++a)	{		if (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN)	{			matrix[a][ch]=0;			}		invmatrix[ch][a]=matrix[a][ch];	/* for debugging */		}	}deltas=0;/* Step 1: Make sure each state is derived for each character *//*derive_each_char(matrix, invmatrix, taxachange, nstates, ctype, maxch, steps, bias, aptaxa, mpd, trpd, notu, nchars, maxstp, mxdel, UNKNOWN, INAP, tree, branches, available, nodes, ttlbr);	*/for (ch=0; (ch<nchars && deltas<ttlstp); ++ch)	{	while (maxch[ch]==0 && ch<nchars)	++ch;	if (ch>=nchars)			break;	steps[ch]=st=0;	clearivector(taxachange[ch],mxdel,-1);	ev=0;			/* make sure that inapplicable characters have at least one taxon that can be changed */	if (aptaxa[ch]<notu)	{		/* count unknowns - these will be put back in later */		u=0;		for (a=0; a<notu; ++a)	if (matrix[a][ch]==UNKNOWN)	++u;		/* now find a node that has similar diversity */		clse=RAND_MAX;				/* start from the bottom if most taxa are scored */		if (aptaxa[ch]>(notu/2))	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==(notu-aptaxa[ch]))	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs((notu-aptaxa[ch])-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}		/* start from the top otherwise */		else	{			for (br=nodes-1; br>0; ++br) {				/* if you find a clade exactly the same size, then use it */				if (tree[br][0]==aptaxa[ch])	{					best=br;					br=nodes;					clse=0;					}				/* if not, find the closest one - favor those that are slightly larger */				else	{					a=abs(aptaxa[ch]-tree[br][0]);					if (a<clse)	{						clse=a;						best=br;						}					else if (a==clse && tree[br][0]>tree[best][0])	best=br;					}				}			}				for (sp=0; sp<notu; ++sp)	{			if (aptaxa[ch]>(notu/2))	matrix[sp][ch]=0;			else						matrix[sp][ch]=INAP;			}		for (a=1; a<tree[best][0]; ++a)	{			sp=tree[best][a];			matrix[sp][a]=0;			}		}	/* end initial creation of inapplicable character */		/* make autapomorphic characters change on one species only */	/* invariants do not change at all */	for (ch=ch; maxch[ch]<=1; ++ch)	{		/* skip invariants and make autapomorphies autapomorphic */		if	(maxch[ch]==1)	{			c=0;			/* we will sample only from otus here - so do not include clades in branches array! */			/* this part rewritten with Cubs winning 7-0 against the Marlins in Game 4 */			for (sp=0; sp<notu; ++sp)				if ((matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP) && trpd[sp]>0)	++c;			if (c>0)	{				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || (trpd[sp]==0 || sp>=notu))					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=1;				taxachange[ch][0]=sp;				}			/* if only cells belong to species with 0 length branches */			if (c==0)	{				/* flip-flop an unknown apomorphic species with a known plesiomorphic one - give plesiomorphic species a ? and the other a 1 */				sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while ((matrix[sp][ch]==UNKNOWN && matrix[sp][ch]==INAP) || sp2>=notu)					sp=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);								sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				while (trpd[sp2]==0 || sp2>=notu)					sp2=(int)((double)rand() / ((double)RAND_MAX + 1) * notu);				invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp2][ch];				invmatrix[ch][sp2]=matrix[sp2][ch]=1;				taxachange[ch][0]=sp2;				}	/* end routine if all scored species were unknown */			ev=1;			++deltas;			++steps[ch];			++mpd[ch];			}		}	/* this should leave us with a character that needs to be changed OR out of characters */	if (ch>=nchars)	break;			used=0;	/* this tells how many branches are discarded; used > steps IF there are absents */	/* branch length is taken into account by trpd */	equalivector(branches,available,ttlbr);	/* Binary && unordered multistate is Easy */	/* for normal character, have it change until all X states are realized */	if (nstates[ch]==2 || ctype[ch]==1)	{		/* changed 10/14/2003 so that non-apomorphic characters	diagnose 2+ species */		for (st=0; (st<nstates[ch]-1 || der[ch]<=1); st=st)	{			/* There are ttlbr-used branches that could change */			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			/* have binary characters change on branches - if they are not autapomorphic, then they need to diagnose multiple species THIS WAS REMOVED 10/14/2003			else				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (avnodes-used));*/			sp = branches[br];						/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				ev=1;				if (nstates[ch]==2)	invmatrix[ch][sp]=matrix[sp][ch]=1;				else					invmatrix[ch][sp]=matrix[sp][ch]=st+1;				++der[ch];				/* add one to the number of species showing derived condition(s) */				}			else if (sp>notu)	{				/* use st+1 instead of nstates[ch] here - we want only 0Ést+1 not 0Énstates    */				/*		(remember, st has not yet been incremented, so we need st+1) 		   */				/* This section modified 10/14/2003 to make sure characters are not apomorphic */				/* if multistate, then we need at least two iterations */				if (nstates[ch]>2)	{					/* if we have not yet derived all of the states, do it this way 			*/					/* if deriving first state (i.e., st=0), then it is the same as binary		*/					if (st<nstates[ch] && st==0)						evolvebinaryinclade(tree[sp-notu],matrix,ch);					/* if deriving subsequent states, then used change unmodified species to st+1 		*/					else if (st<(nstates[ch]-1) && st>=1)	{						for (c=1; c<=tree[sp-notu][0]; ++c)	{							sp2=tree[sp-notu][c];							if (matrix[sp2][ch]==0)	matrix[sp2][ch]=st+1;							}						}/*						evolveunorderedinclade(tree[sp-notu],matrix,ch,st+2,UNKNOWN,INAP);	*/					/* if we have an essentially apomorphic states, then just do it like any other time */					else						evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],UNKNOWN,INAP);					}				else		evolvebinaryinclade(tree[sp-notu],matrix,ch);				for (c=1; c<=tree[sp-notu][0]; ++c)	{					sp2=tree[sp-notu][c];					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					if (invmatrix[ch][sp2]!=0 && (invmatrix[ch][sp2]!=UNKNOWN && invmatrix[ch][sp2]!=INAP))						++der[ch];					else if (invmatrix[ch][sp2]==0)						--der[ch];					/* this will happen only if there are reversals */					}				/* if there was a change, then tally it */				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1) || der[ch]<=1)				removefromivector(branches,sp,&a);							if (used<steps[ch])	{				printf("ERROR LINE 954 - there are more changes than deleted branches for Ch%dÉ\n",ch+1);				}			/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				++st;	/* we increment this only if we have made a change */				}			}	/*end derivation of state */		}	/* end loop for binary / unordered characters */		/* Ordered Multistates are tougher */	else if (nstates[ch]>2 && ctype[ch]==0)	{		used=0;		for (st=0; (st<nstates[ch]-1 && (steps[ch]<mxdel && steps[ch]<maxch[ch])); st=st)	{			br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));			sp=branches[br];			/* this shouldn't be necessary, but occassionaly the random number generator */			/* produces a number outside of the proscribed limits */			while (trpd[sp]==0 || br>=(ttlbr-used))	{				br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));				sp = branches[br];				}			if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				/* in this case all taxa must be examined just in case the matrix has been recentered due to a negative number */				for (sp2=0; sp2<notu; ++sp2)	{					if (ev==0 && invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					}				ev=1;				}							else if (sp>notu)	{				flip = ((int) (100 * rand() / RAND_MAX));				if (flip<bias[ch])	flip=1;				else				flip=-1;				evolveorderedinclade(tree[sp-notu],matrix,ch,flip, INAP, UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				/* in this case all taxa must be modified just in case the matrix has been recentered due to a negative number */				for (sp2=0; sp2<notu; ++sp2)	{					if (ev==0 && invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;					invmatrix[ch][sp2]=matrix[sp2][ch];					}				}							/* if ev=1 then the state has been derived */			if (ev==1)	{				++mpd[sp];				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++deltas;				/* note - do not increment st here - that is done only if a new state is derived */				}			/* check if all states have been derived */			/* note: this is needed only for ordered multistates */			if (steps[ch]>=nstates[ch]-1)	{				for(a=0; a<notu; ++a)	{					if (matrix[a][ch]>st && (matrix[a][ch]!=INAP && matrix[a][ch]!=UNKNOWN))						st=matrix[a][ch];					}				}			a=ttlbr-used;			used=used+trpd[sp];			/* remove branches from possible change list (but only if more changes must be made)	*/			if (st<(nstates[ch]-1))				removefromivector(branches,sp,&a);			if (used<steps[ch])				printf("ERROR LINE 2145 - there are more changes than deleted branches for Ch%dÉ\n",ch+1);						/* emergency reboot procedure! - clear everything and start over again */			if (used==ttlbr)	{				for (a=0; a<steps[ch]; ++a)	{					sp=taxachange[ch][a];					--mpd[sp];					taxachange[ch][a]=0;					}				deltas=deltas-steps[ch];				st=steps[ch]=used=0;				for (sp=0; sp<notu; ++sp)					if (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN)						invmatrix[ch][sp]=matrix[sp][ch]=0;				for (sp=0; sp<ttlbr; ++sp)	branches[sp]=available[sp];				}			}		/* if there are many states and few taxa, then you do not want to mess with this anymore.  Any changes will either eliminate extreme states,		or simply shift the state up or down one (resulting in no observable change once standardized.  So, if steps >= half the taxa, then shut it down */				}	/* end loop for ordered multistates */	}	/* end derivation of all character states *//* Step #2: make sure that each apomorphic species has a derivation */for (sp=0; (sp<notu+nodes && deltas<ttlstp); ++sp)	{	if (mpd[sp]==0 && trpd[sp]>0)	{		while (mpd[sp]==0)	{			ev=0;			ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));			while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))				ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));						if (sp<notu && (matrix[sp][ch]!=INAP && matrix[sp][ch]!=UNKNOWN))	{				if (nstates[ch]==2)						invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);				else if (ctype[ch]==1)					invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);				else if (ctype[ch]==0)	{					invmatrix[ch][sp]=matrix[sp][ch]=multi(matrix[sp][ch],bias[ch]);					/* make sure no negative numbers are kept! */					multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);					}				ev=1;	/* this means that there was a change */				}						else if (sp>notu)	{				d=0;				/* make sure that there are taxa with scorable conditions for this character 		*/				/* and also that not all the descendants have changed already for this character 	*/				/* (the latter can be omitted as evolution cannot know this - but it makes the 		*/				/* output easier to compare to empirical studies.)									*/						for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{					sp2=tree[sp-notu][sc];					if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;					else	{						for (c=0; c<steps[ch]; ++c)	{							if (taxachange[ch][c]==sp2)	{								++d;								c=steps[ch];								}							}						}		/* if any taxa have not yet changed, then d < clade diversity */					}	/* end search for scored taxa */					/* if d is less than clade diversity, then proceed with change */				if (d<tree[sp-notu][0])	{					/* if character is an unordered multistate, then we need an array	*/					/* that tells how each state changed withing the clade				*/					if (ctype[ch]==1)	{						/* routine for unordered multistates */						if (nstates[ch]>2)	{							evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);							}						/* routine for binaries */						else	{							evolvebinaryinclade(tree[sp-notu],matrix,ch);							}						}	/* end routine for unordered / binary characters */					/* routine for ordered multistate */					else {						/* flip is used only for multistates */						flip = ((int) (100 * rand() / RAND_MAX));						if (flip<bias[ch])	flip=1;						else				flip=-1;						evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);						multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);						}					/* now make sure that there was change */					for (c=0; c<notu; ++c)	{						if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;						invmatrix[ch][c]=matrix[c][ch];						}					}	/* end conditional loop */				}	/* end routine for clade */			/* if there was a change, then ev = 1.  Now tally the information */			if (ev==1)	{				taxachange[ch][steps[ch]]=sp;				++steps[ch];				++mpd[sp];				++deltas;				}	/* add changes if there actually was a change */			}	/* routine is repeated until an apomorphy is acquired */					}	/* end derivation of apomorphy for this branch */	}	/* end derivation for each apomorphic branch *//* Step #3: DO ADDITIONAL STEPS NOW *//* this is when we use the rate shift	*//* first date branches	*/for (c=0; c<nodes; ++c)	{	fa[notu+c]=ranges[vtree[c][1]][0];	for (b=2; b<=vtree[c][0]; ++b)	{		s=vtree[c][0];		if (ranges[s][0]<fa[notu+c])			}	}	for (deltas=deltas; deltas < ttlstp; deltas=deltas)	{	/* first choose a character */	ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	while (((ch>=nchars || ch<0) || (steps[ch]>=maxch[ch] || steps[ch]>=mxdel)) || (ctype[ch]==0 && steps[ch]>(notu/2)))		ch=(int)((double)rand() / ((double)RAND_MAX + 1) * (nchars));	/**************************************************************************/	/* do not change the character on a branch where it already has changed */	for (br=0; br<ttlbr; ++br)	branches[br]=available[br];		used=0;	/* used will tally the number of deleted branches */	for (d=0; d<steps[ch]; ++d)	{		for (c=0; c<(ttlbr-used); ++c)	{			/* if branch with change is found, delete it from possible changes */			if (branches[c]==taxachange[ch][d])	{				for (a=c; a<ttlbr-1; ++a)	branches[a]=branches[a+1];				/* some taxa will be in 2+ times - step back to delete them all */				--c;				branches[ttlbr-(used+1)]=-1;				++used;				}			}		}	/* choose a branch from one available */	/* used will be equal to or greater than steps[ch] (due to long branches) */	br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));	sp = branches[br];	/* this shouldn't be necessary, but occassionaly the random number generator */	/* produces a number outside of the proscribed limits */	while (trpd[sp]==0 || br>=(ttlbr-used))	{		br=(int)((double)rand() / ((double)RAND_MAX + 1) * (ttlbr-used));		sp = branches[br];		}	ev=0;	if (nstates[ch]==2)	{		/* routine for binary characters */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=swap(matrix[sp][ch]);			ev=1;			}		/* routine for clade */		else if (sp>=notu)	{			evolvebinaryinclade(tree[sp-notu],matrix,ch);			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (invmatrix[ch][sp2]!=matrix[sp2][ch])	ev=1;				invmatrix[ch][sp2]=matrix[sp2][ch];				}				}	/* end routine for clade */		}	/* Ordered Multistates */	else if (ctype[ch]==0)	{		flip = ((int) (100 * rand() / RAND_MAX));		if (flip<bias[ch])						flip=1;		else									flip=-1;				/* routine for species */		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=matrix[sp][ch]+flip;			if (matrix[sp][ch]>=nstates[ch])	invmatrix[ch][sp]=matrix[sp][ch]=nstates[ch]-2;			else if (matrix[sp][ch]<0)			invmatrix[ch][sp]=matrix[sp][ch]=1;			ev=1;			}		/* routine for clade */		else if (sp>=notu)	{			/* make sure that not all descendants have already changed! */			d=0;			for (sc=1; sc<=tree[sp-notu][0]; ++sc)	{				sp2=tree[sp-notu][sc];				if (matrix[sp2][ch]==UNKNOWN || matrix[sp2][ch]==INAP)	++d;				else	{					for (c=0; c<steps[ch]; ++c)	{						if (taxachange[ch][c]==sp2)	{							++d;							c=steps[ch];							}	/* end test of whether particular change matches species */						}	/* end search through each step */					}	/* end search for unchanged taxa */				}			if (d<tree[sp-notu][0])	{				evolveorderedinclade(tree[sp-notu],matrix,ch,flip,INAP,UNKNOWN);				multistatevett(matrix, ch, nstates[ch], notu, INAP, UNKNOWN);				}			/* now make sure that there was change */			for (c=0; c<notu; ++c)	{				if (invmatrix[ch][c]!=matrix[c][ch])	ev=1;				invmatrix[ch][c]=matrix[c][ch];				}			}	/* end routine for clade */		}	/** END ROUTINE FOR ORDERED MULTISTATES **/	/* Unordered Multistate Characters */	else if (ctype[ch]==1)	{		if (sp<notu && (matrix[sp][ch]!=UNKNOWN && matrix[sp][ch]!=INAP))	{			invmatrix[ch][sp]=matrix[sp][ch]=mswap(matrix[sp][ch],nstates[ch]);			ev=1;			}					else if (sp>notu)	{			evolveunorderedinclade(tree[sp-notu],matrix,ch,nstates[ch],INAP,UNKNOWN);			/* make sure that there is change */			for (a=1; a<=tree[sp-notu][0]; ++a)	{				sp2=tree[sp-notu][a];				if (matrix[sp2][ch]!=INAP && matrix[sp2][ch]!=UNKNOWN)	{					if (invmatrix[ch][sp2]!=matrix[sp2][ch])	{						invmatrix[ch][sp2]=matrix[sp2][ch];						ev=1;						}					}				}			}	/* end unordered change for a clade */			/* if change is made, tally */		}	/* end unordered change */	/* if ev = 1, then there has been a change.  Tally it */	if (ev==1)	{		++deltas;		taxachange[ch][steps[ch]]=sp;		++steps[ch];		++mpd[sp];		}		}	/* end additional steps */free_ivector(der);free_ivector(mpd);free_ivector(trpd);free_ivector(steps);free_ivector(available);free_ivector(branches);free_ivector(aptaxa);free_imatrix(taxachange,nchars,mxdel);free_lmatrix(invmatrix,nchars, notu);return matrix;}