#define geography#include "geography.h"//#define PI 3.141592654fdouble cartesiandistance(double lat1, double lng1, double lat2, double lng2){double	X1, X2, Y1, Y2, Z1, Z2;double	dotproduct, theta, distancekm=0.0f;if (lat1!=lat2 || lng1!=lng2)	{	X1 = (cos(lat1*(PI/180)))*(cos(lng1*(PI/180)));	Y1 = (cos(lat1*(PI/180)))*(sin(lng1*(PI/180)));	Z1 = sin(lat1*(PI/180));	X2 = (cos(lat2*(PI/180)))*(cos(lng2*(PI/180))); 	Y2 = (cos(lat2*(PI/180)))*(sin(lng2*(PI/180)));	Z2 = sin(lat2*(PI/180));	dotproduct=(X1*X2)+(Y1*Y2)+(Z1*Z2);	theta=acos(dotproduct)*180/PI;	if (theta>180)	theta=360-theta;	/* if you go over halfway around the world, then reverse!	*/	distancekm=(theta/360)*2*PI*RAD;	}return (distancekm);}unsigned long **taxoncollectionscount(unsigned long **Data, int Taxa, int Bins, int N, int BinCol, int TaxCol){int	i, b, t;unsigned long **results;results=ulmatrix(Taxa, Bins);for (i=0; i<N; ++i)	{	b=Data[i][BinCol];	t=Data[i][TaxCol];	++results[t][b];	}return (results);}unsigned long *bincollectionscount(unsigned long **Data, int Bins, int N, int BinCol, int CollCol){int	i, b, c;unsigned long *results;results=ulvector(Bins);b=Data[0][BinCol];results[b]=1;for (i=1; i<N; ++i)	{	b=Data[i][BinCol];	c=Data[i][CollCol];	if (b!=Data[i-1][BinCol] || c!=Data[i-1][CollCol])		++results[b];	}return (results);}/*First you put lat long in x,y,z coordinates.#define PI 3.141592654f				/* constant pi					 void Sample::computeXYZcoordinates(){float PI = 3.141592654;float degrad = PI/180;X = ((cos(Lat*degrad))*(cos(Long*degrad))); Y = ((cos(Lat*degrad))*(sin(Long*degrad)));Z = sin(Lat*degrad);}next you calculate distance.void RangeShift::calculateDotProduct(){float PI = 3.141592657;Dotproduct = (CartCentX1 * CartCentX2) + (CartCentY1 * CartCentY2) + (CartCentZ1 * CartCentZ2);Theta = (acos(Dotproduct)) * (180/PI);DistanceKm = (Theta/360)*2*PI*6370.9;}CartCentX, Y and Z are the same as the X, Y, Z in the first function for your purposes.I was calculating the centroid before I calculate range shifts.Obviously, X1 and X2 are from the two points you want to calculate distance between.*/