#define mcmc#include "mcmc.h"#include "memory.h"#include "minmax.h"#include "probability.h"#include "stratocladistics.h"#include "tree_likelihood.h"//int GibbsSample (int argc, char *argv)double **GibbsSample (int n, double rho){long i;double x,y,sd;double **Gibbs;Gibbs=dmatrix(2,n);//gsl_rng *r = gsl_rng_alloc(gsl_rng_mt19937);//n=(long) atoi(argv[1]);//rho=(double) atof(argv[2]);sd=sqrt(1-rho*rho);x=0;y=0;//printf(" %3.3f %3.3f \n",x,y);for (i=1;i<n;i++)	{	Gibbs[0][i]=x=randomnormalZ(rho*y,sd);	Gibbs[1][i]=y=randomnormalZ(rho*x,sd);//	printf(" %3.3f %3.3f \n",x,y);	}return Gibbs;}/* swapbr: routine to swap branches in tree	ape: tree giving ancestral htu of each otu & htu	ttblr: total branches in the tree	notu: number of observed taxa (tips) in tree.****************************************************/void swapbr(long *ape, int ttlbr, int notu){int	a, b, c, d, f, i;a=notu;while (a==notu)	a=(((unsigned int) rand())%ttlbr);if (ape[a]==notu)	{	//		c=ape[a];	d=f=-1;	/* flip notu into node above basal node; pull one descendant of that node to base	*/	for (i=0; i<ttlbr && d==-1; ++i)	{		if (ape[i]==notu && i!=a)	d=i;	/* move node into sister node	*/		}	/* attach one branch to the base	*/	if (d>notu)	{		ape[a]=d;		for (i=0; i<ttlbr && f==-1; ++i)	{			if (ape[i]==d && i!=a)	ape[f=i]=notu;			}	/* attach one branch formerly attached to base to node a-notu	*/		}	/* end case where we flip things into different nodes at the base	*/	else	{		/* find a branch within a and flip that with the outgroup	*/		ape[d]=a;	/* flip outgroup notu->node a	*/		for (i=0; i<ttlbr && f==-1; ++i)	{			if (ape[i]==a && i!=d)	ape[f=i]=notu;	/* flip former daughter taxon -> basal node	*/			}	/* attach one branch formerly attached to base to node a-notu	*/		}	/* end case where the outgroup is a notu	*/	}	/* end case where we flip things around the base of the ape	*/else if (ape[a]!=notu)	{	/* swap ancestors between a & b	*/	c=ape[b=ape[a]];	/* target node	*/	d=imax(b, ttlbr-b);	f=-1;	/* look "up" and "down" until you find the cousin node	*/	for (i=1; (i<=d && f==-1); ++i)	{		if ((b-i)>=0)			if (ape[b-i]==c)	f=b-i;		if ((b+i)<ttlbr && f==-1)			if (ape[b+i]==c)	f=b+i;		}	/* end search for "cousin" to switch	*/	b=ape[a];	ape[a]=ape[f];	ape[f]=b;	}	/* end switch of ancestral nodes	*/}/* swapbrX: routine to swap branch X in tree	ape: tree giving ancestral htu of each otu & htu	ttblr: total branches in the tree	notu: number of observed taxa (tips) in tree.NOTE: use this if you want to do something else with this branch****************************************************************/void swapbrX(long *ape, int ttlbr, int notu, int br){int	b, c, d, f, i;if (ape[br]==notu)	{	//		c=ape[br];	d=f=-1;	/* flip notu into node above basal node; pull one descendant of that node to base	*/	for (i=0; i<ttlbr && d==-1; ++i)	{		if (ape[i]==notu && i!=br)	d=i;	/* move node into sister node	*/		}	/* attach one branch to the base	*/	if (d>notu)	{		ape[br]=d;		for (i=0; i<ttlbr && f==-1; ++i)	{			if (ape[i]==d && i!=br)	ape[f=i]=notu;			}	/* attach one branch formerly attached to base to node br-notu	*/		}	/* end case where we flip things into different nodes at the base	*/	else	{		/* find a branch within br and flip that with the outgroup	*/		ape[d]=br;	/* flip outgroup notu->node br	*/		for (i=0; i<ttlbr && f==-1; ++i)	{			if (ape[i]==br && i!=d)	ape[f=i]=notu;	/* flip former daughter taxon -> basal node	*/			}	/* attach one branch formerly attached to base to node br-notu	*/		}	/* end case where the outgroup is br notu	*/	}	/* end case where we flip things around the base of the ape	*/else if (ape[br]!=notu)	{	/* swap ancestors between br & b	*/	c=ape[b=ape[br]];	/* target node	*/	d=imax(b, ttlbr-b);	f=-1;	/* look "up" and "down" until you find the cousin node	*/	for (i=1; (i<=d && f==-1); ++i)	{		if ((b-i)>=0)			if (ape[b-i]==c)	f=b-i;		if ((b+i)<ttlbr && f==-1)			if (ape[b+i]==c)	f=b+i;		}	/* end search for "cousin" to switch	*/	b=ape[br];	ape[br]=ape[f];	ape[f]=b;	}	/* end switch of ancestral nodes	*/}void swapbr2(long *tree, int ttlbr, int notu){int	a, b, d;a=notu;while (a==notu)	b=a =(((unsigned int) rand())%ttlbr);while (b==a || (b==notu || tree[a]==tree[b]))	b=(((unsigned int) rand())%ttlbr);/* swap ancestors between a & b	*/d=tree[a];tree[a]=tree[b];tree[b]=d;}/*void changebd(long **tree, double *bd, int nodes){int	n;n= (((unsigned int) rand())%nodes);}/*	 *************************************************************************************************/double exponentialbranchdurations (double lambda){double p, t;p=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);t=-1*log(1-p)/lambda;return t;}/*	 *************************************************************************************************/void swap_and_recalculate(long *ape, int notu, int nodes, long **statechars, long *charswstates, int maxst, double *alphas, double *betas, int rates, double ***statelikes, double lambda, double **ranges, double **divergences){int	b, c, d, f, i;int br, ttlbr;int	nd1, nd2, HTU;	/* two nodes with different descendants & node on which to start recalculating	*///int desc[100][10], f1[100];ttlbr=notu+nodes;br=notu;while (br==notu)	br=(((unsigned int) rand())%ttlbr);	/* choose a branch to slide down the tree	*//* ID branches that must be altered: basically, that is all nodes with new members, and everything below them	*/if (ape[br]==notu)	{	//		c=ape[br];	d=f=-1;	/* flip notu into node above basal node; pull one descendant of that node to base	*/	for (i=0; i<ttlbr && d==-1; ++i)	{		if (ape[i]==notu && i!=br)	d=i;	/* move node into sister node	*/		}	/* attach one branch to the base	*/	if (d>notu)	{		nd1=ape[br]=d;		for (i=0; i<ttlbr && f==-1; ++i)	{			if (ape[i]==d && i!=br)	nd2=ape[f=i]=notu;			}	/* attach one branch formerly attached to base to node br-notu	*/		}	/* end case where we flip things into different nodes at the base	*/	else	{		/* find a branch within br and flip that with the outgroup	*/		nd1=ape[d]=br;	/* flip outgroup notu->node br	*/		for (i=0; i<ttlbr && f==-1; ++i)	{			if (ape[i]==br && i!=d)	nd2=ape[f=i]=notu;	/* flip former daughter taxon -> basal node	*/			}	/* attach one branch formerly attached to base to node br-notu	*/		}	/* end case where the outgroup is br notu	*/	}	/* end case where we flip things around the base of the ape	*/else if (ape[br]!=notu)	{	/* swap ancestors between br & b	*/	c=ape[b=ape[br]];	/* target node	*/	d=imax(b, ttlbr-b);	f=-1;	/* look "up" and "down" until you find the cousin node	*/	for (i=1; (i<=d && f==-1); ++i)	{		if ((b-i)>=0)			if (ape[b-i]==c)	f=b-i;		if ((b+i)<ttlbr && f==-1)			if (ape[b+i]==c)	f=b+i;		}	/* end search for "cousin" to switch	*/	b=ape[br];	nd1=ape[br]=ape[f];	nd2=ape[f]=b;	}	/* end switch of ancestral nodes	*/if (nd1==notu)				HTU=nd2;else if (nd2==notu)			HTU=nd1;else if (ape[nd1]==nd2)		HTU=nd1;else if (ape[nd2]==nd1)		HTU=nd2;else if (ape[nd1]==ape[nd2])	{	c=100;	d=1000;	f=20;	}else	{	c=100;	d=1000;	f=20;	}/* now use our old friend recursion!	*/datecladerealape_pulley(HTU, ape, divergences, nodes, notu);MkSimplePulley(HTU, ape, notu, nodes, divergences, statechars, charswstates, maxst, alphas, betas, rates, statelikes, lambda);}change_branch_length(long *ape, int notu, int nodes, long **statechars, long *charswstates, int maxst, double *alphas, double *betas, int rates, double ***statelikes, double lambda, double **ranges, double **divergences){int d, br, ttlbr, HTU;int desc[10];double  x, y;double ble, blu;    ttlbr=notu+nodes;br=notu;while (br==notu)	br=(((unsigned int) rand())%ttlbr);	/* choose a branch to slide down the tree	*/HTU=ape[br];x=(((unsigned int) rand())%RAND_MAX)/((double) RAND_MAX);y=-1*exp(x);    /* this will be the proportional change to the branch length in question    */for (d=0; d<nodes+notu; ++d)	{    if (ape[d]==HTU)	{        desc[f1]=d;	/* make list of descendants	*/        div[f1]=divergences[d][0];        if (divergences[d][1]<ble)	ble=divergences[d][1];	/* oldest divergence time among descendants		*/        if (divergences[d][0]>blu)	blu=divergences[d][0];	/* youngest divergence time among descendants	*/        ++f1;        }	}    /* find ancestral node; see if we can drag the branch up this far; if not, then drag sister-taxon's branch up that far  */for (d=0; d<(notu+nodes); ++d)  {    if (d!=br && ape[d]==HTU)   {                }    }        datecladerealape_pulley(HTU, ape, divergences, nodes, notu);}